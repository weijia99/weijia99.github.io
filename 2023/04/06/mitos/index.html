<!DOCTYPE html><html data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>mitos | Hexo</title><meta name="keywords" content="操作系统,公开课"><meta name="author" content="weijia"><meta name="copyright" content="weijia"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="6.S081这是mit的公开课，使用xv6来自己实现一个小的操作系统。 0.预备环节0.1安装linux本人直接使用的是wsl，安装的是debian系统，可以参照官网的实验步骤。唯一的坑点就是git残酷使用的ssh，不知道是梯子问题，还是校园网问题，一直git不了，课允许lan，一直没有反应，最后还是直接在windows下使用git http才弄下来。 0.2安装vscodevscode主要是讲解">
<meta property="og:type" content="article">
<meta property="og:title" content="mitos">
<meta property="og:url" content="http://yoursite.com/2023/04/06/mitos/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="6.S081这是mit的公开课，使用xv6来自己实现一个小的操作系统。 0.预备环节0.1安装linux本人直接使用的是wsl，安装的是debian系统，可以参照官网的实验步骤。唯一的坑点就是git残酷使用的ssh，不知道是梯子问题，还是校园网问题，一直git不了，课允许lan，一直没有反应，最后还是直接在windows下使用git http才弄下来。 0.2安装vscodevscode主要是讲解">
<meta property="og:locale">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-04-06T14:24:59.000Z">
<meta property="article:modified_time" content="2023-04-29T02:41:24.506Z">
<meta property="article:author" content="weijia">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="公开课">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2023/04/06/mitos/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'mitos',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-29 10:41:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">mitos</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-04-06T14:24:59.000Z" title="Created 2023-04-06 22:24:59">2023-04-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-04-29T02:41:24.506Z" title="Updated 2023-04-29 10:41:24">2023-04-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="mitos"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="6-S081"><a href="#6-S081" class="headerlink" title="6.S081"></a>6.S081</h1><p>这是mit的公开课，使用xv6来自己实现一个小的操作系统。</p>
<h2 id="0-预备环节"><a href="#0-预备环节" class="headerlink" title="0.预备环节"></a>0.预备环节</h2><h3 id="0-1安装linux"><a href="#0-1安装linux" class="headerlink" title="0.1安装linux"></a>0.1安装linux</h3><p>本人直接使用的是wsl，安装的是debian系统，可以参照官网的实验步骤。唯一的坑点就是git残酷使用的ssh，不知道是梯子问题，还是校园网问题，一直git不了，课允许lan，一直没有反应，最后还是直接在windows下使用git http才弄下来。</p>
<h3 id="0-2安装vscode"><a href="#0-2安装vscode" class="headerlink" title="0.2安装vscode"></a>0.2安装vscode</h3><p>vscode主要是讲解如何来配置wsl。需要安装2个插件，一个wsl还有一个是c语言插件。然后重点就是下面三个文件的配置，一个task，一个launch，还有一个是c++——properties，参考下面的连接</p>
<p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/cpp/config-wsl">Visual Studio Code 中的 Linux C++ 和 Windows 子系统入门</a></p>
<ol>
<li>tasks。json（配置编译器的位置，还有编译时候所需要的参数-o，-g</li>
<li>这个是调试选项launch，这个是放入gdb的，有工作目录，还有调试的程序</li>
<li>最后一个properties就是配置gcc还有gdb的位置</li>
</ol>
<h2 id="1-lab-util"><a href="#1-lab-util" class="headerlink" title="1.lab util"></a>1.lab util</h2><p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/util.html">Lab: Xv6 and Unix utilities (mit.edu)</a></p>
<p><a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec01-introduction-and-examples">Lec01 Introduction and Examples (Robert) - MIT6.S081 (gitbook.io)</a></p>
<p><a target="_blank" rel="noopener" href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c1/s0.html">第一章 操作系统接口 · 6.S081 All-In-One (dgs.zone)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.rayzhang.top/2022/06/27/mit-6.s081-lab-util/">MIT 6.S081 Lab Util 实验 | Ray’s Blog (rayzhang.top)</a></p>
<p>本次实验主要参考以上四个网站,视频没有看,直接看的博主翻译的文稿,感觉翻译的文稿比视频好很多.</p>
<p>考研的时候学过操作系统了的,就没怎么看视频,直接找的几个重点章节看了一下.现在复习一下基础知识.</p>
<p><a target="_blank" rel="noopener" href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c1/s0.html">第一章 操作系统接口 · 6.S081 All-In-One (dgs.zone)</a></p>
<p>直接看这本书就行,主要第一张江的是进程相关的内容,应该算进程管理吧.</p>
<h3 id="1-1进程和内存"><a href="#1-1进程和内存" class="headerlink" title="1.1进程和内存"></a>1.1进程和内存</h3><p>用户态通过调用内核态的fork接口来进行创建内存,对于子进程来讲,自己的pid是0,但是对于父进程来讲,自己的pid是大于0的,因此,我们考研来进行判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fork()在父进程中返回子进程的PID</span></span><br><span class="line"><span class="comment">// 在子进程中返回0</span></span><br><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">    pid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个是会反应两个结果的,一个是父进程输出parent,通过调用fork达到子进程,此时自己的pid是0,所以输出child</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent: child=1234</span><br><span class="line">child: exiting</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时我们可以使用exec来执行相关shell命令,直接在用户太执行.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char* argv[3];</span><br><span class="line">argv[0] = &quot;echo&quot;;</span><br><span class="line">argv[1] = &quot;hello&quot;;</span><br><span class="line">argv[2] = 0;</span><br><span class="line">exec(&quot;/bin/echo&quot;, argv);</span><br><span class="line">printf(&quot;exec error\n&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-2-I-x2F-O和文件描述符"><a href="#1-2-I-x2F-O和文件描述符" class="headerlink" title="1.2 I&#x2F;O和文件描述符"></a>1.2 I&#x2F;O和文件描述符</h3><p>主要讲的是io的读取和写入的api使用,使用write还有read.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span> buf);</span><br></pre></td></tr></table></figure>

<p>0代表标准输入流,就是我们输入的东西,buf就是要接受储存的字符串,最后一个是长度,我要接受多长的字符串.</p>
<p>同理,write就是写入,这个是写入到标准输出流.第一个是要写的保存的地方,然后就是要写的字符串,还有长度.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>



<h3 id="1-3-管道"><a href="#1-3-管道" class="headerlink" title="1.3 管道"></a>1.3 管道</h3><p>管道就是用于进程通信的,一个用来读取,一个写入 .只能单向联通,半双工.写入的时候读取必须关闭.</p>
<p>使用方法就是创建一个二位数组,通过pipe来进行调用创建管道,使用close来关闭管道一端然后调用上次的read还有write方法来进行读取还有写入.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序调用<code>pipe</code>，创建一个新的管道，并在数组p中记录读写文件描述符。在<code>fork</code>之后，父子进程都有指向管道的文件描述符。子进程调用<code>close</code>和<code>dup</code>使文件描述符0指向管道的读取端（前面说过优先分配最小的未使用的描述符），然后关闭p中所存的文件描述符，并调用<code>exec</code>运行<code>wc</code>。当<code>wc</code>从它的标准输入读取时，就是从管道读取。父进程关闭管道的读取端，写入管道，然后关闭写入端。</p>
<blockquote>
<p>接起来。然后对管道的左端调用<code>fork</code>和<code>runcmd</code>，对管道的右端调用<code>fork</code>和<code>runcmd</code>，并等待两者都完成。管道的右端可能是一个命令，该命令本身包含一个管道(例如，<code>a | b | c</code>)，该管道本身<code>fork</code>为两个新的子进程(一个用于b，一个用于c)。因此，shell可以创建一个进程树。这个树的叶子是命令，内部节点是等待左右两个子进程完成的进程。</p>
</blockquote>
<p>队友左右节点都是自己进行创建一个新的fork然后执行之后来返回</p>
<h3 id="1-4-文件系统"><a href="#1-4-文件系统" class="headerlink" title="1.4 文件系统"></a>1.4 文件系统</h3><p>文件系统就是文件分为文件还有文件夹,文件夹是一个特殊的数据结构,里面包含当前文件夹的所有名称还有他的大小.</p>
<p>通过调用这个方法来得到答案</p>
<p>这个stat是类型,如果是文件夹还有一个数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR 1    <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE 2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE 3 <span class="comment">// Device</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> dev;     <span class="comment">// 文件系统的磁盘设备</span></span><br><span class="line">    uint ino;    <span class="comment">// Inode编号</span></span><br><span class="line">    <span class="type">short</span> type;  <span class="comment">// 文件类型</span></span><br><span class="line">    <span class="type">short</span> nlink; <span class="comment">// 指向文件的链接数</span></span><br><span class="line">    uint64 size; <span class="comment">// 文件字节数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="1-5实验"><a href="#1-5实验" class="headerlink" title="1.5实验"></a>1.5实验</h3><h4 id="1-5-1boot"><a href="#1-5-1boot" class="headerlink" title="1.5.1boot"></a>1.5.1boot</h4><p>启动过程,首先就是git’数据,直接登录网页使用github来进行下载,使用ssh一直卡死.之后切换分支到util就行,然后执行 make qemu.毕竟这个实验是在qemu上进行模拟的</p>
<h4 id="1-5-2sleep-easy"><a href="#1-5-2sleep-easy" class="headerlink" title="1.5.2sleep (easy)"></a>1.5.2sleep (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h4><p>实现sleep函数.我们可以根据下面提示来进行做</p>
<blockquote>
<ul>
<li>Before you start coding, read Chapter 1 of the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">xv6 book</a>.</li>
<li>Look at some of the other programs in <code>user/</code> (e.g., <code>user/echo.c</code>, <code>user/grep.c</code>, and <code>user/rm.c</code>) to see how you can obtain the command-line arguments passed to a program.</li>
<li>If the user forgets to pass an argument, sleep should print an error message.</li>
<li>The command-line argument is passed as a string; you can convert it to an integer using <code>atoi</code> (see user&#x2F;ulib.c).</li>
<li>Use the system call <code>sleep</code>.</li>
<li>See <code>kernel/sysproc.c</code> for the xv6 kernel code that implements the <code>sleep</code> system call (look for <code>sys_sleep</code>), <code>user/user.h</code> for the C definition of <code>sleep</code> callable from a user program, and <code>user/usys.S</code> for the assembler code that jumps from user code into the kernel for <code>sleep</code>.</li>
<li>Make sure <code>main</code> calls <code>exit()</code> in order to exit your program.</li>
<li>Add your <code>sleep</code> program to <code>UPROGS</code> in Makefile; once you’ve done that, <code>make qemu</code> will compile your program and you’ll be able to run it from the xv6 shell.</li>
<li>Look at Kernighan and Ritchie’s book <em>The C programming language (second edition)</em> (K&amp;R) to learn about C.</li>
</ul>
</blockquote>
<p>看ls是如何获取到参数的,如果没有参数,直接反悔哦失败,传递的参数是字符串,你需要使用atoi,直接使用系统调用的sleep功能.然后调用exit来推出这个程序.最后把这个给功能加入到makefile里面.</p>
<p>上面已经给出了了具体思路,我们只需要写代码就行.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: sleep &lt;ticks&gt;\n&quot;</span>);  <span class="comment">//参数数量不正确，打印错误信息</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> time = atoi(argv[<span class="number">1</span>]);  <span class="comment">//使用atoi转换，见user.h和ulib.c</span></span><br><span class="line">    sleep(time);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>argc是参数个数,argv是参数字符串列表,如果c&lt;2就是不合法,然后直接进行执行调用系统api.之后就是加入到makefile里面.</p>
<h4 id="1-5-3pingpong-easy"><a href="#1-5-3pingpong-easy" class="headerlink" title="1.5.3pingpong (easy)"></a>1.5.3pingpong (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h4><p>实现pingpong功能就是,具体要求就是两个管道,一个父亲写,儿子读取,一个儿子读取谷歌的父亲管道,然后写入到自己的管道,父亲来读取.使用wait可以保真先后顺序.</p>
<blockquote>
<p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</pid></pid></pid></p>
</blockquote>
<blockquote>
<ul>
<li>Use <code>pipe</code> to create a pipe.</li>
<li>Use <code>fork</code> to create a child.</li>
<li>Use <code>read</code> to read from the pipe, and <code>write</code> to write to the pipe.</li>
<li>Use <code>getpid</code> to find the process ID of the calling process.</li>
<li>Add the program to <code>UPROGS</code> in Makefile.</li>
<li>User programs on xv6 have a limited set of library functions available to them. You can see the list in <code>user/user.h</code>; the source (other than for system calls) is in <code>user/ulib.c</code>, <code>user/printf.c</code>, and <code>user/umalloc.c</code>.</li>
</ul>
</blockquote>
<p>根据上面提示,使用pipe创建两个管道,然后使用fork创建孩子进程,之后是以哦那个read来读取,和write来写入.注意要进行关闭管道的一端.只允许单项流通.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[] = &#123;<span class="string">&#x27;P&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> parent2child[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> child2parent[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(parent2child) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create pipe parent2child\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(child2parent) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create pipe child2parent\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();  <span class="comment">// create child process</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create the child process!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child process, read from pipe parent2child,</span></span><br><span class="line">        <span class="comment">// write to pipe child2parent</span></span><br><span class="line">        close(parent2child[<span class="number">1</span>]);</span><br><span class="line">        close(child2parent[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (read(parent2child[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Child: Failed to read from pipe parent2child!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">        <span class="keyword">if</span> (write(child2parent[<span class="number">1</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Child: Failed to write to pipe child2parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent process, write to pipe parent2child,</span></span><br><span class="line">        <span class="comment">// read from pipe child2parent</span></span><br><span class="line">        close(parent2child[<span class="number">0</span>]);</span><br><span class="line">        close(child2parent[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (write(parent2child[<span class="number">1</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Failed to write to pipe parent2child!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (read(child2parent[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to read from pipe child2parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先if的是孩子进程,所以我们关闭父亲写入的,来进行读取,同时关闭孩子的读取来进行写入,把读取的写入到矮子里面.之后就是父亲,父亲是自己先进行写入,然后读取孩子的,也要进行关闭程序.</p>
<h4 id="1-5-4primes-moderate-x2F-hard"><a href="#1-5-4primes-moderate-x2F-hard" class="headerlink" title="1.5.4primes (moderate)&#x2F;(hard)"></a>1.5.4primes (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)&#x2F;(<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</h4><blockquote>
<h4 id="write-a-concurrent-version-of-prime-sieve-using-pipes-This-idea-is-due-to-Doug-McIlroy-inventor-of-Unix-pipes-The-picture-halfway-down-this-page-and-the-surrounding-text-explain-how-to-do-it-Your-solution-should-be-in-the-file-user-primes-c"><a href="#write-a-concurrent-version-of-prime-sieve-using-pipes-This-idea-is-due-to-Doug-McIlroy-inventor-of-Unix-pipes-The-picture-halfway-down-this-page-and-the-surrounding-text-explain-how-to-do-it-Your-solution-should-be-in-the-file-user-primes-c" class="headerlink" title="write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user/primes.c."></a>write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a target="_blank" rel="noopener" href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</h4></blockquote>
<p>题目要求,并发使用管道来进行读取输出2-35的素数.思路是一个写入2-35的管道,另外一个管道来进行输出.</p>
<blockquote>
<ul>
<li>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</li>
<li>Once the first process reaches 35, it should wait until the entire pipeline terminates, including all children, grandchildren, &amp;c. Thus the main primes process should only exit after all the output has been printed, and after all the other primes processes have exited.</li>
<li>Hint: <code>read</code> returns zero when the write-side of a pipe is closed.</li>
<li>It’s simplest to directly write 32-bit (4-byte) <code>int</code>s to the pipes, rather than using formatted ASCII I&#x2F;O.</li>
<li>You should create the processes in the pipeline only as they are needed.</li>
<li>Add the program to <code>UPROGS</code> in Makefile.</li>
</ul>
</blockquote>
<p>这个提示没什么用,直接看的大佬的版本,思路就是使用快速筛,蠡口上有讲解.主要思路就是第一遍把2的倍数全被设置true,剩下的从false里面读取,如果是当前的倍数的,也设置成true,指导到最后一个值.(这个给可以使用并发执行).</p>
<blockquote>
<p>所以这个问题就像是流水线一样，第一个进程将 <code>2~n</code> 依次写给第二个进程，第二个进程筛选非 <code>2</code> 倍数的数输出给第三个进程，第三个进程筛选非 <code>3</code> 倍数的数给第四个进程… 以此类推，单个阶段不一定要全部做完才交给后一阶段，完全可以像流水线一样进行。</p>
<p>我们的目标是使用 <code>pipe</code> 和 <code>fork</code> 来实现这样的流水线，我们将处理 <code>2~35</code> 的数字，进行素数筛。由于 xv6 的文件描述符和进程数量有限，第一个进程可以在 <code>35</code> 时停止。</p>
</blockquote>
<p>使用wait来保真先后顺序,父亲之后才是孩子.在每一个管道的最后一端加入-1,代表管道内容已经结束了.</p>
<p>整体代码,蠡口刷多了,写起来不是会很费力的.读取老的管道,同时把数字写入到新的管道,创建新进程调用新的管道作为输入,注意也要在最后加入-1作为结尾</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prime_num 35</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_child</span><span class="params">(<span class="type">int</span> *read_pipe)</span> &#123;</span><br><span class="line">    close(read_pipe[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> n, status;</span><br><span class="line">    <span class="keyword">if</span> ((status = read(read_pipe[<span class="number">0</span>], &amp;n, <span class="keyword">sizeof</span>(<span class="type">int</span>))) == <span class="number">0</span>) &#123; <span class="comment">// fetch the first number in the row</span></span><br><span class="line">        close(read_pipe[<span class="number">0</span>]);  <span class="comment">// no more numbers in the pipeline</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(status == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to read from pipe!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, n);  <span class="comment">// print out the first number as the prime</span></span><br><span class="line">    <span class="type">int</span> parent_pipe[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(parent_pipe) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create pipe!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create child process!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(read_pipe[<span class="number">0</span>]);</span><br><span class="line">        run_child(parent_pipe);  <span class="comment">// receive number in the new child process</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(parent_pipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="keyword">while</span> ((status = read(read_pipe[<span class="number">0</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">// filter and send numbers to new child process</span></span><br><span class="line">            <span class="keyword">if</span> (num % n != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(write(parent_pipe[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to write to pipe!\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(status == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to read from pipe!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(parent_pipe[<span class="number">1</span>]);</span><br><span class="line">        wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> input_pipe[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(input_pipe) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create pipe!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create child process!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        run_child(input_pipe); <span class="comment">// child process to filter the numbers</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(input_pipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= prime_num; i++) &#123; <span class="comment">// send 2~35 to the child process</span></span><br><span class="line">            <span class="keyword">if</span>(write(input_pipe[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to write to pipe!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(input_pipe[<span class="number">1</span>]);</span><br><span class="line">        wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="1-5-5find-moderate"><a href="#1-5-5find-moderate" class="headerlink" title="1.5.5find (moderate)"></a>1.5.5find (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h4><p>实现查找功能</p>
<blockquote>
<ul>
<li>Look at user&#x2F;ls.c to see how to read directories.</li>
<li>Use recursion to allow find to descend into sub-directories.</li>
<li>Don’t recurse into “.” and “..”.</li>
<li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li>
<li>You’ll need to use C strings. Have a look at K&amp;R (the C book), for example Section 5.5.</li>
<li>Note that &#x3D;&#x3D; does not compare strings like in Python. Use strcmp() instead.</li>
<li>Add the program to <code>UPROGS</code> in Makefile</li>
</ul>
</blockquote>
<p>提示是要我们区看ls的实现,ls把通过switch来对不同的来做判断,我们的现在要求就是根据判断末尾是不是要查找的目标,来进行输出.那么这一个题目就是变成字符串的截取题目.因为对c不是很熟.所以对这个题的代码卡了很久.char *a&#x3D;p.a&#x3D;a+strlen(a).这个意思是把a得到位置移动到最末尾,通过这样就变成截取字符串的操作.</p>
<ol>
<li>首先对与目标我们加上&#x2F;,因为每一个文件都是&#x2F;a&#x2F;a&#x2F;b这样的</li>
<li>然后我们使用ls一样的测策略,对于文件,移动到和目标文件一样长的地方,看他们想不想等,相等就进行输出</li>
<li>对于文件夹,我们使用递归,但是对于&#x2F;..还有&#x2F;.这个文件夹我们就不在进行递归 </li>
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory is a file containing a sequence of dirent structures.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>文件夹的数据结构</p>
<p>实现代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="comment">// Find first character after last slash.</span></span><br><span class="line">    <span class="keyword">for</span> (p = path + <span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">        ;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//返回末尾的文件名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *directory, <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(directory, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot open %s\n&quot;</span>, directory);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot stat %s\n&quot;</span>, directory);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123; <span class="comment">//查看路径类型</span></span><br><span class="line">        <span class="keyword">case</span> T_FILE: <span class="comment">//是文件</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(fmtname(directory), filename) == <span class="number">0</span>) &#123; <span class="comment">//比较路径末尾文件名和查找的文件名</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>, directory);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_DIR: <span class="comment">//是目录</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strlen</span>(directory) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;find: path is too long \n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(buf, directory);</span><br><span class="line">            p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">            *p++ = <span class="string">&#x27;/&#x27;</span>; <span class="comment">//拼凑当前目录路径</span></span><br><span class="line">            <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123; <span class="comment">//遍历目录</span></span><br><span class="line">                <span class="keyword">if</span> (de.inum == <span class="number">0</span> || <span class="built_in">strcmp</span>(<span class="string">&quot;.&quot;</span>, de.name) == <span class="number">0</span> ||</span><br><span class="line">                    <span class="built_in">strcmp</span>(<span class="string">&quot;..&quot;</span>, de.name) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                memmove(p, de.name, DIRSIZ); <span class="comment">//拼凑当前文件路径</span></span><br><span class="line">                p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (stat(buf, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                find(buf, filename); <span class="comment">//调用find递归查找</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: find &lt;directory&gt; &lt;filename&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-lab-syscall"><a href="#2-lab-syscall" class="headerlink" title="2.lab syscall"></a>2.lab syscall</h2><p><a target="_blank" rel="noopener" href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c2/s2.html">2.2 用户态，核心态，以及系统调用 · 6.S081 All-In-One (dgs.zone)</a></p>
<p>操作系统的作用是抽象系统同资源,最基本的目的就是互不影响程序,当一个程序出现问题不会影响下一个程序.所以系统管理员是操作系统,他与硬件打交道.</p>
<h3 id="2-2用户态，核心态，以及系统调用"><a href="#2-2用户态，核心态，以及系统调用" class="headerlink" title="2.2用户态，核心态，以及系统调用"></a>2.2用户态，核心态，以及系统调用</h3><p>用户态和和心态,和心态就是直接与硬件打交道的</p>
<p>核心态可以使用特权指令,用户通过条用内核函数的程序,把用户态转移到和心态,然后 在内核指定的路口,进入内核(ecall函数)需要写entry(write),然后通过设置一个数字作为这个函数的映射,内核太调用这个数字实际对那个内核里面的函数来实现方法</p>
<p><img src="https://blog.rayzhang.top/2022/07/05/mit-6.s081-lab-syscall/syscall_fork.png"></p>
<p>syscall调用sysproc实际方法</p>
<h3 id="2-3内核组织"><a href="#2-3内核组织" class="headerlink" title="2.3内核组织"></a>2.3内核组织</h3><p>分为大内核还有小内核,大内核就是和Windows差不多,所以的硬件功能都已经实现,小内核就是自己要实现文件这中内核操作,通过组合操作.</p>
<h3 id="2-4进程"><a href="#2-4进程" class="headerlink" title="2.4进程"></a>2.4进程</h3><p>进程都有自己的结构体,有自己的状态,还有自己的页表(页表,就是一个进程的虚拟地址空间)</p>
<h3 id="2-5实验"><a href="#2-5实验" class="headerlink" title="2.5实验"></a>2.5实验</h3><h4 id="2-5-1System-call-tracing-moderate"><a href="#2-5-1System-call-tracing-moderate" class="headerlink" title="2.5.1System call tracing (moderate)"></a>2.5.1System call tracing (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h4><p>实现追踪功能,然后追踪的进程的mask是这样得到 <code>trace(1 &lt;&lt; SYS_fork)</code>,这个参数可以通过argint得到</p>
<blockquote>
<ul>
<li>Add <code>$U/_trace</code> to UPROGS in Makefile</li>
<li>Run make qemu and you will see that the compiler cannot compile <code>user/trace.c</code>, because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. Once you fix the compilation issues, run trace 32 grep hello README; it will fail because you haven’t implemented the system call in the kernel yet.</li>
<li>Add a <code>sys_trace()</code> function in <code>kernel/sysproc.c</code> that implements the new system call by remembering its argument in a new variable in the <code>proc</code> structure (see <code>kernel/proc.h</code>). The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, and you can see examples of their use in <code>kernel/sysproc.c</code>.</li>
<li>Modify <code>fork()</code> (see <code>kernel/proc.c</code>) to copy the trace mask from the parent to the child process.</li>
<li></li>
</ul>
</blockquote>
<p>给定的提示,我们直接运行make是无法编译成功的.提示是因为无法编译trace.c,因为这个给用户态的功能trace在内核态没有对应实现,我们需要实现.首先就是在userh里面添加trace功能(申明,系统提供的api).之后区usys添加入口,这是上面的陷入,然后添加一个数值在syscall</p>
<blockquote>
<p>because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. </p>
</blockquote>
<p>尽管添加了之后,你还是没有办法实现,因为你要实现systrace功能在sysproc里面,我们需要把追踪的进程的掩码设置成传入的参数,通过argint得到mask,之后对于该进程创建的子进程,我们也许奥把掩码设置成先对应的mask(复制操作,只需要更改fork的逻辑就行),最后我们把掩码一样的在syscall里进行输出.</p>
<p><strong>这个题的主要重点,就是让我们了解到系统调用的流程,首先是在user里面注册系统调用函数,然后通过entry进行陷入这个函数,之后调用特殊的数值,来作为系统调用的参数.然后我们在sysproc具体实现这个功能</strong></p>
<p>主要 的流程就是上图所示</p>
<blockquote>
<p>所以，需要有一种方式能够让应用程序可以将控制权转移给内核（Entering Kernel）。</p>
<p>在RISC-V中，有一个专门的指令用来实现这个功能，叫做ECALL。ECALL接收一个数字参数，当一个用户程序想要将程序执行的控制权转移到内核，它只需要执行ECALL指令，并传入一个数字。这里的数字参数代表了应用程序想要调用的System Call。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MJX963vbIPHKetjGrZN%2F-MJXAkJxD8pTZOm1Tay_%2Fimage.png?alt=media&token=cf3e26a2-3c26-43b8-aee0-6d5787f8dcf5" alt="img"></p>
<p>ECALL会跳转到内核中一个特定，由内核控制的位置。我们在这节课的最后可以看到在XV6中存在一个唯一的系统调用接入点，每一次应用程序执行ECALL指令，应用程序都会通过这个接入点进入到内核中。举个例子，不论是Shell还是其他的应用程序，当它在用户空间执行fork时，它并不是直接调用操作系统中对应的函数，而是调用ECALL指令，并将fork对应的数字作为参数传给ECALL。之后再通过ECALL跳转到内核。</p>
<p>下图中通过一根竖线来区分用户空间和内核空间，左边是用户空间，右边是内核空间。在内核侧，有一个位于syscall.c的函数syscall，每一个从应用程序发起的系统调用都会调用到这个syscall函数，syscall函数会检查ECALL的参数，通过这个参数内核可以知道需要调用的是fork（3.9会有相应的代码跟踪介绍）。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MJX963vbIPHKetjGrZN%2F-MJXO2n90L0ziqU8mTcg%2Fimage.png?alt=media&token=754f49c1-58a2-42d5-9427-094fc95ab613" alt="img"></p>
</blockquote>
<ol>
<li>在makefile进行注册</li>
<li>在user里面进行注册函数trace在sys里面进行进入entry</li>
<li>之后在syscall里面进行设置特殊的数值</li>
<li>然后调用这个sys_trace,之后在sysproc里实现(思路就是调用新的trace函数)</li>
<li>trace函数就是把当前mask传给当前进程</li>
<li>然后在syscall调用,调用结束后.我们来对这个掩码做比较,相同就进行输出</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>) &#123;  <span class="comment">//获取trace的参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;               <span class="comment">//获取失败返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trace(mask);  <span class="comment">//调用核心函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个trace函数还需要在defs进行申明,不然没发实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span> mask)</span> &#123; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;mask = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对fork的修改,就是把父进程的mask传授那个给子进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br><span class="line">  np-&gt;cwd = idup(p-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">  np-&gt;mask = p-&gt;mask; <span class="comment">//复制mask掩码</span></span><br><span class="line"></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line"></span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;wait_lock);</span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line">  release(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;np-&gt;lock);</span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>最后根据提示,我们在这里进行符合的输出</p>
<blockquote>
<p>The 32 is <code>1&lt;&lt;SYS_read</code>. In the second exam</p>
</blockquote>
<p>他的逻辑就是把这个给进程进行移动系统的位数,所以我们只要一回来,然后与1,还是1,就说明这个是需要最终的,我们就进行输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(p-&gt;mask &gt;&gt; num &amp; 1) &#123;</span><br><span class="line">      printf(&quot;%d: syscall %s -&gt; %d\n&quot;,p-&gt;pid, syscalls_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;mask &gt;&gt; num &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid, syscalls_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="3-lab-pgtble"><a href="#3-lab-pgtble" class="headerlink" title="3.lab pgtble"></a>3.lab pgtble</h2><h4 id="3-2修改页表"><a href="#3-2修改页表" class="headerlink" title="3.2修改页表"></a>3.2修改页表</h4><p>xv6原始是每个程序共享一个页表,现在要求是自己为每一个程序添加页表,陷入时候使用自己的页表</p>
<h2 id="4-lab-trap"><a href="#4-lab-trap" class="headerlink" title="4.lab trap"></a>4.lab trap</h2><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h3 id="4-1回答问题"><a href="#4-1回答问题" class="headerlink" title="4.1回答问题"></a>4.1回答问题</h3><p>Read the code in call.asm for the functions <code>g</code>, <code>f</code>, and <code>main</code>. The instruction manual for RISC-V is on the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/reference.html">reference page</a>. Here are some questions that you should answer (store the answers in a file answers-traps.txt):</p>
<blockquote>
<p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</p>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816327874591681632783414.png"></p>
<p>a2</p>
<blockquote>
<p>Where is the call to function <code>f</code> in the assembly code for <code>main</code>? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</p>
</blockquote>
<p>显的可以看到在 <code>0x26</code> 位置，程序直接将 <code>12</code> 写入了 <code>a1</code> 寄存器的位置（也就是第二参数 <code>f(8)+1</code> 的位置），在处理完所有的寄存器参数后直接就调用了 <code>printf</code>。那只有一种解释，就是编译器直接计算出了 <code>f(8)+1</code> 的结果是 <code>12</code>，主函数中并没直接调用这两个函数</p>
<blockquote>
<p> At what address is the function <code>printf</code> located?</p>
</blockquote>
<p>根据提示他在628，我们直接收地址628</p>
<p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816337731131681633772533.png"></p>
<p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816338091161681633808486.png"></p>
<blockquote>
<p>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</p>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816340951881681634095159.png"></p>
<p><img src="https://blog.rayzhang.top/2022/09/27/mit-6.s081-lab-traps/jalr.png" alt="img"></p>
<p>34是pc地址，后面的是指令，手册的pc+4，就是34+4&#x3D;38是ra</p>
<blockquote>
<p>Run the following code.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">printf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<p>What is the output? <a target="_blank" rel="noopener" href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p>
<p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set to in order to yield the same output? Would you need to change to a different value?<code>i``57616</code></p>
<p><a target="_blank" rel="noopener" href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a target="_blank" rel="noopener" href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p>
</blockquote>
<p>57616十六进制是e110</p>
<p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816344351111681634434489.png"></p>
<p>下一个是小段对齐（就是最开始第一位是末尾2个字节，最后的才是开始）</p>
<p><img src="https://blog.rayzhang.top/2022/09/27/mit-6.s081-lab-traps/hello-world.jpeg" alt="img"></p>
<blockquote>
<p>In the following code, what is going to be printed after ? (note: the answer is not a specific value.) Why does this happen? <code>&#39;y=&#39;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;x=%d y=%d&quot;, 3);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>a2寄存器没有值，随便产生</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://yoursite.com">weijia</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2023/04/06/mitos/">http://yoursite.com/2023/04/06/mitos/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/%E5%85%AC%E5%BC%80%E8%AF%BE/">公开课</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/12/%E5%AF%B9%E6%8A%97%E6%97%A0%E8%81%8A/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">对抗无聊</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%B0%8F%E7%BB%93/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">深度学习代码小结</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">weijia</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#6-S081"><span class="toc-number">1.</span> <span class="toc-text">6.S081</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E9%A2%84%E5%A4%87%E7%8E%AF%E8%8A%82"><span class="toc-number">1.1.</span> <span class="toc-text">0.预备环节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1%E5%AE%89%E8%A3%85linux"><span class="toc-number">1.1.1.</span> <span class="toc-text">0.1安装linux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-2%E5%AE%89%E8%A3%85vscode"><span class="toc-number">1.1.2.</span> <span class="toc-text">0.2安装vscode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-lab-util"><span class="toc-number">1.2.</span> <span class="toc-text">1.lab util</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.1进程和内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-I-x2F-O%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2 I&#x2F;O和文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%AE%A1%E9%81%93"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.3 管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">1.4 文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%E5%AE%9E%E9%AA%8C"><span class="toc-number">1.2.5.</span> <span class="toc-text">1.5实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1boot"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">1.5.1boot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2sleep-easy"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">1.5.2sleep (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3pingpong-easy"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">1.5.3pingpong (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-4primes-moderate-x2F-hard"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">1.5.4primes (moderate)&#x2F;(hard)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#write-a-concurrent-version-of-prime-sieve-using-pipes-This-idea-is-due-to-Doug-McIlroy-inventor-of-Unix-pipes-The-picture-halfway-down-this-page-and-the-surrounding-text-explain-how-to-do-it-Your-solution-should-be-in-the-file-user-primes-c"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user&#x2F;primes.c.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-5find-moderate"><span class="toc-number">1.2.5.6.</span> <span class="toc-text">1.5.5find (moderate)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-lab-syscall"><span class="toc-number">1.3.</span> <span class="toc-text">2.lab syscall</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E7%94%A8%E6%88%B7%E6%80%81%EF%BC%8C%E6%A0%B8%E5%BF%83%E6%80%81%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.2用户态，核心态，以及系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E5%86%85%E6%A0%B8%E7%BB%84%E7%BB%87"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.3内核组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.4进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E5%AE%9E%E9%AA%8C"><span class="toc-number">1.3.4.</span> <span class="toc-text">2.5实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1System-call-tracing-moderate"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">2.5.1System call tracing (moderate)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-lab-pgtble"><span class="toc-number">1.4.</span> <span class="toc-text">3.lab pgtble</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E4%BF%AE%E6%94%B9%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">3.2修改页表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-lab-trap"><span class="toc-number">1.5.</span> <span class="toc-text">4.lab trap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C"><span class="toc-number">1.5.1.</span> <span class="toc-text">实验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E5%9B%9E%E7%AD%94%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.1回答问题</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/01/mmlab%E7%AE%80%E4%BB%8B/" title="mmlab简介"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mmlab简介"/></a><div class="content"><a class="title" href="/2023/06/01/mmlab%E7%AE%80%E4%BB%8B/" title="mmlab简介">mmlab简介</a><time datetime="2023-06-01T11:50:44.000Z" title="Created 2023-06-01 19:50:44">2023-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/01/deepin%E5%AE%89%E8%A3%85docker/" title="deepin安装docker和pytorch"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="deepin安装docker和pytorch"/></a><div class="content"><a class="title" href="/2023/06/01/deepin%E5%AE%89%E8%A3%85docker/" title="deepin安装docker和pytorch">deepin安装docker和pytorch</a><time datetime="2023-06-01T09:28:58.000Z" title="Created 2023-06-01 17:28:58">2023-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/19/mysql%E5%AD%A6%E4%B9%A0/" title="mysql学习"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql学习"/></a><div class="content"><a class="title" href="/2023/04/19/mysql%E5%AD%A6%E4%B9%A0/" title="mysql学习">mysql学习</a><time datetime="2023-04-19T11:25:58.000Z" title="Created 2023-04-19 19:25:58">2023-04-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/15/pve%E6%8A%98%E8%85%BE/" title="pve折腾"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pve折腾"/></a><div class="content"><a class="title" href="/2023/04/15/pve%E6%8A%98%E8%85%BE/" title="pve折腾">pve折腾</a><time datetime="2023-04-15T13:31:59.000Z" title="Created 2023-04-15 21:31:59">2023-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/12/%E5%AF%B9%E6%8A%97%E6%97%A0%E8%81%8A/" title="对抗无聊"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="对抗无聊"/></a><div class="content"><a class="title" href="/2023/04/12/%E5%AF%B9%E6%8A%97%E6%97%A0%E8%81%8A/" title="对抗无聊">对抗无聊</a><time datetime="2023-04-12T07:49:53.000Z" title="Created 2023-04-12 15:49:53">2023-04-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By weijia</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>