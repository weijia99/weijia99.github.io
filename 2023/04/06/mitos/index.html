<!DOCTYPE html><html data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>mitos | Hexo</title><meta name="keywords" content="操作系统,公开课"><meta name="author" content="weijia"><meta name="copyright" content="weijia"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="6.S081这是mit的公开课，使用xv6来自己实现一个小的操作系统。 0.预备环节0.1安装linux本人直接使用的是wsl，安装的是debian系统，可以参照官网的实验步骤。唯一的坑点就是git残酷使用的ssh，不知道是梯子问题，还是校园网问题，一直git不了，课允许lan，一直没有反应，最后还是直接在windows下使用git http才弄下来。 0.2安装vscodevscode主要是讲解">
<meta property="og:type" content="article">
<meta property="og:title" content="mitos">
<meta property="og:url" content="http://yoursite.com/2023/04/06/mitos/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="6.S081这是mit的公开课，使用xv6来自己实现一个小的操作系统。 0.预备环节0.1安装linux本人直接使用的是wsl，安装的是debian系统，可以参照官网的实验步骤。唯一的坑点就是git残酷使用的ssh，不知道是梯子问题，还是校园网问题，一直git不了，课允许lan，一直没有反应，最后还是直接在windows下使用git http才弄下来。 0.2安装vscodevscode主要是讲解">
<meta property="og:locale">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-04-06T14:24:59.000Z">
<meta property="article:modified_time" content="2023-06-27T14:12:33.954Z">
<meta property="article:author" content="weijia">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="公开课">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2023/04/06/mitos/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'mitos',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-27 22:12:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">92</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">mitos</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-04-06T14:24:59.000Z" title="Created 2023-04-06 22:24:59">2023-04-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-06-27T14:12:33.954Z" title="Updated 2023-06-27 22:12:33">2023-06-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="mitos"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="6-S081"><a href="#6-S081" class="headerlink" title="6.S081"></a>6.S081</h1><p>这是mit的公开课，使用xv6来自己实现一个小的操作系统。</p>
<h2 id="0-预备环节"><a href="#0-预备环节" class="headerlink" title="0.预备环节"></a>0.预备环节</h2><h3 id="0-1安装linux"><a href="#0-1安装linux" class="headerlink" title="0.1安装linux"></a>0.1安装linux</h3><p>本人直接使用的是wsl，安装的是debian系统，可以参照官网的实验步骤。唯一的坑点就是git残酷使用的ssh，不知道是梯子问题，还是校园网问题，一直git不了，课允许lan，一直没有反应，最后还是直接在windows下使用git http才弄下来。</p>
<h3 id="0-2安装vscode"><a href="#0-2安装vscode" class="headerlink" title="0.2安装vscode"></a>0.2安装vscode</h3><p>vscode主要是讲解如何来配置wsl。需要安装2个插件，一个wsl还有一个是c语言插件。然后重点就是下面三个文件的配置，一个task，一个launch，还有一个是c++——properties，参考下面的连接</p>
<p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/cpp/config-wsl">Visual Studio Code 中的 Linux C++ 和 Windows 子系统入门</a></p>
<ol>
<li>tasks。json（配置编译器的位置，还有编译时候所需要的参数-o，-g</li>
<li>这个是调试选项launch，这个是放入gdb的，有工作目录，还有调试的程序</li>
<li>最后一个properties就是配置gcc还有gdb的位置</li>
</ol>
<hr>
<p>开始扩展:</p>
<p>参考这个视频</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Lv411g7EV/?vd_source=ba1e1ba13062afebe588f7479b936272">mit6s081 通过vscode来debug kernel_哔哩哔哩_bilibili</a></p>
<p>一直以来的vscode的配置都是直接抄的别人配置好的,对vscode 的task.json haiyou launch.json都有一种莫名的不要输系感觉.并且对使用用gdb来进行调试c制作的make程序都深恶痛绝.直到今天,看完这个视频,才发现并没有多么的可怕.</p>
<p>下面将要来介绍一下launch.json的配置是为什么</p>
<ol>
<li>首先launch.json这个是用来调试的</li>
<li>调试那么就需要调试器吧,调试器就是gdb</li>
<li>i那位这个riscv,一般的gdb是只能x64,所以需要使用gdb-mul</li>
<li>然后调试的话,你也需要调试的文件吧,文件就是kernel&#x2F;kernel,因为xv6最开始是从kernel启动的</li>
<li>miDebuggerServerAddress这个是远程调试的后端,就是输入make qemu-gdb产生的地址</li>
<li>然后按住F5就可以启动</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// configuration 包含了 gdb 启动的相关信息</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debug xv6&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="comment">// 如果没有下载c/pp插件 这个type会报错</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="comment">// 你需要的调试的二进制文件 , 默认是kernel/kernel ,因为你先得把xv6启动 你才有机会调试xv6上的用户程序</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/kernel/kernel&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="comment">// 是否在kernel的main函数中 打个断点</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="comment">// make qemu-gdb 会启动一个 gdbserver ,你需要指定一个端口,来连接上这个gdb server, 具体端口可以查看.gdbinit</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost:26001&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="comment">// gdb的路径,  gdb可以是gdb-multiarch 也可以是riscv64-linux-gnu-gdb 具体看你安装的是哪个, 如果是ubuntu的话 </span></span><br><span class="line">          <span class="comment">// 应该是gdb-multiarch 比较多</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb-multiarch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pretty printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;logging&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                 <span class="attr">&quot;engineLogging&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                 <span class="attr">&quot;programOutput&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题来了,每次我要进行调试,都要自己手动输入一次make qemu-gdb,那么这就相当于一次任务,我们可以值在执行调试的时候,先执行这个,那么可以顶一个pretask,task.json的任务就是制作一个任务,同理,我们如果按照之前,手工运行的话,可以直接制作一个task,就可以直接运行了</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// launch.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xv6debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/kernel/kernel&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:25000&quot;</span><span class="punctuation">,</span> <span class="comment">//见.gdbinit 中 target remote xxxx:xx</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb-multiarch&quot;</span><span class="punctuation">,</span> <span class="comment">// which gdb-multiarch</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xv6build&quot;</span></span><br><span class="line">            #这里的xv6build就是task的定义</span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tasks.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//指定make qemu的执行位置</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xv6build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;isBackground&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;make qemu-gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;regexp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;beginsPattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.*Now run &#x27;gdb&#x27; in another window.&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;endsPattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者<span class="punctuation">:</span> 扎克蕉</span><br><span class="line">链接<span class="punctuation">:</span> https<span class="punctuation">:</span><span class="comment">//www.515code.com/posts/r1eiw7kt/#1-4-VSCode%E8%B0%83%E8%AF%95</span></span><br><span class="line">来源<span class="punctuation">:</span> <span class="number">515</span>code-实验室</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>常规的c定义</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) Launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++.exe build active file&quot;</span><span class="punctuation">,</span><span class="comment">//调试前执行的任务，就是之前配置的tasks.json中的label字段</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span><span class="comment">//配置类型，只能为cppdbg</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span><span class="comment">//请求配置类型，可以为launch（启动）或attach（附加）</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span><span class="comment">//调试程序的路径名称</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="comment">//调试传递参数</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//true显示外置的控制台窗口，false显示内置终端</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\mingw-w64\\x86_64-8.1.0-win32-seh-rt_v6-rev0\\mingw64\\bin\\gdb.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">#相当于gcc -g file -o x.exe</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558 </span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++.exe build active file&quot;</span><span class="punctuation">,</span><span class="comment">//任务的名字，就是刚才在命令面板中选择的时候所看到的，可以自己设置</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/mingw-w64/x86_64-8.1.0-win32-seh-rt_v6-rev0/mingw64/bin/g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="comment">//编译时候的参数</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span><span class="comment">//添加gdb调试选项</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span><span class="comment">//指定生成可执行文件的名称</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/mingw-w64/x86_64-8.1.0-win32-seh-rt_v6-rev0/mingw64/bin&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="comment">//表示快捷键Ctrl+Shift+B可以运行该任务</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="1-lab-util"><a href="#1-lab-util" class="headerlink" title="1.lab util"></a>1.lab util</h2><p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/util.html">Lab: Xv6 and Unix utilities (mit.edu)</a></p>
<p><a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec01-introduction-and-examples">Lec01 Introduction and Examples (Robert) - MIT6.S081 (gitbook.io)</a></p>
<p><a target="_blank" rel="noopener" href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c1/s0.html">第一章 操作系统接口 · 6.S081 All-In-One (dgs.zone)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.rayzhang.top/2022/06/27/mit-6.s081-lab-util/">MIT 6.S081 Lab Util 实验 | Ray’s Blog (rayzhang.top)</a></p>
<p>本次实验主要参考以上四个网站,视频没有看,直接看的博主翻译的文稿,感觉翻译的文稿比视频好很多.</p>
<p>考研的时候学过操作系统了的,就没怎么看视频,直接找的几个重点章节看了一下.现在复习一下基础知识.</p>
<p><a target="_blank" rel="noopener" href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c1/s0.html">第一章 操作系统接口 · 6.S081 All-In-One (dgs.zone)</a></p>
<p>直接看这本书就行,主要第一张江的是进程相关的内容,应该算进程管理吧.</p>
<h3 id="1-1进程和内存"><a href="#1-1进程和内存" class="headerlink" title="1.1进程和内存"></a>1.1进程和内存</h3><p>用户态通过调用内核态的fork接口来进行创建内存,对于子进程来讲,自己的pid是0,但是对于父进程来讲,自己的pid是大于0的,因此,我们考研来进行判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fork()在父进程中返回子进程的PID</span></span><br><span class="line"><span class="comment">// 在子进程中返回0</span></span><br><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">    pid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个是会反应两个结果的,一个是父进程输出parent,通过调用fork达到子进程,此时自己的pid是0,所以输出child</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent: child=1234</span><br><span class="line">child: exiting</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时我们可以使用exec来执行相关shell命令,直接在用户太执行.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char* argv[3];</span><br><span class="line">argv[0] = &quot;echo&quot;;</span><br><span class="line">argv[1] = &quot;hello&quot;;</span><br><span class="line">argv[2] = 0;</span><br><span class="line">exec(&quot;/bin/echo&quot;, argv);</span><br><span class="line">printf(&quot;exec error\n&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-2-I-x2F-O和文件描述符"><a href="#1-2-I-x2F-O和文件描述符" class="headerlink" title="1.2 I&#x2F;O和文件描述符"></a>1.2 I&#x2F;O和文件描述符</h3><p>主要讲的是io的读取和写入的api使用,使用write还有read.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span> buf);</span><br></pre></td></tr></table></figure>

<p>0代表标准输入流,就是我们输入的东西,buf就是要接受储存的字符串,最后一个是长度,我要接受多长的字符串.</p>
<p>同理,write就是写入,这个是写入到标准输出流.第一个是要写的保存的地方,然后就是要写的字符串,还有长度.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>



<h3 id="1-3-管道"><a href="#1-3-管道" class="headerlink" title="1.3 管道"></a>1.3 管道</h3><p>管道就是用于进程通信的,一个用来读取,一个写入 .只能单向联通,半双工.写入的时候读取必须关闭.</p>
<p>使用方法就是创建一个二位数组,通过pipe来进行调用创建管道,使用close来关闭管道一端然后调用上次的read还有write方法来进行读取还有写入.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序调用<code>pipe</code>，创建一个新的管道，并在数组p中记录读写文件描述符。在<code>fork</code>之后，父子进程都有指向管道的文件描述符。子进程调用<code>close</code>和<code>dup</code>使文件描述符0指向管道的读取端（前面说过优先分配最小的未使用的描述符），然后关闭p中所存的文件描述符，并调用<code>exec</code>运行<code>wc</code>。当<code>wc</code>从它的标准输入读取时，就是从管道读取。父进程关闭管道的读取端，写入管道，然后关闭写入端。</p>
<blockquote>
<p>接起来。然后对管道的左端调用<code>fork</code>和<code>runcmd</code>，对管道的右端调用<code>fork</code>和<code>runcmd</code>，并等待两者都完成。管道的右端可能是一个命令，该命令本身包含一个管道(例如，<code>a | b | c</code>)，该管道本身<code>fork</code>为两个新的子进程(一个用于b，一个用于c)。因此，shell可以创建一个进程树。这个树的叶子是命令，内部节点是等待左右两个子进程完成的进程。</p>
</blockquote>
<p>队友左右节点都是自己进行创建一个新的fork然后执行之后来返回</p>
<h3 id="1-4-文件系统"><a href="#1-4-文件系统" class="headerlink" title="1.4 文件系统"></a>1.4 文件系统</h3><p>文件系统就是文件分为文件还有文件夹,文件夹是一个特殊的数据结构,里面包含当前文件夹的所有名称还有他的大小.</p>
<p>通过调用这个方法来得到答案</p>
<p>这个stat是类型,如果是文件夹还有一个数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR 1    <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE 2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE 3 <span class="comment">// Device</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> dev;     <span class="comment">// 文件系统的磁盘设备</span></span><br><span class="line">    uint ino;    <span class="comment">// Inode编号</span></span><br><span class="line">    <span class="type">short</span> type;  <span class="comment">// 文件类型</span></span><br><span class="line">    <span class="type">short</span> nlink; <span class="comment">// 指向文件的链接数</span></span><br><span class="line">    uint64 size; <span class="comment">// 文件字节数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="1-5实验"><a href="#1-5实验" class="headerlink" title="1.5实验"></a>1.5实验</h3><h4 id="1-5-1boot"><a href="#1-5-1boot" class="headerlink" title="1.5.1boot"></a>1.5.1boot</h4><p>启动过程,首先就是git’数据,直接登录网页使用github来进行下载,使用ssh一直卡死.之后切换分支到util就行,然后执行 make qemu.毕竟这个实验是在qemu上进行模拟的</p>
<h4 id="1-5-2sleep-easy"><a href="#1-5-2sleep-easy" class="headerlink" title="1.5.2sleep (easy)"></a>1.5.2sleep (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h4><p>实现sleep函数.我们可以根据下面提示来进行做</p>
<blockquote>
<ul>
<li>Before you start coding, read Chapter 1 of the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">xv6 book</a>.</li>
<li>Look at some of the other programs in <code>user/</code> (e.g., <code>user/echo.c</code>, <code>user/grep.c</code>, and <code>user/rm.c</code>) to see how you can obtain the command-line arguments passed to a program.</li>
<li>If the user forgets to pass an argument, sleep should print an error message.</li>
<li>The command-line argument is passed as a string; you can convert it to an integer using <code>atoi</code> (see user&#x2F;ulib.c).</li>
<li>Use the system call <code>sleep</code>.</li>
<li>See <code>kernel/sysproc.c</code> for the xv6 kernel code that implements the <code>sleep</code> system call (look for <code>sys_sleep</code>), <code>user/user.h</code> for the C definition of <code>sleep</code> callable from a user program, and <code>user/usys.S</code> for the assembler code that jumps from user code into the kernel for <code>sleep</code>.</li>
<li>Make sure <code>main</code> calls <code>exit()</code> in order to exit your program.</li>
<li>Add your <code>sleep</code> program to <code>UPROGS</code> in Makefile; once you’ve done that, <code>make qemu</code> will compile your program and you’ll be able to run it from the xv6 shell.</li>
<li>Look at Kernighan and Ritchie’s book <em>The C programming language (second edition)</em> (K&amp;R) to learn about C.</li>
</ul>
</blockquote>
<p>看ls是如何获取到参数的,如果没有参数,直接反悔哦失败,传递的参数是字符串,你需要使用atoi,直接使用系统调用的sleep功能.然后调用exit来推出这个程序.最后把这个给功能加入到makefile里面.</p>
<p>上面已经给出了了具体思路,我们只需要写代码就行.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: sleep &lt;ticks&gt;\n&quot;</span>);  <span class="comment">//参数数量不正确，打印错误信息</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> time = atoi(argv[<span class="number">1</span>]);  <span class="comment">//使用atoi转换，见user.h和ulib.c</span></span><br><span class="line">    sleep(time);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>argc是参数个数,argv是参数字符串列表,如果c&lt;2就是不合法,然后直接进行执行调用系统api.之后就是加入到makefile里面.</p>
<h4 id="1-5-3pingpong-easy"><a href="#1-5-3pingpong-easy" class="headerlink" title="1.5.3pingpong (easy)"></a>1.5.3pingpong (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h4><p>实现pingpong功能就是,具体要求就是两个管道,一个父亲写,儿子读取,一个儿子读取谷歌的父亲管道,然后写入到自己的管道,父亲来读取.使用wait可以保真先后顺序.</p>
<blockquote>
<p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</pid></pid></pid></p>
</blockquote>
<blockquote>
<ul>
<li>Use <code>pipe</code> to create a pipe.</li>
<li>Use <code>fork</code> to create a child.</li>
<li>Use <code>read</code> to read from the pipe, and <code>write</code> to write to the pipe.</li>
<li>Use <code>getpid</code> to find the process ID of the calling process.</li>
<li>Add the program to <code>UPROGS</code> in Makefile.</li>
<li>User programs on xv6 have a limited set of library functions available to them. You can see the list in <code>user/user.h</code>; the source (other than for system calls) is in <code>user/ulib.c</code>, <code>user/printf.c</code>, and <code>user/umalloc.c</code>.</li>
</ul>
</blockquote>
<p>根据上面提示,使用pipe创建两个管道,然后使用fork创建孩子进程,之后是以哦那个read来读取,和write来写入.注意要进行关闭管道的一端.只允许单项流通.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[] = &#123;<span class="string">&#x27;P&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> parent2child[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> child2parent[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(parent2child) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create pipe parent2child\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(child2parent) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create pipe child2parent\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();  <span class="comment">// create child process</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create the child process!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child process, read from pipe parent2child,</span></span><br><span class="line">        <span class="comment">// write to pipe child2parent</span></span><br><span class="line">        close(parent2child[<span class="number">1</span>]);</span><br><span class="line">        close(child2parent[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (read(parent2child[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Child: Failed to read from pipe parent2child!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">        <span class="keyword">if</span> (write(child2parent[<span class="number">1</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Child: Failed to write to pipe child2parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent process, write to pipe parent2child,</span></span><br><span class="line">        <span class="comment">// read from pipe child2parent</span></span><br><span class="line">        close(parent2child[<span class="number">0</span>]);</span><br><span class="line">        close(child2parent[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (write(parent2child[<span class="number">1</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Failed to write to pipe parent2child!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (read(child2parent[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to read from pipe child2parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先if的是孩子进程,所以我们关闭父亲写入的,来进行读取,同时关闭孩子的读取来进行写入,把读取的写入到矮子里面.之后就是父亲,父亲是自己先进行写入,然后读取孩子的,也要进行关闭程序.</p>
<h4 id="1-5-4primes-moderate-x2F-hard"><a href="#1-5-4primes-moderate-x2F-hard" class="headerlink" title="1.5.4primes (moderate)&#x2F;(hard)"></a>1.5.4primes (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)&#x2F;(<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</h4><blockquote>
<h4 id="write-a-concurrent-version-of-prime-sieve-using-pipes-This-idea-is-due-to-Doug-McIlroy-inventor-of-Unix-pipes-The-picture-halfway-down-this-page-and-the-surrounding-text-explain-how-to-do-it-Your-solution-should-be-in-the-file-user-primes-c"><a href="#write-a-concurrent-version-of-prime-sieve-using-pipes-This-idea-is-due-to-Doug-McIlroy-inventor-of-Unix-pipes-The-picture-halfway-down-this-page-and-the-surrounding-text-explain-how-to-do-it-Your-solution-should-be-in-the-file-user-primes-c" class="headerlink" title="write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user/primes.c."></a>write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a target="_blank" rel="noopener" href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</h4></blockquote>
<p>题目要求,并发使用管道来进行读取输出2-35的素数.思路是一个写入2-35的管道,另外一个管道来进行输出.</p>
<blockquote>
<ul>
<li>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</li>
<li>Once the first process reaches 35, it should wait until the entire pipeline terminates, including all children, grandchildren, &amp;c. Thus the main primes process should only exit after all the output has been printed, and after all the other primes processes have exited.</li>
<li>Hint: <code>read</code> returns zero when the write-side of a pipe is closed.</li>
<li>It’s simplest to directly write 32-bit (4-byte) <code>int</code>s to the pipes, rather than using formatted ASCII I&#x2F;O.</li>
<li>You should create the processes in the pipeline only as they are needed.</li>
<li>Add the program to <code>UPROGS</code> in Makefile.</li>
</ul>
</blockquote>
<p>这个提示没什么用,直接看的大佬的版本,思路就是使用快速筛,蠡口上有讲解.主要思路就是第一遍把2的倍数全被设置true,剩下的从false里面读取,如果是当前的倍数的,也设置成true,指导到最后一个值.(这个给可以使用并发执行).</p>
<blockquote>
<p>所以这个问题就像是流水线一样，第一个进程将 <code>2~n</code> 依次写给第二个进程，第二个进程筛选非 <code>2</code> 倍数的数输出给第三个进程，第三个进程筛选非 <code>3</code> 倍数的数给第四个进程… 以此类推，单个阶段不一定要全部做完才交给后一阶段，完全可以像流水线一样进行。</p>
<p>我们的目标是使用 <code>pipe</code> 和 <code>fork</code> 来实现这样的流水线，我们将处理 <code>2~35</code> 的数字，进行素数筛。由于 xv6 的文件描述符和进程数量有限，第一个进程可以在 <code>35</code> 时停止。</p>
</blockquote>
<p>使用wait来保真先后顺序,父亲之后才是孩子.在每一个管道的最后一端加入-1,代表管道内容已经结束了.</p>
<p>整体代码,蠡口刷多了,写起来不是会很费力的.读取老的管道,同时把数字写入到新的管道,创建新进程调用新的管道作为输入,注意也要在最后加入-1作为结尾</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prime_num 35</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_child</span><span class="params">(<span class="type">int</span> *read_pipe)</span> &#123;</span><br><span class="line">    close(read_pipe[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> n, status;</span><br><span class="line">    <span class="keyword">if</span> ((status = read(read_pipe[<span class="number">0</span>], &amp;n, <span class="keyword">sizeof</span>(<span class="type">int</span>))) == <span class="number">0</span>) &#123; <span class="comment">// fetch the first number in the row</span></span><br><span class="line">        close(read_pipe[<span class="number">0</span>]);  <span class="comment">// no more numbers in the pipeline</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(status == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to read from pipe!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, n);  <span class="comment">// print out the first number as the prime</span></span><br><span class="line">    <span class="type">int</span> parent_pipe[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(parent_pipe) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create pipe!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create child process!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(read_pipe[<span class="number">0</span>]);</span><br><span class="line">        run_child(parent_pipe);  <span class="comment">// receive number in the new child process</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(parent_pipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="keyword">while</span> ((status = read(read_pipe[<span class="number">0</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">// filter and send numbers to new child process</span></span><br><span class="line">            <span class="keyword">if</span> (num % n != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(write(parent_pipe[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to write to pipe!\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(status == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to read from pipe!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(parent_pipe[<span class="number">1</span>]);</span><br><span class="line">        wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> input_pipe[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(input_pipe) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create pipe!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create child process!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        run_child(input_pipe); <span class="comment">// child process to filter the numbers</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(input_pipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= prime_num; i++) &#123; <span class="comment">// send 2~35 to the child process</span></span><br><span class="line">            <span class="keyword">if</span>(write(input_pipe[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to write to pipe!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(input_pipe[<span class="number">1</span>]);</span><br><span class="line">        wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="1-5-5find-moderate"><a href="#1-5-5find-moderate" class="headerlink" title="1.5.5find (moderate)"></a>1.5.5find (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h4><p>实现查找功能</p>
<blockquote>
<ul>
<li>Look at user&#x2F;ls.c to see how to read directories.</li>
<li>Use recursion to allow find to descend into sub-directories.</li>
<li>Don’t recurse into “.” and “..”.</li>
<li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li>
<li>You’ll need to use C strings. Have a look at K&amp;R (the C book), for example Section 5.5.</li>
<li>Note that &#x3D;&#x3D; does not compare strings like in Python. Use strcmp() instead.</li>
<li>Add the program to <code>UPROGS</code> in Makefile</li>
</ul>
</blockquote>
<p>提示是要我们区看ls的实现,ls把通过switch来对不同的来做判断,我们的现在要求就是根据判断末尾是不是要查找的目标,来进行输出.那么这一个题目就是变成字符串的截取题目.因为对c不是很熟.所以对这个题的代码卡了很久.char *a&#x3D;p.a&#x3D;a+strlen(a).这个意思是把a得到位置移动到最末尾,通过这样就变成截取字符串的操作.</p>
<ol>
<li>首先对与目标我们加上&#x2F;,因为每一个文件都是&#x2F;a&#x2F;a&#x2F;b这样的</li>
<li>然后我们使用ls一样的测策略,对于文件,移动到和目标文件一样长的地方,看他们想不想等,相等就进行输出</li>
<li>对于文件夹,我们使用递归,但是对于&#x2F;..还有&#x2F;.这个文件夹我们就不在进行递归 </li>
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory is a file containing a sequence of dirent structures.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>文件夹的数据结构</p>
<p>实现代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="comment">// Find first character after last slash.</span></span><br><span class="line">    <span class="keyword">for</span> (p = path + <span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">        ;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//返回末尾的文件名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *directory, <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(directory, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot open %s\n&quot;</span>, directory);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot stat %s\n&quot;</span>, directory);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123; <span class="comment">//查看路径类型</span></span><br><span class="line">        <span class="keyword">case</span> T_FILE: <span class="comment">//是文件</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(fmtname(directory), filename) == <span class="number">0</span>) &#123; <span class="comment">//比较路径末尾文件名和查找的文件名</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>, directory);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_DIR: <span class="comment">//是目录</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strlen</span>(directory) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;find: path is too long \n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(buf, directory);</span><br><span class="line">            p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">            *p++ = <span class="string">&#x27;/&#x27;</span>; <span class="comment">//拼凑当前目录路径</span></span><br><span class="line">            <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123; <span class="comment">//遍历目录</span></span><br><span class="line">                <span class="keyword">if</span> (de.inum == <span class="number">0</span> || <span class="built_in">strcmp</span>(<span class="string">&quot;.&quot;</span>, de.name) == <span class="number">0</span> ||</span><br><span class="line">                    <span class="built_in">strcmp</span>(<span class="string">&quot;..&quot;</span>, de.name) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                memmove(p, de.name, DIRSIZ); <span class="comment">//拼凑当前文件路径</span></span><br><span class="line">                p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (stat(buf, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                find(buf, filename); <span class="comment">//调用find递归查找</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: find &lt;directory&gt; &lt;filename&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-lab-syscall"><a href="#2-lab-syscall" class="headerlink" title="2.lab syscall"></a>2.lab syscall</h2><p><a target="_blank" rel="noopener" href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c2/s2.html">2.2 用户态，核心态，以及系统调用 · 6.S081 All-In-One (dgs.zone)</a></p>
<p>操作系统的作用是抽象系统同资源,最基本的目的就是互不影响程序,当一个程序出现问题不会影响下一个程序.所以系统管理员是操作系统,他与硬件打交道.</p>
<h3 id="2-2用户态，核心态，以及系统调用"><a href="#2-2用户态，核心态，以及系统调用" class="headerlink" title="2.2用户态，核心态，以及系统调用"></a>2.2用户态，核心态，以及系统调用</h3><p>用户态和和心态,和心态就是直接与硬件打交道的</p>
<p>核心态可以使用特权指令,用户通过条用内核函数的程序,把用户态转移到和心态,然后 在内核指定的路口,进入内核(ecall函数)需要写entry(write),然后通过设置一个数字作为这个函数的映射,内核太调用这个数字实际对那个内核里面的函数来实现方法</p>
<p><img src="https://blog.rayzhang.top/2022/07/05/mit-6.s081-lab-syscall/syscall_fork.png"></p>
<p>syscall调用sysproc实际方法</p>
<h3 id="2-3内核组织"><a href="#2-3内核组织" class="headerlink" title="2.3内核组织"></a>2.3内核组织</h3><p>分为大内核还有小内核,大内核就是和Windows差不多,所以的硬件功能都已经实现,小内核就是自己要实现文件这中内核操作,通过组合操作.</p>
<h3 id="2-4进程"><a href="#2-4进程" class="headerlink" title="2.4进程"></a>2.4进程</h3><p>进程都有自己的结构体,有自己的状态,还有自己的页表(页表,就是一个进程的虚拟地址空间)</p>
<h3 id="2-5实验"><a href="#2-5实验" class="headerlink" title="2.5实验"></a>2.5实验</h3><h4 id="2-5-1System-call-tracing-moderate"><a href="#2-5-1System-call-tracing-moderate" class="headerlink" title="2.5.1System call tracing (moderate)"></a>2.5.1System call tracing (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h4><p>实现追踪功能,然后追踪的进程的mask是这样得到 <code>trace(1 &lt;&lt; SYS_fork)</code>,这个参数可以通过argint得到</p>
<blockquote>
<ul>
<li>Add <code>$U/_trace</code> to UPROGS in Makefile</li>
<li>Run make qemu and you will see that the compiler cannot compile <code>user/trace.c</code>, because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. Once you fix the compilation issues, run trace 32 grep hello README; it will fail because you haven’t implemented the system call in the kernel yet.</li>
<li>Add a <code>sys_trace()</code> function in <code>kernel/sysproc.c</code> that implements the new system call by remembering its argument in a new variable in the <code>proc</code> structure (see <code>kernel/proc.h</code>). The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, and you can see examples of their use in <code>kernel/sysproc.c</code>.</li>
<li>Modify <code>fork()</code> (see <code>kernel/proc.c</code>) to copy the trace mask from the parent to the child process.</li>
<li></li>
</ul>
</blockquote>
<p>给定的提示,我们直接运行make是无法编译成功的.提示是因为无法编译trace.c,因为这个给用户态的功能trace在内核态没有对应实现,我们需要实现.首先就是在userh里面添加trace功能(申明,系统提供的api).之后区usys添加入口,这是上面的陷入,然后添加一个数值在syscall</p>
<blockquote>
<p>because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. </p>
</blockquote>
<p>尽管添加了之后,你还是没有办法实现,因为你要实现systrace功能在sysproc里面,我们需要把追踪的进程的掩码设置成传入的参数,通过argint得到mask,之后对于该进程创建的子进程,我们也许奥把掩码设置成先对应的mask(复制操作,只需要更改fork的逻辑就行),最后我们把掩码一样的在syscall里进行输出.</p>
<p><strong>这个题的主要重点,就是让我们了解到系统调用的流程,首先是在user里面注册系统调用函数,然后通过entry进行陷入这个函数,之后调用特殊的数值,来作为系统调用的参数.然后我们在sysproc具体实现这个功能</strong></p>
<p>主要 的流程就是上图所示</p>
<blockquote>
<p>所以，需要有一种方式能够让应用程序可以将控制权转移给内核（Entering Kernel）。</p>
<p>在RISC-V中，有一个专门的指令用来实现这个功能，叫做ECALL。ECALL接收一个数字参数，当一个用户程序想要将程序执行的控制权转移到内核，它只需要执行ECALL指令，并传入一个数字。这里的数字参数代表了应用程序想要调用的System Call。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MJX963vbIPHKetjGrZN%2F-MJXAkJxD8pTZOm1Tay_%2Fimage.png?alt=media&token=cf3e26a2-3c26-43b8-aee0-6d5787f8dcf5" alt="img"></p>
<p>ECALL会跳转到内核中一个特定，由内核控制的位置。我们在这节课的最后可以看到在XV6中存在一个唯一的系统调用接入点，每一次应用程序执行ECALL指令，应用程序都会通过这个接入点进入到内核中。举个例子，不论是Shell还是其他的应用程序，当它在用户空间执行fork时，它并不是直接调用操作系统中对应的函数，而是调用ECALL指令，并将fork对应的数字作为参数传给ECALL。之后再通过ECALL跳转到内核。</p>
<p>下图中通过一根竖线来区分用户空间和内核空间，左边是用户空间，右边是内核空间。在内核侧，有一个位于syscall.c的函数syscall，每一个从应用程序发起的系统调用都会调用到这个syscall函数，syscall函数会检查ECALL的参数，通过这个参数内核可以知道需要调用的是fork（3.9会有相应的代码跟踪介绍）。</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MJX963vbIPHKetjGrZN%2F-MJXO2n90L0ziqU8mTcg%2Fimage.png?alt=media&token=754f49c1-58a2-42d5-9427-094fc95ab613" alt="img"></p>
</blockquote>
<ol>
<li>在makefile进行注册</li>
<li>在user里面进行注册函数trace在sys里面进行进入entry</li>
<li>之后在syscall里面进行设置特殊的数值</li>
<li>然后调用这个sys_trace,之后在sysproc里实现(思路就是调用新的trace函数)</li>
<li>trace函数就是把当前mask传给当前进程</li>
<li>然后在syscall调用,调用结束后.我们来对这个掩码做比较,相同就进行输出</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>) &#123;  <span class="comment">//获取trace的参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;               <span class="comment">//获取失败返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trace(mask);  <span class="comment">//调用核心函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个trace函数还需要在defs进行申明,不然没发实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span> mask)</span> &#123; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;mask = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对fork的修改,就是把父进程的mask传授那个给子进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br><span class="line">  np-&gt;cwd = idup(p-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">  np-&gt;mask = p-&gt;mask; <span class="comment">//复制mask掩码</span></span><br><span class="line"></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line"></span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;wait_lock);</span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line">  release(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;np-&gt;lock);</span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>最后根据提示,我们在这里进行符合的输出</p>
<blockquote>
<p>The 32 is <code>1&lt;&lt;SYS_read</code>. In the second exam</p>
</blockquote>
<p>他的逻辑就是把这个给进程进行移动系统的位数,所以我们只要一回来,然后与1,还是1,就说明这个是需要最终的,我们就进行输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(p-&gt;mask &gt;&gt; num &amp; 1) &#123;</span><br><span class="line">      printf(&quot;%d: syscall %s -&gt; %d\n&quot;,p-&gt;pid, syscalls_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;mask &gt;&gt; num &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid, syscalls_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="3-lab-pgtble"><a href="#3-lab-pgtble" class="headerlink" title="3.lab pgtble"></a>3.lab pgtble</h2><h3 id="3-1基础知识"><a href="#3-1基础知识" class="headerlink" title="3.1基础知识"></a>3.1基础知识</h3><p><img src="https://blog.rayzhang.top/2022/07/22/mit-6.s081-lab-pgtbl/pgtbl-3-level.png" alt="img"></p>
<p>虚拟地址,通过页表来获取得到ppn(页表项),之后通过页表项目+offset得到最后的物理低值.这是一个三级页表,我没得到的前面两个ppn是下一个页面的地址.转化教程如下walk,让hi偶我们再看每一个pte是不是有效,获得pte使用的全相联,直接把这个虚拟地址进行映射到页表上面,最终与1ff想与,就是在512个里面找到是那一项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span> </span><br><span class="line">  <span class="comment">//pagetable表示一级页表的地址，va为虚拟内存地址，alloc表示是否创建条目</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA) <span class="comment">//虚拟内存地址越界，报错</span></span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123; <span class="comment">//分三级地址</span></span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)]; <span class="comment">//使用位运算获取L2/L1/L0，计算索引位置</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte); <span class="comment">//若条目有效，将页表指针指向下级页表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>) <span class="comment">//若无效，且alloc有设置，创建相关条目</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)]; <span class="comment">//最后返回三级页表中映射的物理地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化流程</p>
<p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16876974250271687697424363.png" alt="16876974250271687697424363.png"></p>
<p>首先kinit是初始化锁,之后的kvmint初始化内核页表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  kernel_pagetable = kvmmake();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Make a direct-map page table for the kernel.</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line"></span><br><span class="line">  kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel stacks</span></span><br><span class="line">  proc_mapstacks(kpgtbl);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要看kvmake的,她的作用就是映射pa,与设备在内存的地址上面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要使用的map来进行操作,map就是设置映射最底层的实现了，参数分别为页表地址 <code>pagetable</code>，虚拟地址 <code>va</code>，映射大小 <code>sz</code>，物理地址 <code>pa</code> 和访问标志位 <code>perm</code>：</p>
<p>代码的含义:对虚拟地址首先下面对齐,结尾的扼要进行最下面的页面对齐</p>
<p>使用walk返回的值是一个地址,还需要*pte才是最后的值,返回的是物理地址.然后在使用    *pte &#x3D; PA2PTE(pa) | perm | PTE_V;填入值</p>
<hr>
<p>用户地址基础知识</p>
<p><img src="https://blog.rayzhang.top/2022/07/22/mit-6.s081-lab-pgtbl/user-addr-space.png" alt="img"></p>
<p>构建第一个用户程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对用户程序分配pagetable,epc,sp,状态,重点看alloc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line">  p-&gt;state = USED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过查找 空闲的来进行分配</p>
<p>看用户页表的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a user page table for a given process,</span></span><br><span class="line"><span class="comment">// with no user memory, but with trampoline pages.</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address.</span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保留两个空间一个是trapframe(陷入的时候用的),然后放入到页表里面</p>
<h3 id="3-2实现系统调用的加速"><a href="#3-2实现系统调用的加速" class="headerlink" title="3.2实现系统调用的加速"></a>3.2实现系统调用的加速</h3><h4 id="要求和提示"><a href="#要求和提示" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在这个部分中，我们要通过调整页表的映射来实现对特定的系统调用的加速。</p>
<p>在部分操作系统（例如 Linux 中），会使用用户空间和内核空间之间的一块只读区域用来进行数据共享，以此来达到加速特定的系统调用的目的，这样就消除了与内核交互产生的开销。在本部分中，我们将实现对 <code>getpid</code> 系统调用的优化。</p>
<p>当一个进程被创建时，我们需要将一个只读的内存页映射到 <code>USYSCALL</code> 上，其中 <code>USYSCALL</code> 是一个虚拟内存地址，见 <code>kernel/memlayout.h</code>。在该内存页上我们需要存储一个叫 <code>struct usyscall</code> 的结构体，见 <code>kernel/memlayout.h</code>，然后将其初始化使其存储当前进程的 PID。下面是 <code>memlayout.h</code> 的节选部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#define USYSCALL (TRAPFRAME - PGSIZE)</span><br><span class="line">struct usyscall &#123;</span><br><span class="line">  int pid;  // Process ID</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个 Lab 中，系统在用户空间部分已经提供了 <code>ugetpid()</code>，并会自动使用 <code>USYSCALL</code> 的映射，<code>ugetpid</code> 函数就是我们测试时的函数，<strong>为了使得他工作正常我们需要完成相关修改</strong>。这段见 <code>user/ulib.c</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#ifdef LAB_PGTBL</span><br><span class="line">int</span><br><span class="line">ugetpid(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct usyscall *u = (struct usyscall *)USYSCALL;</span><br><span class="line">  return u-&gt;pid;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>相关提示：</p>
<ul>
<li>可以在 <code>kernel/proc.c</code> 下的 <code>proc_pagetable</code> 中处理内存映射问题。</li>
<li>注意处理访问标志位使得该内存页对用户空间来说是只读的。</li>
<li>了解 <code>mappages()</code> 的使用方法会很有帮助。</li>
<li>不要忘记在 <code>allocproc()</code> 中分配和初始化内存页。</li>
<li>确保在 <code>freeproc()</code> 中正确地释放了内存页。</li>
</ul>
<blockquote>
<p>大致的意识就是要求我们使用用户空间和内核空间之间的一块只读区域用来进行数据共享，以此来达到加速特定的系统调用的目的，这样就消除了与内核交互产生的开销。</p>
</blockquote>
<p><img src="https://blog.rayzhang.top/2022/07/22/mit-6.s081-lab-pgtbl/usyscall.png" alt="img"></p>
<blockquote>
<p>要求我们在usyspage这个里面进行设置我们的信息都存放在这个空间里面</p>
</blockquote>
<p>根据我们上面的基础知识,我们知道页表初始化**,实在proc_pagetable(p);**这个函数里面,我们在这里进行映射usys这个地址到页表.</p>
<p>和trapoframe一样的流程,分配之后,然后才是分配页表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a usyscall page</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;usyspage = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">      freeproc(p);</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Init the usyscall page</span></span><br><span class="line">  p-&gt;usyspage-&gt;pid = p-&gt;pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//页表函数</span></span><br><span class="line"><span class="comment">// map the usyscall page</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;usyspage), PTE_R | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line">按照trapframe释放方法</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;usyspage) </span><br><span class="line">    kfree((<span class="type">void</span> *)p-&gt;usyspage);</span><br><span class="line">  p-&gt;usyspage = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p-&gt;pagetable) proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br></pre></td></tr></table></figure>

<p>注意到释放过程,调用页表,那么页表项,我们也要释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-3实现页表打印"><a href="#3-3实现页表打印" class="headerlink" title="3.3实现页表打印"></a>3.3实现页表打印</h3><h4 id="要求和提示-1"><a href="#要求和提示-1" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在本部分中，我们需要将 RISC-V 的页表可视化，也就是实现一个页表内容的打印功能，作为后续调试的辅助工具。</p>
<p>我们需要定义一个叫做 <code>vmprint()</code> 的函数，这个函数应当传入一个类型为 <code>pagetable_t</code> 的参数，也是页表的指针，然后将页表的全部有效信息打印出来。题目要求在 <code>kernel/exec.c</code> 下的 <code>exec()</code> 中，在最后的 <code>return argc</code> 前加入一行（疯狂暗示，喂到嘴巴里）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">if(p-&gt;pid==1) vmprint(p-&gt;pagetable);</span><br></pre></td></tr></table></figure>

<p>来实现对第一个进程的页表的打印。</p>
<p>题目中给出了示例，当第一个进程刚完成 <code>exec()</code> 执行了 <code>/init</code> 时的页表状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">page table <span class="number">0x0000000087f6e000</span></span><br><span class="line"> .<span class="number">.0</span>: pte <span class="number">0x0000000021fda801</span> pa <span class="number">0x0000000087f6a000</span></span><br><span class="line"> .. .<span class="number">.0</span>: pte <span class="number">0x0000000021fda401</span> pa <span class="number">0x0000000087f69000</span></span><br><span class="line"> .. .. .<span class="number">.0</span>: pte <span class="number">0x0000000021fdac1f</span> pa <span class="number">0x0000000087f6b000</span></span><br><span class="line"> .. .. .<span class="number">.1</span>: pte <span class="number">0x0000000021fda00f</span> pa <span class="number">0x0000000087f68000</span></span><br><span class="line"> .. .. .<span class="number">.2</span>: pte <span class="number">0x0000000021fd9c1f</span> pa <span class="number">0x0000000087f67000</span></span><br><span class="line"> .<span class="number">.255</span>: pte <span class="number">0x0000000021fdb401</span> pa <span class="number">0x0000000087f6d000</span></span><br></pre></td></tr></table></figure>

<p>相关提示：</p>
<ul>
<li>可以把 <code>vmprint()</code> 放在 <code>kernel/vm.c</code> 里面</li>
<li>记得使用 <code>kernel/riscv.h</code> 最后添加的宏定义，包括但不限于 <code>PTE2PA</code> 等</li>
<li>强烈建议参考 <code>vm.c</code> 文件中的 <code>freewalk</code> 函数（疯狂暗示，喂嘴巴里了）</li>
<li>记得在 <code>kernel/defs.h</code> 中定义 <code>vmprint</code> 函数，以便在 <code>exec.c</code> 中成功调用</li>
<li>在 <code>printf</code> 中使用 <code>%p</code> 来打印完整的 16 进制 64 位地址和 PTE 信息</li>
</ul>
<p><img src="https://blog.rayzhang.top/2022/07/22/mit-6.s081-lab-pgtbl/pgtbl-3-level.png" alt="img"></p>
<p>这个很明显就是递归的效果,我们参考freewalk,首先得到page,之后根据二级页表得到页表项,再继续递归</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pgtblprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="comment">// if PTE is valid</span></span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; depth; t++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if this PTE points to a lower-level page table</span></span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// start with new child PTE addr</span></span><br><span class="line">        <span class="type">pagetable_t</span> child = (<span class="type">pagetable_t</span>)PTE2PA(pte);</span><br><span class="line">        pgtblprint(child, depth + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  pgtblprint(pagetable, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4查询内存页访问情况"><a href="#3-4查询内存页访问情况" class="headerlink" title="3.4查询内存页访问情况"></a>3.4查询内存页访问情况</h3><h4 id="要求和提示-2"><a href="#要求和提示-2" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>一些垃圾回收器可以根据内存页被访问情况的信息来进行工作。</p>
<p>在本部分中，我们将主要考虑为 xv6 实现一个新的功能，也就是检测用户空间的内存访问情况，并将信息返回给用户空间。我们需要通过检查 RISC-V 页表中的 <code>A</code> 标识位来实现，RISC-V 硬件每当尝试解决 TLB 未命中问题时，访问内存页的时候就会在页表中将对应 PTE 的标志位置为有效。</p>
<p>我们的目标是实现一个叫做 <code>pgaccess</code> 的系统调用，以此来查看哪些内存页被访问过了。这个系统调用需要传入三个参数，第一个参数是开始的要查看的用户空间内存页地址，第二个参数是需要查看的内存页数量，最后传入的是一个用户地址空间，好让我们将结果写到用户地址空间，结果以 bitmask 的形式存储，每一位和各个内存页一一对应，第一个内存页对应最小的比特位。</p>
<p>相关提示：</p>
<ul>
<li>考虑在 <code>kernel/sysproc.c</code> 下实现 <code>sys_pgaccess()</code> 系统调用主要功能。</li>
<li>需要使用 <code>argaddr()</code> 和 <code>argint()</code> 来获取系统调用传入的参数，这一块可以详见上次的 <a target="_blank" rel="noopener" href="https://blog.rayzhang.top/2022/07/05/mit-6.s081-lab-syscall/">Lab syscall: System calls</a>。</li>
<li>由于我们需要将结果返回给用户态的地址，因此有必要使用内核态中的临时缓冲区进行结果的处理，然后使用 <code>copyout()</code> 函数将结果复制到用户态，这段也可见 Lab Syscall 中相关内容。</li>
<li>可以设置扫描的内存页数上限。</li>
<li>在 <code>kernel/vm.c</code> 下的 <code>walk()</code> 函数会对找到正确的 PTE 很有帮助。</li>
<li>需要在 <code>kernel/riscv.h</code> 中额外定义一下 <code>PTE_A</code>，也就是访问标记的比特位。（不敢相信他们居然原来没有加）</li>
<li>确保在扫描内存页结束后将标志位 <code>PTE_A</code> 清零，不然下次扫描这个页的时候你看到标志位就乱了，不知道有没有被访问过了。</li>
<li>在调试页表的时候可以使用 <code>vmprint()</code>，活学活用了属于是。</li>
</ul>
<p><img src="https://blog.rayzhang.top/2022/07/22/mit-6.s081-lab-pgtbl/pte.png" alt="img"></p>
<p>数，第一个参数是开始的要查看的用户空间内存页地址，第二个参数是需要查看的内存页数量，最后传入的是一个用户地址空间，好让我们将结果写到用户地址空间，结果以 bitmask 的形式存储，</p>
<p>参照这个图,我们自己来进行设置access</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以参照这个代码块</p>
<ol>
<li>首先arg获得参数</li>
<li>然后是指读取条目数</li>
<li>之后就是对地址来求pte,看pte之后来进行清楚</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 va;</span><br><span class="line">  <span class="type">int</span> page_nums;</span><br><span class="line">  uint64 out_addr;</span><br><span class="line">  <span class="comment">// get syscall params</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;va) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">1</span>, &amp;page_nums) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">2</span>, &amp;out_addr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// check if the page numbers to scan is valid</span></span><br><span class="line">  <span class="keyword">if</span>(page_nums &lt; <span class="number">0</span> || page_nums &gt; <span class="number">64</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uint64 bitmask = <span class="number">0</span>;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; page_nums; i++) &#123;</span><br><span class="line">    <span class="comment">// check if va is out of range</span></span><br><span class="line">    <span class="keyword">if</span>(va &gt;= MAXVA) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get pte addr by va</span></span><br><span class="line">    pte = walk(p-&gt;pagetable, va, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!pte) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check if accessed</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_A) &#123;</span><br><span class="line">      bitmask |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">      <span class="comment">// clear the bit afterwards</span></span><br><span class="line">      *pte ^= PTE_A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// move va to next mem page</span></span><br><span class="line">    va += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// copy bitmask to user space</span></span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, out_addr, (<span class="type">char</span> *)&amp;bitmask, <span class="keyword">sizeof</span>(bitmask)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-5总结"><a href="#3-5总结" class="headerlink" title="3.5总结"></a>3.5总结</h3><p>终于填完所有的坑了,重点就是包含xv6的启动过程,首先kvinit(lock),之后就是kvm.内核启动,包括空间分配还有内核启动时候页表的操作,着重的讲解是如何使用pte来得到物理地址,使用walk可以得到当前va的pte地址,通过指针可以得到值,然后使用maparg来进行映射</p>
<ol>
<li>页表简介</li>
<li>内核态简介</li>
<li>用户空间简介</li>
</ol>
<h2 id="4-lab-trap"><a href="#4-lab-trap" class="headerlink" title="4.lab trap"></a>4.lab trap</h2><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h3 id="4-1回答问题"><a href="#4-1回答问题" class="headerlink" title="4.1回答问题"></a>4.1回答问题</h3><p>Read the code in call.asm for the functions <code>g</code>, <code>f</code>, and <code>main</code>. The instruction manual for RISC-V is on the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/reference.html">reference page</a>. Here are some questions that you should answer (store the answers in a file answers-traps.txt):</p>
<blockquote>
<p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</p>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816327874591681632783414.png"></p>
<p>a2</p>
<blockquote>
<p>Where is the call to function <code>f</code> in the assembly code for <code>main</code>? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</p>
</blockquote>
<p>显的可以看到在 <code>0x26</code> 位置，程序直接将 <code>12</code> 写入了 <code>a1</code> 寄存器的位置（也就是第二参数 <code>f(8)+1</code> 的位置），在处理完所有的寄存器参数后直接就调用了 <code>printf</code>。那只有一种解释，就是编译器直接计算出了 <code>f(8)+1</code> 的结果是 <code>12</code>，主函数中并没直接调用这两个函数</p>
<blockquote>
<p> At what address is the function <code>printf</code> located?</p>
</blockquote>
<p>根据提示他在628，我们直接收地址628</p>
<p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816337731131681633772533.png"></p>
<p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816338091161681633808486.png"></p>
<blockquote>
<p>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</p>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816340951881681634095159.png"></p>
<p><img src="https://blog.rayzhang.top/2022/09/27/mit-6.s081-lab-traps/jalr.png" alt="img"></p>
<p>34是pc地址，后面的是指令，手册的pc+4，就是34+4&#x3D;38是ra</p>
<blockquote>
<p>Run the following code.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">printf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<p>What is the output? <a target="_blank" rel="noopener" href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p>
<p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set to in order to yield the same output? Would you need to change to a different value?<code>i``57616</code></p>
<p><a target="_blank" rel="noopener" href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a target="_blank" rel="noopener" href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p>
</blockquote>
<p>57616十六进制是e110</p>
<p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816344351111681634434489.png"></p>
<p>下一个是小段对齐（就是最开始第一位是末尾2个字节，最后的才是开始）</p>
<p><img src="https://blog.rayzhang.top/2022/09/27/mit-6.s081-lab-traps/hello-world.jpeg" alt="img"></p>
<blockquote>
<p>In the following code, what is going to be printed after ? (note: the answer is not a specific value.) Why does this happen? <code>&#39;y=&#39;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;x=%d y=%d&quot;, 3);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>a2寄存器没有值，随便产生</p>
<h3 id="4-2函数调用栈打印"><a href="#4-2函数调用栈打印" class="headerlink" title="4.2函数调用栈打印"></a>4.2函数调用栈打印</h3><h4 id="要求和提示-3"><a href="#要求和提示-3" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>我们在代码调试的过程中为了定位错误的位置，经常需要使用到函数的调用栈打印。当错误发生时，会打印出一系列之前的函数调用信息。</p>
<p>在这里要求我们需要在 <code>kernel/printf.c</code> 下实现函数 <code>backtrace()</code>，并在 <code>sys_sleep</code> 中插入对此函数的一个调用。当我们在终端中调用 <code>bttest</code> 测试时，该命令会调起 <code>sleep</code> 系统调用，从而触发打印，运行 <code>bttest</code> 时打印结果示例为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">backtrace:</span><br><span class="line">0x0000000080002cda</span><br><span class="line">0x0000000080002bb6</span><br><span class="line">0x0000000080002898</span><br></pre></td></tr></table></figure>

<p>在 <code>bttest</code> 退出了 QEMU 之后，在终端下，我们也可以使用 <code>addr2line</code> 命令来将指令地址转化为具体的代码位置，例如我们使用指令 <code>addr2line -e kernel/kernel</code>：</p>
<p>我们的目标是从顶部开始遍历各个栈帧，并将<strong>各个栈帧中保存的返回地址</strong>打印出来。（讲道理感觉做个 <code>-4</code> 打印调用函数的地址可能会更直观一点，但是他说是就是吧）</p>
<p>相关提示：</p>
<ul>
<li><p>需要在 <code>kernel/defs.h</code> 中添加 <code>backtrace</code> 的声明，使得我们可以在 <code>sys_sleep</code> 下调用 <code>backtrace</code>。</p>
</li>
<li><p>GCC 编译器将当前执行的函数的栈帧指针 frame pointer 存储在 <code>s0</code> 寄存器中，为此我们需要在 <code>kernel/riscv.h</code> 下加入代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">static inline uint64</span><br><span class="line">r_fp()</span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  asm volatile(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) );</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以方便我们在 <code>backtrace</code> 中调用来读取栈帧的底部地址。</p>
<blockquote>
<p>P.S. <code>sp</code> 和 <code>fp</code> 是典型的堆栈寄存器，用来标注当前栈帧的底部和顶部地址，由于我们在描述的时候对顶部和底部往往有自己的理解，因为栈地址是向下增长的，这里还是放一张图会比较好：</p>
<p><a target="_blank" rel="noopener" href="https://blog.rayzhang.top/2022/09/27/mit-6.s081-lab-traps/stack-registers.png"><img src="https://blog.rayzhang.top/2022/09/27/mit-6.s081-lab-traps/stack-registers.png" alt="img"></a></p>
</blockquote>
</li>
<li><p>由刚才贴出的图可见，注意到当前函数的返回地址和当前的 <code>fp</code> 存在一个 <code>-8</code> 的地址偏移量，上一个栈帧的 <code>fp</code> 保存位置和当前的 <code>fp</code> 存在一个 <code>-16</code> 的偏移量。</p>
</li>
<li><p>在 xv6 中，操作系统内核会为每个栈分配一个页面的空间，并地址对齐。因此我们可以使用 <code>PGROUNDDOWN(fp)</code> 和 <code>PGROUNDUP(fp)</code> 来寻找栈所在页面的顶部和底部地址，<code>PGROUNDDOWN</code> 和 <code>PGROUNDUP</code> 的定义可以看下 <code>kernel/riscv.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>函数调用栈的实现,我们可以通过这个图可以看到每一个栈的大小是不固定,因为参数可能不一样,但是返回地址,还有上一个节点的地址是ra,和上一个fp是固定的,都是当前的fp-8,还有fp-16,得到这两个的值</p>
<ol>
<li>因此我们只需要进行递归地道道当前fp,是不是最上面的地址(pgup(fp))(这是第一个fp),就代表结束</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span> &#123; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  uint64 fp = r_fp();</span><br><span class="line">  <span class="keyword">while</span> (fp != PGROUNDUP(fp)) &#123; <span class="comment">// until get to stack bottom</span></span><br><span class="line">      <span class="comment">// get return addr in current stack frame</span></span><br><span class="line">      uint64 ra = *(uint64 *)(fp - <span class="number">8</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, ra);</span><br><span class="line">      <span class="comment">// go to prev stack frame</span></span><br><span class="line">      fp = *(uint64 *)(fp - <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="4-3实现定时器"><a href="#4-3实现定时器" class="headerlink" title="4.3实现定时器"></a>4.3实现定时器</h3><h4 id="要求和提示-4"><a href="#要求和提示-4" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在本部分中，我们将为 xv6 添加一个新的功能，使得当一个进程使用 CPU 时间的时候周期性的发出警告。这种功能对于想要限制它们占用多少 CPU 时间的计算型进程，或者对于想要计算但又想采取一些定期行动的进程，可能是很有用的。更广泛地说，我们将实现一个原始形式的用户级中断 &#x2F; 故障处理程序；例如，我们可以使用类似的东西来处理应用程序中的页面故障。我们需要通过 <code>alarmtest</code> 来完成该部分。</p>
<p>我们需要在 xv6 中添加一个新的系统调用 <code>sigalarm(interval, handler)</code>，例如当程序调用 <code>sigalarm(n, fn)</code> 的时候，那么接下来程序每消耗 <code>n</code> 个 ticks 的 CPU 时间后，内核应该调用 <code>fn</code>。当 <code>fn</code> 成功返回时，程序应当继续不受影响的运行，这部分由需要添加的系统调用 <code>sigreturn</code> 负责完成。如果应用程序调用 <code>sigalarm(0, 0)</code>，内核应该停止产生周期性的调用。</p>
<blockquote>
<p>P.S. 在 xv6 中，tick 是一个相当随意的时间单位，由硬件定时器产生中断的频率决定。</p>
</blockquote>
<p><code>alarmtest</code> 的相关代码在 <code>user/alarmtest.c</code> 中可见，为了使得其能够被正确识别，我们需要将其加入到 Makefile 中，如果对这块已经有点不记得的小伙伴可以看看 Lab Utils，可能可以记起来。</p>
<p>由于 <code>alarmtest</code> 文件中使用了两个我们待实现的系统调用 <code>sigalarm</code> 和 <code>sigreturn</code>，务必将系统调用正确添加，记不得的小伙伴可以再去看看 Lab Syscall… 后面也会继续提</p>
<p>在 <code>alarmtest</code> 中在 <code>test0</code> 调用了 <code>sigalarm(2, periodic)</code>，要求内核每隔 2 个 ticks 强制调用 <code>periodic()</code>，然后尝试自旋一段时间。我们可以在 <code>user/alarmtest.asm</code> 中看到 <code>alarmtest</code> 的汇编代码，这可能对调试很有帮助。</p>
<p>正确运行 <code>alarmtest</code> 和 <code>usertests</code> 的示例结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">$ alarmtest</span><br><span class="line">test0 start</span><br><span class="line">........alarm!</span><br><span class="line">test0 passed</span><br><span class="line">test1 start</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">test1 passed</span><br><span class="line">test2 start</span><br><span class="line">................alarm!</span><br><span class="line">test2 passed</span><br><span class="line">$ usertests</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>这块内容分为两部分完成，我们首先实现 <code>test0</code>，再实现 <code>test1</code> 和 <code>test2</code>。</p>
<p>对于 <code>test0</code> 而言，其功能是测试 handler 函数是否被正确执行了，首先我们需要修改内核代码使得内核可以跳转到用户空间中的 <code>periodic</code> 函数，从而打印出 <code>&quot;alarm!&quot;</code>。我们在这里暂时不考虑打印之后怎么处理，如果你在打印出 <code>&quot;alarm!&quot;</code> 程序直接 crash 也是完全正常的。以下是关于 <code>test0</code> 的相关提示：</p>
<ul>
<li><p>请将 <code>alarmtest.c</code> 加入 Makefile 中，使得其能够被正常编译。</p>
</li>
<li><p>两个系统调用需要在 <code>user/user.h</code> 中声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">int sigalarm(int ticks, void (*handler)());</span><br><span class="line">int sigreturn(void);</span><br></pre></td></tr></table></figure>
</li>
<li><p>你需要更新 <code>user/usys.pl</code>，<code>kernel/syscall.h</code> 和 <code>kernel/syscall.c</code> 来使得 <code>alarmtest</code> 可以正确的触发 <code>sigslarm</code> 和 <code>sigreturn</code> 系统调用。这块不记得的可以看看 Lab Syscall。</p>
</li>
<li><p><code>test0</code> 中对 <code>sys_sigreturn</code> 暂时没有要求，可以返回 <code>0</code> 完事。</p>
</li>
<li><p>你的 <code>sys_sigalarm()</code> 需要在 <code>kernel/proc.h</code> 下的 <code>proc</code> 结构体中开辟新的空间额外存储间隔时间和 handler 函数的指针。</p>
</li>
<li><p>你需要跟踪从最后一次调用直到下一次调用，过去了（或者说还剩下）多少时间，因此我们也需要在 <code>proc</code> 结构体中开辟额外的空间来实现。初始化 <code>proc</code> 结构体参数的方法详见 <code>kernel/proc.c</code> 下的 <code>allocproc()</code>。</p>
</li>
<li><p>每一次 tick 周期，硬件始终都会强制中断，这块的逻辑代码由 <code>kernel/trap.c</code> 下的 <code>usertrap()</code> 实现。</p>
</li>
<li><p>在 <code>usertrap()</code> 下，如果我们要控制硬件定时器中断发生时的行为，例如修改 <code>proc</code> 中存储的时间参数，我们只需要关注如下代码下的改动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">if(which_dev == 2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>请当进程有一个未完成的定时器时才可调用 handler 函数。注意到 handler 函数的地址可能是 <code>0</code>，例如在 <code>user/alarmtest.asm</code> 中，<code>periodic</code> 位于地址 <code>0</code>。</p>
</li>
<li><p>请修改 <code>usertrap()</code> 使得当进程的定时间隔过期时，用户进程可以执行 handler 函数。另外请思考，当在 RISC-V 上的陷阱返回到用户空间时，是什么决定了接下来用户空间代码开始执行的位置？</p>
</li>
<li><p>为了方便使用 GDB 观察陷阱的运行，我们可以让 QEMU 只使用一个 CPU，例如运行如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">make CPUS=1 qemu-gdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>在本阶段中，只要 <code>alarmtest</code> 成功打印出 <code>&quot;alarm!.&quot;</code> 即为成功</p>
</li>
</ul>
<p>对于 <code>test1</code> 和 <code>test2</code> 而言，其功能主要是测试被中断的代码接下来是否能够继续运行。为了确保程序接下来能够继续正确的运行，我们需要在 handler 函数执行完毕时，返回至被定时器中断的代码位置，同时保证寄存器内容被正确的存储并恢复了。最后我们需要在每次计时结束后重置计时器的计数器，使得 handler 函数能不断的被周期调用。</p>
<p>我们假定如下的设计：用户空间的 handler 函数在结束时需要调用 <code>sigreturn</code> 系统调用，参考 <code>user/alarmtest.c</code> 的 <code>periodic</code> 函数。这意味着我们需要在 <code>usertrap</code> 和 <code>sys_sigreturn</code> 中进行修改，使得用户空间进程可以正确的继续执行下去。如下为关于 <code>test1</code> 和 <code>test2</code> 的相关提示：</p>
<ul>
<li>为了保证被中断程序的正确运行，你需要保存和恢复寄存器。请思考一下，哪些寄存器需要你进行存储和恢复呢？</li>
<li>在 <code>usertrap</code> 中需要向 <code>proc</code> 结构体中保存一些状态信息，以方便 <code>sigreturn</code> 正确返回到原先的代码位置。</li>
<li>禁止可重入的调用 handler 函数，在 handler 函数没有返回之前，内核不应当再次调起。关于这块的测试将在 <code>test2</code> 中有所体现。</li>
</ul>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><img src="https://blog.rayzhang.top/2022/09/27/mit-6.s081-lab-traps/alarm.png" alt="img"></p>
<p>陷入流程:</p>
<ol>
<li>首先是调用systemcall,我们首先设置handler,还有时间</li>
<li>之后就是始终的定时中断</li>
<li>我们首先可以在dev&#x3D;2这个地方捕捉到中断信号,我们需要把当前运行pc设置成handler来进行处理,如果当时间满了的情况下</li>
<li>之后,这个中断结束,但是可能会被其他程序抢走,所以这个程序的trapframe也需要保存下来</li>
</ol>
<p>让我们梳理一下题意</p>
<ol>
<li>首先完成用户态到内核态陷入,之前的已经写过,跳过</li>
<li>需要我们在proc的结构体里面添加处理函数handler</li>
<li>距离下一次调用的时间也需要进行设置</li>
<li>然后userttrap下面的dev就是定时中断锁需要进行的操作</li>
<li>现在我们来回顾一下陷入流程</li>
</ol>
<hr>
<p><strong>完成sys_sigalarm</strong></p>
<p>添加下列参数到proc里面</p>
<p> p-&gt;alarm_interval &#x3D; ticks;<br>  p-&gt;alarm_handler &#x3D; handler;<br>  p-&gt;alarm_ticks_left &#x3D; ticks;</p>
<p>主要就是获取参数,然后设置到proc里面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">uint64 sys_sigalarm(void) &#123; </span><br><span class="line">  int n;</span><br><span class="line">  uint64 fn;</span><br><span class="line">  if(argint(0, &amp;n) &lt; 0) &#123;</span><br><span class="line">      return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  if(argaddr(1, &amp;fn) &lt; 0) &#123;</span><br><span class="line">      return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  return sigalarm(n, (void(*)())(fn));</span><br><span class="line">&#125;</span><br><span class="line">int sigalarm(int ticks, void (*handler)()) &#123; </span><br><span class="line">  struct proc *p = myproc();</span><br><span class="line">  p-&gt;alarm_interval = ticks;</span><br><span class="line">  p-&gt;alarm_handler = handler;</span><br><span class="line">  p-&gt;alarm_ticks_left = ticks;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完成trap陷入操作</strong></p>
<p>每一次中断,我们都会让时间减少,而且还要看是不是已经运行了</p>
<p>所以需要lock参数,我们需要备份trapframe,按照之前的样子,所以还需要</p>
<p>backtrap,还有lock</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;alarm_interval) &#123; <span class="comment">// if alarm is enalbled</span></span><br><span class="line">      <span class="keyword">if</span>(--p-&gt;alarm_ticks_left &lt;= <span class="number">0</span>) &#123; <span class="comment">// if ticks expired, trigger the handler func</span></span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;alarm_handler_lock) &#123; <span class="comment">// if the handler func is not running</span></span><br><span class="line">          <span class="comment">// save the current trapframe</span></span><br><span class="line">          *p-&gt;alarm_backup = *p-&gt;trapframe;</span><br><span class="line">          <span class="comment">// modify return address</span></span><br><span class="line">          p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarm_handler;</span><br><span class="line">          <span class="comment">// set reentrant lock</span></span><br><span class="line">          p-&gt;alarm_handler_lock = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>





<hr>
<p><strong>恢复操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">()</span> &#123; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// restore trapframe</span></span><br><span class="line">  *p-&gt;trapframe = *p-&gt;alarm_backup;</span><br><span class="line">  <span class="comment">// release reentrant lock</span></span><br><span class="line">  p-&gt;alarm_handler_lock = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="4-4总结"><a href="#4-4总结" class="headerlink" title="4.4总结"></a>4.4总结</h3><p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MKFsfImgYCtnwA1d2hO%2F-MKHxleUqYy-y0mrS48w%2Fimage.png?alt=media&token=ab7c66bc-cf61-4af4-90fd-1fefc96c7b5f" alt="img"></p>
<p>总体流程</p>
<ol>
<li>首先调用ecall</li>
<li>之后是uservec(内核执行的第一个程序,trampoline是一部分,保存页表)</li>
<li>然后才是转到c语言的usertrap,开始查看是什么类型的原因到内核态(trap,interupt还是page fault)</li>
<li>陷入之后是system call,调用实际的底层函数</li>
</ol>
<p>ecall作用详解:</p>
<ol>
<li><p>第一，ecall将代码从user mode改到supervisor mode。</p>
</li>
<li><p>第二，ecall将程序计数器的值保存在了SEPC寄存器。我们可以通过打印程序计数器看到这里的效果，</p>
</li>
<li><p>ecall跳转到stvec</p>
</li>
</ol>
<p>在trampoline page详解:</p>
<ol>
<li>修改vec的代码</li>
<li>保存寄存器等其他信息trapframe</li>
</ol>
<p>主要就是保存你用户的页表</p>
<p>usertrap详解:</p>
<p>找到是什么类型,来进行对应出路i</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MLhY-FzqA_AFTTcuD6U%2F-MLjZNai3dy2h5fFhLXf%2Fimage.png?alt=media&token=f1e670c2-97f6-471a-a0f1-76dace363806" alt="img"></p>
<p>sertrap函数的最后调用了usertrapret函数，来设置好我之前说过的，在返回到用户空间之前内核要做的工作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>保存相关的内核信息到trapframe,然后再次进入到trampoline,进行恢复用户的页表</p>
<p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MLhY-FzqA_AFTTcuD6U%2F-MLjbaxkbJ9sBUszhiaX%2Fimage.png?alt=media&token=fefe6012-0e8b-4f4d-b044-c25b62d5f0fd" alt="img"></p>
<p>接下来的几行填入了trapframe的内容，这些内容对于执行trampoline代码非常有用。这里的代码就是：</p>
<p>- </p>
<p>  存储了kernel page table的指针</p>
<p>- </p>
<p>  存储了当前用户进程的kernel stack</p>
<p>- </p>
<p>  存储了usertrap函数的指针，这样trampoline代码才能跳转到这个函数（注，详见6.5中 <em>ld t0 (16)a0</em> 指令）</p>
<p>- </p>
<p>  从tp寄存器中读取当前的CPU核编号，并存储在trapframe中，这样trampoline代码才能恢复这个数字，因为用户代码可能会修改这个数字</p>
<p>实际上，我们会在汇编代码trampoline中完成page table的切换，并且也只能在trampoline中完成切换，因为只有trampoline中代码是同时在用户和内核空间中映射</p>
<p><img src="https://img2023.cnblogs.com/blog/1942408/202303/1942408-20230301194532035-432919191.png" alt="img"></p>
<h2 id="5-cow"><a href="#5-cow" class="headerlink" title="5.cow"></a>5.cow</h2><p>写时候分配,大致意识fork的时候,不进行分配,使用与父亲的一起共享的内存,当这篇内存要写入的时候,出发page fault,在进行分配,分配主要包括,给内存释放权限,还有重新进行开辟一个新空间</p>
<p><img src="https://blog.rayzhang.top/2022/10/01/mit-6.s081-lab-cow/cow.png" alt="img"></p>
<h3 id="5-1实现-COW-下的-fork"><a href="#5-1实现-COW-下的-fork" class="headerlink" title="5.1实现 COW 下的 fork"></a>5.1实现 COW 下的 <code>fork</code></h3><h4 id="要求和提示-5"><a href="#要求和提示-5" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在本部分中，我们的任务是在 xv6 操作系统中实现一个写时复制的 <code>fork</code>。完成的代码需要通过 <code>cowtest</code> 和 <code>usertests</code> 测试。<code>cowtest</code> 中的相关测试样例详见 <code>user/cowtest.c</code>。</p>
<p>例如，如果我们对 xv6 操作系统一开始什么都没做修改，就直接执行 <code>cowtest</code>，我们会得到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">$ cowtest</span><br><span class="line">simple: fork() failed</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<p>这是因为在 <code>simple</code> 测试样例中，它分配了超过一半的可用物理内存空间，随后调用 <code>fork</code>。在没有实现 COW 的 xv6 下，操作系统会采取 eager 策略，立即为子进程创建对应用户空间并着手复制，这会直接导致物理内存空间的耗尽。</p>
<p>为了实现 COW 我们要在以下几处完成修改：</p>
<ul>
<li>修改 <code>kernel/vm.c</code> 下的 <code>uvmcopy()</code> 函数，我们需要共享父进程和子进程的用户空间，而非重新分配新的内存。此外，我们还需要将子进程和父进程的 PTE 置为只读，以触发缺页中断 page fault。</li>
<li>修改 <code>kernel/trap.c</code> 下的 <code>usertrap()</code> 函数，使得内核可以正确的判断出发生了缺页中断 page fault。一旦内核识别出在一个 COW 内存页上发生了缺页中断，就需要使用 <code>kalloc()</code> 开辟新的内存页，并将原内存页的数据拷贝到新的内存页上，并设置新的映射关系，将 PTE 下的可读 <code>PTE_W</code> 置位。</li>
<li>我们需要确保当该物理页面最后的 PTE 引用 ref count 清零了才可将其进行释放。当 <code>kernel/kalloc.c</code> 下的 <code>kalloc()</code> 分配该内存页时我们就将其 ref count 设置为 <code>1</code>，每当有 <code>fork</code> 操作使得子进程共享该内存页时我们就将 ref count 加一，同理每当一个进程将对应映射关系从其页表中删除时，我们就要将 ref count 减一。只有当 ref count 清零的时候我们才可以将当前内存页使用 <code>kernel/kalloc.c</code> 下的 <code>kfree()</code> 放置在空闲列表中。我们可以把这些计数的 ref count 放在一个固定大小的整数数组中，例如我们可以使用页面的物理地址除以 <code>4096</code> 来索引数组，然后给数组一个等同于 <code>kalloc.c</code> 中 <code>kinit()</code> 放置在空闲列表中页面的最高物理地址的元素数。</li>
<li>不要忘记修改 <code>kernel/vm.c</code> 下的 <code>copyout()</code>，来适应 COW 的内存页，因为可能有用户空间下的内存页暂未被分配，原先的 <code>copyout</code> 也会触发 page fault。</li>
</ul>
<p>相关提示：</p>
<ul>
<li><p>我们很有可能需要标记当前的 PTE 为 COW 内存页映射，因此我们可以使用 RSW（reserved for software）标识位来实现：</p>
<p><a target="_blank" rel="noopener" href="https://blog.rayzhang.top/2022/10/01/mit-6.s081-lab-cow/rsw-bits.png"><img src="https://blog.rayzhang.top/2022/10/01/mit-6.s081-lab-cow/rsw-bits.png" alt="img"></a></p>
</li>
<li><p>一些有用的宏和定义可以方便处理 PTE 的相关标识位，这些代码在 <code>kernel/riscv.h</code> 的最后可以找到。</p>
</li>
<li><p>如果 COW 下的缺页中断产生了，但是也没有足够的物理内存空间，那么进程应当被杀死。</p>
</li>
</ul>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>提示已经给了很多信息,我们把提示在进行翻译一遍</p>
<p>这个rsw标记需要我们自己手动来做</p>
<p><img src="https://blog.rayzhang.top/2022/10/01/mit-6.s081-lab-cow/rsw-bits.png" alt="img"></p>
<ol>
<li>首先修改uvmcopy,不是分配,二十把这个新地址还是映射到同一个物理地址,之前的map函数,同时设置不能写,符号</li>
<li>然后修改trap,因为会出发page_fault,这样我们需要解开原来的映射,然后进行kalloc分配,新的还要加入写入权限**(注意,解开原来映射的时候,会消灭原始内存,因此需要引用计数)**</li>
<li>之后就是应用计数的相关设置</li>
<li>然后设置copy的配置</li>
</ol>
<blockquote>
<p>们可以把这些计数的 ref count 放在一个固定大小的整数数组中，例如我们可以使用页面的物理地址除以 <code>4096</code> 来索引数组，然后给数组一个等同于 <code>kalloc.c</code> 中 <code>kinit()</code> 放置在空闲列表中页面的最高物理地址的元素数。</p>
</blockquote>
<p>设置页面数组,来统计每一个页面使用的次数,当然还是要进行枷锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> refcount_arr[(PHYSTOP - KERNBASE) / PGSIZE];</span><br><span class="line">&#125; refcount;</span><br></pre></td></tr></table></figure>

<p>刚开始就是初始化,维1此使用,之后就是设置++</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">refcount_add</span><span class="params">(uint64 va, <span class="type">int</span> add)</span> &#123; </span><br><span class="line">  <span class="type">int</span> index = (va - KERNBASE) / PGSIZE;</span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  <span class="type">int</span> res = refcount.refcount_arr[index];</span><br><span class="line">  res += add;</span><br><span class="line">  refcount.refcount_arr[index] = res;</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">refcount_set</span><span class="params">(uint64 va, <span class="type">int</span> ref)</span> &#123; </span><br><span class="line">  <span class="type">int</span> index = (va - KERNBASE) / PGSIZE; </span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  refcount.refcount_arr[index] = ref;</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就是freerange来开始设置</p>
<p>,因为他调用了kfree</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int refcount_add(uint64 va, int add) &#123; </span><br><span class="line">  int index = (va - KERNBASE) / PGSIZE;</span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  int res = refcount.refcount_arr[index];</span><br><span class="line">  res += add;</span><br><span class="line">  refcount.refcount_arr[index] = res;</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void refcount_set(uint64 va, int ref) &#123; </span><br><span class="line">  int index = (va - KERNBASE) / PGSIZE; </span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  refcount.refcount_arr[index] = ref;</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是设置uvmcopy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define PTE_V (1L &lt;&lt; 0) // valid</span><br><span class="line">#define PTE_R (1L &lt;&lt; 1)</span><br><span class="line">#define PTE_W (1L &lt;&lt; 2)</span><br><span class="line">#define PTE_X (1L &lt;&lt; 3)</span><br><span class="line">#define PTE_U (1L &lt;&lt; 4) // 1 -&gt; user can access</span><br><span class="line">#define PTE_COW (1L &lt;&lt; 8) // 1 -&gt; set as cow page</span><br></pre></td></tr></table></figure>

<p>设置维rsw,并且只能读取,还有进行映射地址,还有应用加一</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    <span class="keyword">if</span> (*pte &amp; PTE_W) &#123; <span class="comment">// if the page is writable</span></span><br><span class="line">        *pte ^= PTE_W; <span class="comment">// disable write flag</span></span><br><span class="line">        *pte |= PTE_COW; <span class="comment">//setup COW flag</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map pagetable to same physical addr in the new processs</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)pa, PTE_FLAGS(*pte)) != <span class="number">0</span>)&#123;</span><br><span class="line">      uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// increace ref for page share</span></span><br><span class="line">    refcount_add(pa, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在这里对这个物理页面进行加1此使用</p>
<p><img src="https://blog.rayzhang.top/2022/10/01/mit-6.s081-lab-cow/scause.png" alt="img"></p>
<p>通过这个我们知道13还有15是page fault原因,我们新建一个copycow来进行解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">else if (r_scause() == 15) &#123;</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    if(copycow(p-&gt;pagetable, va) &lt; 0) &#123;</span><br><span class="line">      p-&gt;killed = 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>copycow,才是真实的</p>
<p>分配代码</p>
<ol>
<li>检查pte的标识</li>
<li>接触原始映射</li>
<li>然后kalloc</li>
<li>copy内容</li>
<li>之后在世新的映射,和之前原来的uvmcopy差不多</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy cow page,</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure, -2 on invalid va</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copycow</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (va &gt;= MAXVA) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;va cannot be greater than MAXVA: %p\n&quot;</span>, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  uint64 mem;</span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line">  <span class="type">pte_t</span> *pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  uint64 pa = PTE2PA(*pte);</span><br><span class="line">  uint flags = PTE_FLAGS(*pte);</span><br><span class="line">  <span class="keyword">if</span> (!(*pte &amp; PTE_COW))&#123; <span class="comment">// check if page is COW page</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Not a COW page. Invalid va: %p\n&quot;</span>, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(mem = (uint64)kalloc()))&#123; <span class="comment">// kalloc new page</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Failed to allocate physical page.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  memmove((<span class="type">void</span> *)mem, (<span class="type">void</span> *)pa, PGSIZE); <span class="comment">//copy to new page</span></span><br><span class="line">  flags ^= PTE_COW | PTE_W; <span class="comment">// setup write flag, disable COW flag</span></span><br><span class="line">  uvmunmap(pagetable, va, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// cancel original pagetable map which caused page fault</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(pagetable, va, PGSIZE, mem, flags) != <span class="number">0</span>) &#123; <span class="comment">// remap va to new page</span></span><br><span class="line">    kfree((<span class="type">void</span>*)mem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>调用了kalloc,还有kfree,会对这个页面进行初始化维1,然后减少一次,知道这个页面还有用,才不会清楚</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(refcount_add((uint64)pa,<span class="number">-1</span>,<span class="number">0</span>)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 还有引用直接推出</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r) </span><br><span class="line">    refcount_set((uint64)r, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Free the page of physical memory pointed at by v,</span><br><span class="line">// which normally should have been returned by a</span><br><span class="line">// call to kalloc().  (The exception is when</span><br><span class="line">// initializing the allocator; see kinit above.)</span><br><span class="line">void</span><br><span class="line">kfree(void *pa)</span><br><span class="line">&#123;</span><br><span class="line">  struct run *r;</span><br><span class="line"></span><br><span class="line">  if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(&quot;kfree&quot;);</span><br><span class="line">  </span><br><span class="line">  if (refcount_add((uint64)pa, -1) &gt; 0) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Fill with junk to catch dangling refs.</span><br><span class="line">  memset(pa, 1, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修改 <code>copyout</code> 函数</strong></p>
<p>这点也在刚才的提示中贴心的点出<strong>来了，由于我们的 COW 页面是只读状态，那么在 <code>kernel/vm.c</code> 下的 <code>copyout</code> 函数需要进行修改。因为这个函数负责的是将一些数据从内核态复制到用户态，按照原先 xv6 的设置，<code>copyout</code> 是不可能预见到内存空间中的内存页只读的。</strong></p>
<p>修改的办法也说不上很难，在我们通过 walk 页表取得 PTE 后先不着急转化成物理地址，而是先看一下这个 PTE 的 COW 标识位，如果有标识位那直接使用刚才的 <code>copycow</code> 函数，一通操作，复制到新页面修改，映射到新的物理地址映射，再继续接下来的操作：</p>
<ol>
<li>首先得到pte</li>
<li>看pte有没有rsw,悠久调用cow来进行分配</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pte_t *pte = walk(pagetable, va0, 0);</span><br><span class="line">    if(!pte) &#123;</span><br><span class="line">      printf(&quot;Failed to get pa from pgtbl. va: %p\n&quot;, va0);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(*pte &amp; PTE_cow)&#123;</span><br><span class="line">      if(copycow(pagetable, va0) &lt; 0)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from kernel to user.</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dstva &gt;= MAXVA)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;dstva cannot be greater than MAXVA: %p\n&quot;</span>, dstva);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    <span class="type">pte_t</span> *pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!pte) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Failed to get pa from pgtbl. va: %p\n&quot;</span>, va0);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_COW)&#123;</span><br><span class="line">      <span class="keyword">if</span>(copycow(pagetable, va0) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总体来说，这一个是抄的别人写的博客。大致的原理，就是不分配内存，通过cow来分配，但是细节太麻烦了。</p>
<h2 id="6-thread"><a href="#6-thread" class="headerlink" title="6.thread"></a>6.thread</h2><h3 id="用户线程切换"><a href="#用户线程切换" class="headerlink" title="用户线程切换"></a>用户线程切换</h3><h4 id="要求和提示-6"><a href="#要求和提示-6" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在本部分中我们将设计并实现用户级别下的线程上下文切换。开始前可以阅读 <code>user/uthread.c</code> 和 <code>uthread_switch.S</code> 下的代码，这两个文件实现了线程切换的大致框架和简单的功能测试代码，我们需要补全剩余部分。</p>
<p>注意到我们需要想办法创造线程并在线程切换的过程中尝试保存 &#x2F; 恢复寄存器，事后如果功能实现，可以在 xv6 下运行 <code>uthread</code>，正确运行示例如下（三个线程的顺序可能会有出入）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">$ uthread</span><br><span class="line">thread_a started</span><br><span class="line">thread_b started</span><br><span class="line">thread_c started</span><br><span class="line">thread_c 0</span><br><span class="line">thread_a 0</span><br><span class="line">thread_b 0</span><br><span class="line">thread_c 1</span><br><span class="line">thread_a 1</span><br><span class="line">thread_b 1</span><br><span class="line">...</span><br><span class="line">thread_c 99</span><br><span class="line">thread_a 99</span><br><span class="line">thread_b 99</span><br><span class="line">thread_c: exit after 100</span><br><span class="line">thread_a: exit after 100</span><br><span class="line">thread_b: exit after 100</span><br><span class="line">thread_schedule: no runnable threads</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>终端上的输出来自三个测试线程，每个线程都会进入一个循环，在循环中打印一行随后让出 CPU 给其他线程。但是由于现在我们还没有加入实现上下文切换的代码，我们是看不到输出的。</p>
<p>我们需要向 <code>user/uthread.c</code> 下的 <code>thread_create()</code> 和 <code>thread_schedule()</code> 中，以及 <code>user/uthread_switch.S</code> 下的 <code>thread_switch</code> 加入代码，从名字里看得出来，我们需要实现线程的创建和切换功能…</p>
<p>我们有两个目标需要实现，一个是我们需要确保当 <code>thread_schedule()</code> 第一次运行一个给定的线程时，该线程在自己的堆栈中执行 <code>thread_create()</code> 中给定的函数参数；另外一个是，确保 <code>thread_switch</code> 保存被切换走的线程寄存器，并恢复被切换到的线程寄存器，随后返回到切换过来的线程的指令中最后离开的位置。</p>
<p>我们需要决定在哪里存储 &#x2F; 恢复寄存器，尝试修改结构体 <code>struct thread</code> 会是一个很好的主意。此外，我们需要在 <code>thread_switch</code> 中加入调用 <code>thread_schedule</code>（这玩意儿只有汇编代码），可以在调用时传入我们想要的任何参数，只要能从线程 <code>t</code> 切换到 <code>next_thread</code>。</p>
<p>相关提示：</p>
<ul>
<li>在 <code>thread_switch</code> 中我们只需要保存和恢复 callee-save 寄存器。</li>
<li>我们可以参考编译后根据 <code>uthread.c</code> 生成的 <code>user/uthread.asm</code> 汇编代码，以方便调试。</li>
<li>为了测试代码，使用 <code>riscv64-linux-gnu-gdb</code> 单步浏览 <code>thread_switch</code> 可能会有帮助。相关的 GDB 调试技巧，已经在 Lecture 5 介绍过了，也可以再去熟悉下。</li>
</ul>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>写这一个代码就是为了让我们更深入的了解，线程是如何进行切换。</p>
<p><img src="https://pic2.zhimg.com/v2-b732485b8ee0ccae1cc989d7d426959d_b.jpg" alt="img"></p>
<p>基础知识：线程切换</p>
<ol>
<li>shell通过中断进入内核态</li>
<li>执行yield操作，进行让位</li>
<li>使用swtch算法找到一个合适的</li>
<li>最后使用usertrapret进行返回</li>
</ol>
<p>因为要和寄存器直接打交道，所以 xv6 选择汇编来完成，而不是 C 。相比于 C ，汇编更适合操纵寄存器，使用swtch来进行保存</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Context switch</span><br><span class="line">#</span><br><span class="line">#   void swtch(struct context *old, struct context *new);</span><br><span class="line"># </span><br><span class="line"># Save current registers in old. Load from new. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">        sd ra, 0(a0)</span><br><span class="line">        sd sp, 8(a0)</span><br><span class="line">        sd s0, 16(a0)</span><br><span class="line">        ...</span><br><span class="line">        sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, 0(a1)</span><br><span class="line">        ld sp, 8(a1)</span><br><span class="line">        ld s0, 16(a1)</span><br><span class="line">        ...</span><br><span class="line">        ld s11, 104(a1)</span><br><span class="line"></span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>保存当前的上下文，之后就是调度</p>
<p>理解了上面知识，我们知道我们这一届需要做什么了。我们就是自己模仿swtch操作，因为进程信息只有内核态可以看见，所以我们需要把这个信息传入到外面的线程数组，直接用数组来进行调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct thread_context &#123;</span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  // callee-saved</span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line">struct thread &#123;</span><br><span class="line">  char       stack[STACK_SIZE]; /* the thread&#x27;s stack */</span><br><span class="line">  int        state;             /* FREE, RUNNING, RUNNABLE */</span><br><span class="line">  struct thread_context context; /* thread context to save/restore reg */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>之后的调度程序直接抄汇编的swtch</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">	.text</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">         * save the old thread&#x27;s registers,</span><br><span class="line">         * restore the new thread&#x27;s registers.</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">	.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">	/* YOUR CODE HERE */</span><br><span class="line">    sd ra, 0(a0)</span><br><span class="line">    sd sp, 8(a0)</span><br><span class="line">    sd s0, 16(a0)</span><br><span class="line">    sd s1, 24(a0)</span><br><span class="line">    sd s2, 32(a0)</span><br><span class="line">    sd s3, 40(a0)</span><br><span class="line">    sd s4, 48(a0)</span><br><span class="line">    sd s5, 56(a0)</span><br><span class="line">    sd s6, 64(a0)</span><br><span class="line">    sd s7, 72(a0)</span><br><span class="line">    sd s8, 80(a0)</span><br><span class="line">    sd s9, 88(a0)</span><br><span class="line">    sd s10, 96(a0)</span><br><span class="line">    sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">    ld ra, 0(a1)</span><br><span class="line">    ld sp, 8(a1)</span><br><span class="line">    ld s0, 16(a1)</span><br><span class="line">    ld s1, 24(a1)</span><br><span class="line">    ld s2, 32(a1)</span><br><span class="line">    ld s3, 40(a1)</span><br><span class="line">    ld s4, 48(a1)</span><br><span class="line">    ld s5, 56(a1)</span><br><span class="line">    ld s6, 64(a1)</span><br><span class="line">    ld s7, 72(a1)</span><br><span class="line">    ld s8, 80(a1)</span><br><span class="line">    ld s9, 88(a1)</span><br><span class="line">    ld s10, 96(a1)</span><br><span class="line">    ld s11, 104(a1)</span><br><span class="line">	ret    /* return to ra */</span><br></pre></td></tr></table></figure>

<p>实现Switch操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void </span><br><span class="line">thread_schedule(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct thread *t, *next_thread;</span><br><span class="line"></span><br><span class="line">  /* Find another runnable thread. */</span><br><span class="line">  next_thread = 0;</span><br><span class="line">  t = current_thread + 1;</span><br><span class="line">  for(int i = 0; i &lt; MAX_THREAD; i++)&#123;</span><br><span class="line">    if(t &gt;= all_thread + MAX_THREAD)</span><br><span class="line">      t = all_thread;</span><br><span class="line">    if(t-&gt;state == RUNNABLE) &#123;</span><br><span class="line">      next_thread = t;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    t = t + 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (next_thread == 0) &#123;</span><br><span class="line">    printf(&quot;thread_schedule: no runnable threads\n&quot;);</span><br><span class="line">    exit(-1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (current_thread != next_thread) &#123;         /* switch threads?  */</span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    /* YOUR CODE HERE</span><br><span class="line">     * Invoke thread_switch to switch from t to next_thread:</span><br><span class="line">     * thread_switch(??, ??);</span><br><span class="line">     */</span><br><span class="line">    thread_switch((uint64)&amp;t-&gt;context, (uint64)&amp;next_thread-&gt;context);</span><br><span class="line">  &#125; else</span><br><span class="line">    next_thread = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><h4 id="要求和提示-7"><a href="#要求和提示-7" class="headerlink" title="要求和提示"></a>要求和提示</h4><p><strong>注意：本部分实验需要在有多核心处理器的 Linux&#x2F;macOS 电脑中完成，而不是在 xv6&#x2F;QEMU 下完成。</strong></p>
<p>在本部分实验中，我们将使用多线程编程和锁来实现一个 HashTable 哈希表。在本次作业中我们将使用 UNIX 下的 <code>pthread</code> 库函数，关于 <code>pthreads</code> 的更多用法，可以查询 man 手册，终端上输入 <code>man pthreads</code> 即可，也可查询相关网页。</p>
<p>文件 <code>notxv6/ph.c</code> 中实现了一个仅在单线程下可行的哈希表，但是在多线程下运行就会产生错误。我们在主目录下运行 <code>make ph</code>，随后向可执行文件中传入线程数量作为参数，例如单线程执行<code>./ph 1</code> 即可。示例如下：</p>
<p><code>ph</code> 程序中主要尝试运行两项测试，首先它通过 <code>put()</code> 尝试向哈希表中加入大量的 key，并打印出平均每秒钟执行 <code>put</code> 的数量，随后它尝试使用 <code>get()</code> 从哈希表中将 key 取出，并打印出哈希表中的 key 的数量。但是很显然目前由于没有对多线程去做额外的实现，部分的 <code>put</code> 操作丢失了，如下是程序未修改的情况下两个线程执行 <code>ph</code> 的结果，我们看到线程 <code>put()</code> 操作丢失了一些 key：</p>
<p>虽然使用两个线程使得哈希表插入的平均速度翻倍，但是带来了严重的数据丢失问题，这就是个很严重的问题需要我们解决。请仔细阅读 <code>notxv6/ph.c</code>，尤其是文件下的 <code>put()</code> 和 <code>insert()</code> 函数。</p>
<p>两个线程同时执行 <code>put()</code> 导致 key 丢失的原因是什么？请将作业答案保存在主目录下 <code>answers-thread.txt</code> 下。</p>
<p>为了确保相关时间的有序执行，我们需要在 <code>put()</code> 和 <code>get()</code> 中引入加锁和解锁机制。相关的 <code>pthread</code> 函数调用有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">pthread_mutex_t lock;            // declare a lock</span><br><span class="line">pthread_mutex_init(&amp;lock, NULL); // initialize the lock</span><br><span class="line">pthread_mutex_lock(&amp;lock);       // acquire lock</span><br><span class="line">pthread_mutex_unlock(&amp;lock);     // release lock</span><br></pre></td></tr></table></figure>

<p>记得不要忘记调用 <code>pthread_mutex_init()</code>。在这部分操作结束后，你应该可以顺利通过 <code>ph_safe</code> 测试，即不会有 key 丢失的状况存在。</p>
<p>接下来，我们尝试对哈希表的速度进行优化，在操作中有部分 <code>put()</code> 对内存的操作并无重叠部分，也许不需要一把很大的锁来保护哈希表（疯狂暗示减小锁的粒度），我们需要对 <code>ph.c</code> 做出额外的变动进而加速 <code>put()</code> 操作（提示：可以对每个哈希桶 bucket 各设置一把锁）。在这部分操作结束后，我们将通过 <code>ph_fast</code> 测试，该测试要求两个线程产生的 <code>put()</code> 速率是一个线程的 1.25 倍。</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><blockquote>
<ol>
<li>优化成多线程</li>
<li>资源共享（需要加锁）</li>
<li>只有在oput的时候才需要上锁</li>
<li>注意到这里分块了bucket，所以每一个bucket都要上锁</li>
<li>每次对于一个bucket进行操作的时候，上锁put</li>
</ol>
</blockquote>
<p>struct entry {</p>
<p> int key;</p>
<p> int value;</p>
<p> struct entry *next;</p>
<p>};</p>
<p>struct entry *table[NBUCKET];</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct entry &#123;</span><br><span class="line">  int key;</span><br><span class="line">  int value;</span><br><span class="line">  struct entry *next;</span><br><span class="line">&#125;;</span><br><span class="line">struct entry *table[NBUCKET];</span><br><span class="line"></span><br><span class="line">static </span><br><span class="line">void put(int key, int value)</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  int i = key % NBUCKET;</span><br><span class="line">  // 对每一个bucket上锁</span><br><span class="line">   pthread_mutex_lock(&amp;locks[i]);</span><br><span class="line">  // is the key already present?</span><br><span class="line">  struct entry *e = 0;</span><br><span class="line">  for (e = table[i]; e != 0; e = e-&gt;next) &#123;</span><br><span class="line">    if (e-&gt;key == key)</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  if(e)&#123;</span><br><span class="line">    // update the existing key.</span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // the new is new.</span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  // release</span><br><span class="line">    pthread_mutex_unlock(&amp;locks[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="实现同步屏障"><a href="#实现同步屏障" class="headerlink" title="实现同步屏障"></a>实现同步屏障</h3><h4 id="要求和提示-8"><a href="#要求和提示-8" class="headerlink" title="要求和提示"></a>要求和提示</h4><p><strong>注意：本部分实验需要在有多核心处理器的 Linux&#x2F;macOS 电脑中完成，而不是在 xv6&#x2F;QEMU 下完成。</strong></p>
<p>在这个部分中，我们需要实现一个同步屏障。也就是程序中的一个位置，所有参与的线程都需要等待直到所有其他线程都到达这个位置。我们将使用 <code>pthread</code> 提供的条件变量，他的机制类似于 xv6 中的 <code>sleep</code> 和 <code>wakeup</code>，我们将使用到下面这两个调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);  // go to sleep on cond, releasing lock mutex, acquiring upon wake up</span><br><span class="line">pthread_cond_broadcast(&amp;cond);     // wake up every thread sleeping on cond</span><br></pre></td></tr></table></figure>

<p>其中，<code>pthread_cond_wait</code> 在被调用时释放了 <code>mutex</code>，并在返回前重新获取了 <code>mutex</code>。</p>
<p>在 <code>notxv6/barrier.c</code> 下存在一个没有实现好的同步屏障，如果在没有修改的情况下运行，运行就会报错：</p>
<p><a target="_blank" rel="noopener" href="https://blog.rayzhang.top/2022/10/07/mit-6.s081-lab-thread/barrier-err.png"><img src="https://blog.rayzhang.top/2022/10/07/mit-6.s081-lab-thread/barrier-err.png" alt="img"></a></p>
<p>其中我们给 <code>barrier</code> 传入的第二个参数表示的是需要在同步屏障上进行同步的线程数量。每个线程都在执行一个循环，在每个循环中线程会调用 <code>barrier()</code> 然后随机睡眠若干微秒。刚才未修改的代码导致断言被触发，是因为一个线程在另一个线程到达同步屏障前就离开了。我们希望每个线程都在 <code>barrier()</code> 位置阻塞，直到 <code>nthreads</code> 个线程都调用过了 <code>barrier()</code>。</p>
<p>在 <code>notxv6/barrier.c</code> 中，<code>barrier_init()</code> 已经被给出，结构体 <code>struct barrier</code> 已经定义，仅供参考。我们只需要实现 <code>barrier()</code> 相关功能，以此来确保不会报错。</p>
<p>注意两个较难实现的点：</p>
<ul>
<li>我们需要处理一连串的 <code>barrier()</code> 调用，我们把这个叫做一轮。<code>bstate.round</code> 中记录了轮数，因此每当所有线程到达内存屏障的时候我们就需要将计数加一。</li>
<li>小心处理 <code>bstate.nthread</code>，尤其这种情形：一个线程离开了同步屏障，其他线程还没反应过来，就进入了下一轮循环，然后又遇到了同步屏障，直接对计数加一。上一轮和下一轮的计数要分清楚。</li>
</ul>
<blockquote>
<p>打字已实施，只有人气了，才会对论述进行+1，不齐就是阻塞。只有齐了才全部唤醒，操作也要上锁</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static void </span><br><span class="line">barrier()</span><br><span class="line">&#123;</span><br><span class="line">  // YOUR CODE HERE</span><br><span class="line">  //</span><br><span class="line">  // Block until all threads have called barrier() and</span><br><span class="line">  // then increment bstate.round.</span><br><span class="line">  //</span><br><span class="line">  </span><br><span class="line">  // protect nthread counter</span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  if (++bstate.nthread &lt; nthread) &#123;</span><br><span class="line">    // sleep if not all threads have reached the barrier</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // clear bstate.nthread</span><br><span class="line">    bstate.nthread = 0;</span><br><span class="line">    // imcrement on round count</span><br><span class="line">    bstate.round++;</span><br><span class="line">    // wake up all other threads</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>今天的实验还是比较简单，都是直接按照的讲授的内容锁撰写的。只需要明lock还有调度相关原理即可，基本可以实现。</p>
<h2 id="7-lock"><a href="#7-lock" class="headerlink" title="7.lock"></a>7.lock</h2><h3 id="内存分配器加速"><a href="#内存分配器加速" class="headerlink" title="内存分配器加速"></a>内存分配器加速</h3><h4 id="要求和提示-9"><a href="#要求和提示-9" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在 <code>user/kalloctest.c</code> 下我们实现了一个测试，在这个测试中针对 xv6 的内存分配器进行了重点测试，使用了三个进程大量的对地址空间进行增加和缩小，导致大量对 <code>kalloc</code> 和 <code>kfree</code> 的调用，其中 <code>kalloc</code> 和 <code>kfree</code> 在执行时均需要获取锁 <code>kmem.lock</code>。在这里我们使用 <code>kalloctest</code> 打印了由于另一进程已经持有了锁而在尝试自旋获取的次数，在这里使用<code>#fetch-and-add</code> 打印进行表示。需要指出的是，自旋的次数只能作为锁冲突的一种粗略的衡量。如果我们还没有对当前的 Lab 做出修改，我们执行 <code>kalloctest</code> 会得到如下类似的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">$ kalloctest</span><br><span class="line">start test1</span><br><span class="line">test1 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: #fetch-and-add 83375 #acquire() 433015</span><br><span class="line">lock: bcache: #fetch-and-add 0 #acquire() 1260</span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: kmem: #fetch-and-add 83375 #acquire() 433015</span><br><span class="line">lock: proc: #fetch-and-add 23737 #acquire() 130718</span><br><span class="line">lock: virtio_disk: #fetch-and-add 11159 #acquire() 114</span><br><span class="line">lock: proc: #fetch-and-add 5937 #acquire() 130786</span><br><span class="line">lock: proc: #fetch-and-add 4080 #acquire() 130786</span><br><span class="line">tot= 83375</span><br><span class="line">test1 FAIL</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>acquire</code> 针对每一个锁，打印出了当前锁的调用次数（<code>#acquire()</code> 后），以及为了获取锁失败而产生的自旋次数（<code>#fetch-and-add()</code> 后）。<code>kalloctest</code> 通过调用系统调用，要求内核为 <code>kmem</code> 和 <code>bcache</code> 打印相关的计数信息，以及 5 个竞争最激烈的锁。如果发生了锁竞争，那么自旋的次数就会很大。由于在这部分实验中，我们比较关心 <code>kmem</code> 和 <code>bcache</code> 两个锁的性能，系统调用最后会返回这两个锁上发生的自旋次数的总和。</p>
<p>需要注意到的是，为了完成当前的 Lab，我们需要使用一台多核心独立无负载的机器。如果使用的机器上面有其他的工作负载，<code>kalloctest</code> 打印出的计数次数就会失去意义。</p>
<p>现在让我们来关注代码，在 <code>kalloctest</code> 中产生大量锁冲突的根本原因是 <code>kalloc()</code> 只有一个空闲列表。为了尽可能的规避锁冲突，我们需要重新设计内存分配器来避免一个唯一的锁和空闲列表。有一个很简单的想法，我们在每个 CPU 核心中都维护一个空闲列表，每个空闲列表有自己的锁。这样下来，在不同 CPU 下的内存分配和释放就可以并行运行，因为每个 CPU 都操作的是不同的空闲列表。这个想法实现下来最大的困难是，如何处理如下情形，一个 CPU 的空闲列表已经空了，但是另一个 CPU 仍然有空闲的内存。为了处理这样的情形，我们的 CPU 需要从别的 CPU 的空闲列表中 “偷出” 一部分空闲内存。这种 “偷窃内存” 也有可能引入锁冲突，但是希望这样会少频繁一些。</p>
<p>我们需要做的事情总结下来就是为每个 CPU 维护空闲列表，并当空闲列表空时从其他 CPU 处 “偷取” 空余内存。也就是说，我们需要为我们的每一个列表的锁都调用 <code>initlock</code>，并将名字设置为 <code>kmem</code> 开头。我们需要运行 <code>kalloctest</code> 来查看我们的实现是否减少了锁的竞争，此外为了确保实现没有问题我们还能正确分配所有的内存，我们需要运行 <code>usertests sbrkmuch</code> 测试。我们需要通过 <code>test1</code> 和 <code>test2</code> 测试，测试的相关输出示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">$ kalloctest</span><br><span class="line">start test1</span><br><span class="line">test1 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: #fetch-and-add 0 #acquire() 42843</span><br><span class="line">lock: kmem: #fetch-and-add 0 #acquire() 198674</span><br><span class="line">lock: kmem: #fetch-and-add 0 #acquire() 191534</span><br><span class="line">lock: bcache: #fetch-and-add 0 #acquire() 1242</span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: proc: #fetch-and-add 43861 #acquire() 117281</span><br><span class="line">lock: virtio_disk: #fetch-and-add 5347 #acquire() 114</span><br><span class="line">lock: proc: #fetch-and-add 4856 #acquire() 117312</span><br><span class="line">lock: proc: #fetch-and-add 4168 #acquire() 117316</span><br><span class="line">lock: proc: #fetch-and-add 2797 #acquire() 117266</span><br><span class="line">tot= 0</span><br><span class="line">test1 OK</span><br><span class="line">start test2</span><br><span class="line">total free number of pages: 32499 (out of 32768)</span><br><span class="line">.....</span><br><span class="line">test2 OK</span><br><span class="line">$ usertests sbrkmuch</span><br><span class="line">usertests starting</span><br><span class="line">test sbrkmuch: OK</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$ usertests</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>相关提示：</p>
<ul>
<li>我们可以使用 <code>kernel/param.h</code> 下的 <code>NCPU</code> 常量表示 CPU 数量。</li>
<li>使用 <code>freerange</code> 为当前运行 <code>freerange</code> 的 CPU 提供所有空余内存。</li>
<li>函数 <code>cpuid</code> 可以返回当前的 CPU 核心编号，但是只有在中断处于关闭状态时调用才是安全的，我们需要使用 <code>push_off()</code> 和 <code>pop_off()</code> 来控制中断的关和开。</li>
<li>可以看看在 <code>kernel/sprintf.c</code> 下是怎么实现格式化字符串的。当然，我们将空闲列表锁的名称设置为 <code>kmem</code> 也是完全可以的</li>
</ul>
<h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><blockquote>
<p>1.，我们在每个 CPU 核心中都维护一个空闲列表，每个空闲列表有自己的锁。这样下来，在不同 CPU 下的内存分配和释放就可以并行运行，因为每个 CPU 都操作的是不同的空闲列表。</p>
<p>2.一个 CPU 的空闲列表已经空了，但是另一个 CPU 仍然有空闲的内存。为了处理这样的情形，我们的 CPU 需要从别的 CPU 的空闲列表中 “偷出” 一部分空闲内存。这种 “偷窃内存” 也有可能引入锁冲突，但是希望这样会少频繁一些。</p>
</blockquote>
<p>根据题意我们锁需要做的就是</p>
<ol>
<li>对每一个cpu都进行设置kmem</li>
<li>使用 <code>freerange</code> 为当前运行 <code>freerange</code> 的 CPU 提供所有空余内存。</li>
<li>如果当前cpu不够就进行偷取其他的，同事要跳过当前cpu</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem[NCPU];</span><br></pre></td></tr></table></figure>

<p>首先是设置cpu个数，然后初始化锁，还有刚开始，吧所有线程分给0号，之后在进行偷取</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kinit()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// initlock(&amp;kmem.lock, &quot;kmem&quot;);</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">    initlock(&amp;kmem[i].lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据之前我们讲到的有，首先需要freerange，吧这个内存放到当前的cpu，需要重新写一个程序，因为kfree这个函数被多个其他函数调用。我们需要修改这个kfree—cpu，按照kfree的写法修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">freerange(void *pa_start, void *pa_end)</span><br><span class="line">&#123;</span><br><span class="line">  char *p;</span><br><span class="line">  p = (char*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  // 获取当前cpu，当前直接全部吃掉</span><br><span class="line">  push_off();</span><br><span class="line">  int cpu = cpuid();</span><br><span class="line">  pop_off();</span><br><span class="line"></span><br><span class="line">  for(; p + PGSIZE &lt;= (char*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree_cpu(cpu,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void kfree(void *pa) &#123; </span><br><span class="line">  push_off();</span><br><span class="line">  int cpu = cpuid();</span><br><span class="line">  pop_off();</span><br><span class="line">  kfree_cpu(cpu,pa);</span><br><span class="line">&#125;</span><br><span class="line">// Free the page of physical memory pointed at by v,</span><br><span class="line">// which normally should have been returned by a</span><br><span class="line">// call to kalloc().  (The exception is when</span><br><span class="line">// initializing the allocator; see kinit above.)</span><br><span class="line">void</span><br><span class="line">kfree_cpu(int cpu,void *pa)</span><br><span class="line">&#123;</span><br><span class="line">  struct run *r;</span><br><span class="line"></span><br><span class="line">  if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(&quot;kfree&quot;);</span><br><span class="line"></span><br><span class="line">  // Fill with junk to catch dangling refs.</span><br><span class="line">  memset(pa, 1, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line">  // huoqu dangqian de cpu</span><br><span class="line">  // 需要终端</span><br><span class="line">  acquire(&amp;kmem[cpu].lock);</span><br><span class="line">  r-&gt;next = kmem[cpu].freelist;</span><br><span class="line">  kmem[cpu].freelist = r;</span><br><span class="line">  release(&amp;kmem[cpu].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是kalloc的实现，主要就是实现偷取，进行遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  <span class="comment">// 获取当前线程</span></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="type">int</span> cpu = cpuid();</span><br><span class="line">  pop_off();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem[cpu].lock);</span><br><span class="line">  r = kmem[cpu].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    kmem[cpu].freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem[cpu].lock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 借鉴别人的一些</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* code */</span></span><br><span class="line">      <span class="keyword">if</span> (i==cpu)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      acquire(&amp;kmem[i].lock);</span><br><span class="line">      r = kmem[i].freelist;</span><br><span class="line">      <span class="comment">// 开始stolen</span></span><br><span class="line">      <span class="keyword">if</span> (r)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">         kmem[i].freelist = r-&gt;next;</span><br><span class="line">          release(&amp;kmem[i].lock);</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;kmem[i].lock);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">      release(&amp;kmem[cpu].lock);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="磁盘缓存加速"><a href="#磁盘缓存加速" class="headerlink" title="磁盘缓存加速"></a>磁盘缓存加速</h3><h4 id="要求和提示-10"><a href="#要求和提示-10" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在本部分中实验与上半部分互相独立，如果愿意也可以先做这部分，前部分结果并不会影响当前部分的完成。</p>
<p>当多个进程尝试大量的使用文件系统时，锁 <code>bcache.lock</code> 就会产生大量的冲突，这个锁的功能就是在 <code>kernel/bio.c</code> 中保护磁盘块缓存。我们的测试程序 <code>bcachetest</code> 会创建多个进程，并不断的读取不同的文件来触发锁 <code>bcache.lock</code> 上的冲突，在我们还没有完成 Lab 前，<code>bcachetest</code> 输出类似如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">$ bcachetest</span><br><span class="line">start test0</span><br><span class="line">test0 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: #fetch-and-add 0 #acquire() 33035</span><br><span class="line">lock: bcache: #fetch-and-add 16142 #acquire() 65978</span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: virtio_disk: #fetch-and-add 162870 #acquire() 1188</span><br><span class="line">lock: proc: #fetch-and-add 51936 #acquire() 73732</span><br><span class="line">lock: bcache: #fetch-and-add 16142 #acquire() 65978</span><br><span class="line">lock: uart: #fetch-and-add 7505 #acquire() 117</span><br><span class="line">lock: proc: #fetch-and-add 6937 #acquire() 73420</span><br><span class="line">tot= 16142</span><br><span class="line">test0: FAIL</span><br><span class="line">start test1</span><br><span class="line">test1 OK</span><br></pre></td></tr></table></figure>

<p>具体输出的数字可能有所差异，但是肯定可以看到 <code>bcache</code> 锁由于不断 <code>acquire</code> 产生的自旋尝试次数会变得很高。在 <code>kernel/bio.c</code> 中，我们可以看到 <code>bcache.lock</code> 保护了缓存块列表，包括每个块中的引用数 <code>b-&gt;refcnt</code> 以及缓存块的信息（<code>b-&gt;dev</code> 和 <code>b-&gt;blockno</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  struct buf buf[NBUF];</span><br><span class="line"></span><br><span class="line">  // Linked list of all buffers, through prev/next.</span><br><span class="line">  // Sorted by how recently the buffer was used.</span><br><span class="line">  // head.next is most recent, head.prev is least.</span><br><span class="line">  struct buf head;</span><br><span class="line">&#125; bcache;</span><br><span class="line"></span><br><span class="line">struct buf &#123;</span><br><span class="line">  int valid;   // has data been read from disk?</span><br><span class="line">  int disk;    // does disk &quot;own&quot; buf?</span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  struct sleeplock lock;</span><br><span class="line">  uint refcnt;</span><br><span class="line">  struct buf *prev; // LRU cache list</span><br><span class="line">  struct buf *next;</span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们的目标是修改缓存块使得在 <code>bcachetest</code> 测试中，由于对尝试锁 <code>acquire</code> 产生的自旋次数尽可能的少且接近零。理想状态下，块缓存中涉及所有锁的尝试自旋次数之和应该为 <code>0</code>，但是总和小于 <code>500</code> 也是可以接受的。我们需要修改 <code>bget</code> 和 <code>brelse</code>，使得 <code>bcache</code> 中的涉及不同缓存块的查找和释放时更不容易在锁上发生冲突（例如，不需要所有操作都等待 <code>bcache.lock</code>）。同时，我们需要确保每个磁盘块只会有一份缓存。</p>
<p>当完成时，我们的输出示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">$ bcachetest</span><br><span class="line">start test0</span><br><span class="line">test0 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: #fetch-and-add 0 #acquire() 32954</span><br><span class="line">lock: kmem: #fetch-and-add 0 #acquire() 75</span><br><span class="line">lock: kmem: #fetch-and-add 0 #acquire() 73</span><br><span class="line">lock: bcache: #fetch-and-add 0 #acquire() 85</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 4159</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 2118</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 4274</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 4326</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 6334</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 6321</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 6704</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 6696</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 7757</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 6199</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 4136</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 4136</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 2123</span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: virtio_disk: #fetch-and-add 158235 #acquire() 1193</span><br><span class="line">lock: proc: #fetch-and-add 117563 #acquire() 3708493</span><br><span class="line">lock: proc: #fetch-and-add 65921 #acquire() 3710254</span><br><span class="line">lock: proc: #fetch-and-add 44090 #acquire() 3708607</span><br><span class="line">lock: proc: #fetch-and-add 43252 #acquire() 3708521</span><br><span class="line">tot= 128</span><br><span class="line">test0: OK</span><br><span class="line">start test1</span><br><span class="line">test1 OK</span><br><span class="line">$ usertests</span><br><span class="line">  ...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>在 <code>initlock</code> 中，我们需要给我们创建的每个锁一个名字，以 <code>bcache</code> 开头，。</p>
<p>相比刚才的 <code>kalloc</code> 内存分配，这里处理减少对于缓存块的竞争问题更加棘手，因为 <code>bcache</code> 缓冲区是在进程、CPU 之间共享的。对于 <code>kalloc</code> 来说，我们可以为每个 CPU 安排一个空闲列表来解决，在这里却是行不通的。我们需要使用一个哈希表来查询块编号，并给每一个 bucket 桶设置一把锁。</p>
<p>这些情况下，如果发生锁冲突我们认定是可以接受的：</p>
<ul>
<li>当两个进程同时操作相同的块编号时，在 <code>bcachetest</code> 中的 <code>test0</code> 我们不会这样测试。</li>
<li>当两个进程同时没有命中缓存，并需要寻找一块没有被使用的缓存块进行替换时。我们在 <code>bcachetest</code> 中的 <code>test0</code> 下也不会这样测试。</li>
<li>当两个进程操作的块编号在你用来划分区块和锁的方案中发生冲突时；例如，两个进程给定的块编号映射到了同一个哈希表的 bucket 桶中。这是完全有可能的，<code>bcachetest</code> 中的 <code>test0</code> 有可能会这样做，这完全取决于我们的设计，但我们应该尝试调整方案的细节以避免冲突（例如，改变哈希表的大小）。</li>
</ul>
<p>和 <code>test0</code> 相比之下，<code>test1</code> 中将测试操作更多不同的块编号，并大量使用文件系统的代码路径。</p>
<p>相关提示：</p>
<ul>
<li>请阅读 xv6 教材 PDF 中关于块缓存的描述（见 8.1~8.3 节）</li>
<li>为哈希表设置固定数量的桶是可以的，可以不去动态调整哈希表的大小。另外可以使用质数数量的桶（例如 13）来减少散列冲突。</li>
<li>在哈希表中搜索块编号，如果没有命中我们再重新分配条目，这两个操作需要是原子的。</li>
<li>我们需要删除所有缓存块列表（<code>bcache.head</code> 等），改为使用缓冲区的最后时间（即使用 <code>kernel/trap.c</code> 下的 <code>ticks</code> 来记录时间戳）。这样修改后，<code>brelse</code> 就不需要获取 <code>bcache</code> 锁，<code>bget</code> 也可以根据时间戳选择最久没有使用的块。</li>
<li>在 <code>bget</code> 中序列化地进行驱逐是可行的（即 <code>bget</code> 中选择缓存块的部分，当查找缓存未命中时可以选择一个缓存块重新使用）。</li>
<li>我们的答案在一些情形下需要使用两把锁；例如，在驱逐缓存块期间，我们可能需要持有 <code>bcache</code> 和哈希表 bucket 下的锁。请确保不会发生死锁。</li>
<li>当我们尝试替换一个缓存块，我们可能需要将一个缓冲块从一个桶 bucket 转移到另一个桶 bucket。我们可能会遇到棘手的问题，也就是新的块可能哈希到与旧的块相同的桶，务必注意不要发生死锁。</li>
<li>一些调试小技巧：实现 bucket 锁的时候，可以先在 <code>bget</code> 的开始和结束位置留下全局的 <code>bcache.lock</code> 的加锁解锁。当我们尝试解决了竞争问题，尝试运行测试的时候再去掉全局锁，处理并发问题。我们也可以使用 <code>make CPUS=1 qemu</code> 来使用单独一个核心来进行测试。</li>
</ul>
<h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><blockquote>
<ul>
<li>哈希表设置固定数量的桶是可以的，可以不去动态调整哈希表的大小。另外可以使用质数数量的桶（例如 13）来减少散列冲突。</li>
<li>希表中搜索块编号，如果没有命中我们再重新分配条目，这两个操作需要是原子的</li>
</ul>
</blockquote>
<p>这一节需要我们对磁盘有一定的了解</p>
<p><img src="https://pica.zhimg.com/v2-395ac352730e6573b0e71d02e177205a_720w.jpg?source=d16d100b" alt="「实验记录」MIT 6.S081 Lab8 locks"></p>
<p>文件的基本构造，首先最下面进行操作 的是disk，之后我们通过对bcache进行操作，然后写入disk，logging是负责记录操作的日子，为了房子电脑停电crash，inode则是每一个虚拟dev对应的数据结构，通过对pathname我们来得到文件夹dinode</p>
<p>现在我们来看buf cache的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出则是一个双向链表，则是实现lru来进行构造的，buf数组是所有的缓存区文件，head是为了好进行lru才构造的。我们现在的目的是制作多个head，发散到不同的头上面，然后来进行删除</p>
<p>根据上面的提示，我们把这一整个链表分成多个段，使用13座为三列值，三列函数，使用dev+blockno，来得到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// struct spinlock lock;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">hashtable</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lks</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">&#125; bcache;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置hash函数，用于get得到对应的bucket</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (dev + blockno) % NBUCKET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正的底层操作还是在hashtable，每一个hashtable都是单独的一个双向链表，我们还是在单独的双向链表进行操作，但是初始化，吧所有的节点还是挂到0号，之后和上面一样进行偷取</p>
<p>首先还是进行lock初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="comment">// 初始化所有的锁</span></span><br><span class="line">  <span class="comment">// initlock(&amp;bcache.lock, &quot;bcache&quot;);</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">    initlock(&amp;bcache.lks[i], <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">    <span class="comment">// 对bucket来进行</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">    bcache.hashtable[i].prev = &amp;bcache.hashtable[i];</span><br><span class="line">    bcache.hashtable[i].next = &amp;bcache.hashtable[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对每一个buf，进行设置为单独的节点，不是数组</span></span><br><span class="line">  <span class="comment">// Create linked list of buffers</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 一次性分配给0号bucket</span></span><br><span class="line">  <span class="comment">/* code */</span></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.buf; b &lt; bcache.buf + NBUF; b++)</span><br><span class="line">  &#123;</span><br><span class="line">    b-&gt;next = bcache.hashtable[<span class="number">0</span>].next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.hashtable[<span class="number">0</span>];</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化每一个buf的</span></span><br><span class="line">    <span class="comment">// 头插法</span></span><br><span class="line">    bcache.hashtable[<span class="number">0</span>].next-&gt;prev = b;</span><br><span class="line">    bcache.hashtable[<span class="number">0</span>].next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>接下来就是什么时候更新会见戳，当我们这个这个数据结构引用次数是0的时候，就需要进行更新了，之前是直接自己进行lru算法实现，现在我们只需要吧这个变成当前时间就可以</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line">  <span class="comment">// 通过buf获取bucket</span></span><br><span class="line">  <span class="type">int</span> index = hash(b-&gt;dev, b-&gt;blockno);</span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lks[index]);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="comment">// 不需要进行移动了，更新时间就行</span></span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// no one is waiting for it.</span></span><br><span class="line">    <span class="comment">// b-&gt;next-&gt;prev = b-&gt;prev;</span></span><br><span class="line">    <span class="comment">// b-&gt;prev-&gt;next = b-&gt;next;</span></span><br><span class="line">    <span class="comment">// b-&gt;next = bcache.hashtable[index].next;</span></span><br><span class="line">    <span class="comment">// b-&gt;prev = &amp;bcache.hashtable[index];</span></span><br><span class="line">    <span class="comment">// bcache.hashtable[index].next-&gt;prev = b;</span></span><br><span class="line">    <span class="comment">// bcache.hashtable[index].next = b;</span></span><br><span class="line">    <span class="comment">// 最左边的是要进行删除的</span></span><br><span class="line"></span><br><span class="line">    acquire(&amp;tickslock);</span><br><span class="line">    b-&gt;timestamp = ticks;</span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新时间</span></span><br><span class="line"></span><br><span class="line">  release(&amp;bcache.lks[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> id = myhash(b-&gt;blockno);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lks[id]);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  release(&amp;bcache.lks[id]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bunpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> id = myhash(b-&gt;blockno);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lks[id]);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  release(&amp;bcache.lks[id]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>最后就是如何进行偷取，bget的任务就是根据给定dev还有blockno来进行得到所需要的buf。下面是2中解决</p>
<p>我们是首先根据他的id，来算出他是哪一个bucket里面的，之后对这个bucket来进行遍历，看这个buf存不存在。不存在，就是用lru策略，使用时间戳来进行换出。如果是没有空闲节点，那就需要进行偷取，遍历其他bucket，然后找到空闲的，之后修改这个空闲的dev还有no来进行偷取</p>
<ol>
<li>获取当前的bucket</li>
<li>查看有没有他</li>
<li>没有就查看有没有空闲节点，使用lru换出</li>
<li>也没有，就使用lru偷取别人的</li>
</ol>
<p>1.查找bucket，看有没有缓存可以使用的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">truct buf *b;</span><br><span class="line">  <span class="type">int</span> index = hash(dev, blockno);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lks[index]);</span><br><span class="line">  <span class="comment">// 锁index的bucket</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过head查找不是数组</span></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.hashtable[index].next; b != &amp;bcache.hashtable[index]; b = b-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)</span><br><span class="line">    &#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.lks[index]);</span><br><span class="line">      <span class="comment">// 自旋转锁</span></span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>2.没有，就从自己的空闲使用lru</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not cached.</span></span><br><span class="line"> <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line"> <span class="comment">// 这里是直接使用时间戳</span></span><br><span class="line"> <span class="comment">// todo: 修改</span></span><br><span class="line"> <span class="comment">// 还是和之前一样，开始查找，没有就开始偷取</span></span><br><span class="line"> <span class="comment">//  使用时间戳来进行比较</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">victm</span> =</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"> acquire(&amp;tickslock);</span><br><span class="line"> uint minticks = ticks;</span><br><span class="line"> release(&amp;tickslock);</span><br><span class="line"> <span class="comment">// 找到最小的，进行替换</span></span><br><span class="line"> <span class="keyword">for</span> (b = bcache.hashtable[index].next; b != &amp;bcache.hashtable[index]; b = b-&gt;next)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">/* code */</span></span><br><span class="line">   <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span> &amp;&amp; b-&gt;timestamp &lt;=minticks)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">/* code */</span></span><br><span class="line">     victm = b;</span><br><span class="line">     minticks = b-&gt;timestamp;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>还是没找到，就偷取别人，找到就break’</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!victm)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 找不到就开始偷取</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* code */</span></span><br><span class="line">      <span class="comment">// 从不同的bucket的查找</span></span><br><span class="line">      <span class="keyword">if</span> (i == index)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// huoqu lock</span></span><br><span class="line">      acquire(&amp;bcache.lks[i]);</span><br><span class="line">      <span class="comment">// 接着查找</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      复制上面的代码</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      acquire(&amp;tickslock);</span><br><span class="line">      minticks = ticks;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 找到最小的，进行替换</span></span><br><span class="line">      <span class="keyword">for</span> (b = bcache.hashtable[i].next; b != &amp;bcache.hashtable[i]; b = b-&gt;next)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span> &amp;&amp; b-&gt;timestamp &lt;= minticks)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* code */</span></span><br><span class="line">          victm = b;</span><br><span class="line">          minticks = b-&gt;timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       release(&amp;bcache.lks[i]);</span><br><span class="line">      <span class="keyword">if</span> (victm)</span><br><span class="line">      &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 开锁</span></span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最后就是如果找到了，就进行初始化，更换dev，还有block，还有ref，同事还有进行打开和释放链表，双向链表得到操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (victm)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* code */</span></span><br><span class="line">      <span class="comment">// 找到就进行break</span></span><br><span class="line">      <span class="comment">// 吧他翘出来，放到inde</span></span><br><span class="line">      b=victm;</span><br><span class="line">      b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">      b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化这个锁信息</span></span><br><span class="line">      <span class="comment">// 更新</span></span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 放入到index 头插法</span></span><br><span class="line">      b-&gt;next = bcache.hashtable[index].next;</span><br><span class="line">      bcache.hashtable[index].next-&gt;prev = b;</span><br><span class="line">      bcache.hashtable[index].next = victm;</span><br><span class="line">      b-&gt;prev = &amp;bcache.hashtable[index];</span><br><span class="line"></span><br><span class="line">  acquiresleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  release(&amp;bcache.lks[index]);</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是全部操作的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf *</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="type">int</span> index = hash(dev, blockno);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lks[index]);</span><br><span class="line">  <span class="comment">// 锁index的bucket</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过head查找不是数组</span></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.hashtable[index].next; b != &amp;bcache.hashtable[index]; b = b-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)</span><br><span class="line">    &#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.lks[index]);</span><br><span class="line">      <span class="comment">// 自旋转锁</span></span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="comment">// 这里是直接使用时间戳</span></span><br><span class="line">  <span class="comment">// todo: 修改</span></span><br><span class="line">  <span class="comment">// 还是和之前一样，开始查找，没有就开始偷取</span></span><br><span class="line">  <span class="comment">//  使用时间戳来进行比较</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">victm</span> =</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  uint minticks = ticks;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="comment">// 找到最小的，进行替换</span></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.hashtable[index].next; b != &amp;bcache.hashtable[index]; b = b-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">    <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span> &amp;&amp; b-&gt;timestamp &lt;=minticks)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* code */</span></span><br><span class="line">      victm = b;</span><br><span class="line">      minticks = b-&gt;timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!victm)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 找不到就开始偷取</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* code */</span></span><br><span class="line">      <span class="comment">// 从不同的bucket的查找</span></span><br><span class="line">      <span class="keyword">if</span> (i == index)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// huoqu lock</span></span><br><span class="line">      acquire(&amp;bcache.lks[i]);</span><br><span class="line">      <span class="comment">// 接着查找</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      复制上面的代码</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      acquire(&amp;tickslock);</span><br><span class="line">      minticks = ticks;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 找到最小的，进行替换</span></span><br><span class="line">      <span class="keyword">for</span> (b = bcache.hashtable[i].next; b != &amp;bcache.hashtable[i]; b = b-&gt;next)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span> &amp;&amp; b-&gt;timestamp &lt;= minticks)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* code */</span></span><br><span class="line">          victm = b;</span><br><span class="line">          minticks = b-&gt;timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       release(&amp;bcache.lks[i]);</span><br><span class="line">      <span class="keyword">if</span> (victm)</span><br><span class="line">      &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 开锁</span></span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> (victm)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">/* code */</span></span><br><span class="line">        <span class="comment">// 找到就进行break</span></span><br><span class="line">        <span class="comment">// 吧他翘出来，放到inde</span></span><br><span class="line">        b=victm;</span><br><span class="line">        b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">        b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化这个锁信息</span></span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        b-&gt;blockno = blockno;</span><br><span class="line">        b-&gt;dev = dev;</span><br><span class="line">        b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">        b-&gt;valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放入到index 头插法</span></span><br><span class="line">        b-&gt;next = bcache.hashtable[index].next;</span><br><span class="line">        bcache.hashtable[index].next-&gt;prev = b;</span><br><span class="line">        bcache.hashtable[index].next = victm;</span><br><span class="line">        b-&gt;prev = &amp;bcache.hashtable[index];</span><br><span class="line"></span><br><span class="line">    acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">  </span><br><span class="line">    release(&amp;bcache.lks[index]);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;bcache.lks[index]);</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>第一个内存分配的题目是送分题目，基本上只要看懂题目就知道如何理解。第二个这个也是参考别人的实现，有的是没使用单链表，这个博主的思路和之前代码基本一样比较好理解，就对这个博主的代码进行了参考。</p>
<h2 id="8-fs"><a href="#8-fs" class="headerlink" title="8.fs"></a>8.fs</h2><h3 id="大文件实现"><a href="#大文件实现" class="headerlink" title="大文件实现"></a>大文件实现</h3><h4 id="要求和提示-11"><a href="#要求和提示-11" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在这个部分中，我们将为 xv6 提高其文件系统所能支持的最大文件大小。当前 xv6 所支持的最大文件大小被限制在 268 个块，也就是 <code>268*BSIZE</code> 个字节（在 xv6 中 <code>BSIZE</code> 块内存大小为 1024）。这个限制的原因来自在 xv6 的 inode 中，存储有 12 个 “直接” 块编号和一个 “间接” 块编号，在 “间接” 块编号指向的块中又可以存储 256 个块编号。因此，一个文件最多可以对应 12+256&#x3D;26812+256&#x3D;26812+256&#x3D;268 个块。</p>
<p>这是在 PDF 中图 8.3，很好的表示了这一结构：</p>
<p><img src="https://blog.rayzhang.top/2022/10/19/mit-6.s081-lab-fs/inode.png" alt="img"></p>
<p>在这部分作业中，我们将使用 <code>bigfile</code> 进行测试能创建的最大文件，如果我们暂时还没有对当前 xv6 修改，我们会获得这样的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">$ bigfile</span><br><span class="line">..</span><br><span class="line">wrote 268 blocks</span><br><span class="line">bigfile: file is too s</span><br></pre></td></tr></table></figure>

<h4 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h4><p>这一个题目是408考了很多次的题目，直接看提示就可以写的。首先设置最大的文件块长度，是直接+一级+二级，二级索引是一级*一级。之后把地址进行变成addr+2，0 -addr-1是直接，addr是一级，addr+1下标代表的是二级。同事inode还有dinode也要更新，之后就是进行分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT + NINDIRECT * NINDIRECT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>分配，是在一级之后来进行二级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inode content</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The content (data) associated with each inode is stored</span></span><br><span class="line"><span class="comment">// in blocks on the disk. The first NDIRECT block numbers</span></span><br><span class="line"><span class="comment">// are listed in ip-&gt;addrs[].  The next NINDIRECT blocks are</span></span><br><span class="line"><span class="comment">// listed in block ip-&gt;addrs[NDIRECT].</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the disk block address of the nth block in inode ip.</span></span><br><span class="line"><span class="comment">// If there is no such block, bmap allocates one.</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NINDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT * NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load doubly-indirect block, allocating if necessary</span></span><br><span class="line">    <span class="type">int</span> index = bn / NINDIRECT; <span class="comment">// Determine which indirect block</span></span><br><span class="line">    <span class="type">int</span> offset = bn % NINDIRECT; <span class="comment">// Determine offset of the data block in the indirect block</span></span><br><span class="line">    <span class="comment">// Create the doubly-indirect block if not exists</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT + <span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT + <span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the indirect block if not exists</span></span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[index]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[index] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the data block if not exists</span></span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[offset]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[offset] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>)</span><br><span class="line">      </span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<p>删除也是一样的操作，首先获取地址，然后对这个网页在进行遍历，之后再次进行删除，直接抄袭一级索引就行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Truncate inode (discard contents).</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j, k;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>, *<span class="title">ibp</span>;</span></span><br><span class="line">  uint *a, *b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Locate doubly-indirect block</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT + <span class="number">1</span>])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class="number">1</span>]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="comment">// Traverse indirect blocks</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])&#123;</span><br><span class="line">        ibp = bread(ip-&gt;dev, a[j]);</span><br><span class="line">        b = (uint*)ibp-&gt;data;</span><br><span class="line">        <span class="comment">// Traverse data blocks</span></span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; NINDIRECT; k++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(b[k])</span><br><span class="line">            bfree(ip-&gt;dev, b[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(ibp);</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class="number">1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="符号链接实现"><a href="#符号链接实现" class="headerlink" title="符号链接实现"></a>符号链接实现</h3><h4 id="要求和提示-12"><a href="#要求和提示-12" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在这一部分中，我们将为 xv6 添加符号链接（软链接）功能。符号链接通过路径名指向一个被链接的文件；当一个符号链接被打开时，内核会跟踪符号链接访问对应的文件。符号链接类似于硬链接，但是硬链接只仅限于指向同一磁盘的文件，而符号链接可以跨越磁盘。虽然 xv6 不支持多设备，但是实现这个系统调用是一个很好的练习，可以帮助我们了解路径名查询的工作原理。</p>
<p>我们的目标是实现系统调用 <code>symlink(char *target, char *path)</code>，他将在指定路径上创建一个新的符号链接，指向由目标命名的文件。想了解更多用法，我们可以查看 <code>symlink</code> 的 man 页面。为了测试 <code>symlink</code> 系统调用，我们需要向主目录下 <code>Makefile</code> 文件中加入 <code>symlinktest</code>（添加系统调用的基操，忘记了的话去重温下 Lab Syscall）。成功的 <code>symlinktest</code> 运行结果示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">$ symlinktest</span><br><span class="line">Start: test symlinks</span><br><span class="line">test symlinks: ok</span><br><span class="line">Start: test concurrent symlinks</span><br><span class="line">test concurrent symlinks: ok</span><br><span class="line">$ usertests</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<p>相关提示：</p>
<ul>
<li>首先，为 <code>symlink</code> 创建一个新的系统调用编号，在 <code>user/usys.pl</code> 和 <code>user/user.h</code> 中添加条目，并在 <code>kernel/sysfile.c</code> 中实现 <code>sys_symlink</code>。（不记得的强烈建议重新去看一下 Lab Syscall）</li>
<li>向 <code>kernel/stat.h</code> 中添加一个新的文件类型 <code>T_SYMLINK</code>，以表示符号链接。</li>
<li>我们需要在 <code>kernel/fcntl.h</code> 中添加一个新的标志 <code>O_NOFOLLOW</code>，我们可以与 <code>open</code> 系统调用一起使用。请注意，传递给 <code>open</code> 的标志是按照位检测的，所以新标志不应当与现有的标志位重叠。在添加标志位之后，只要我们将 <code>symlinktest</code> 加入到 Makefile 中，<code>user/symlinktest.c</code> 就可以顺利通过编译。</li>
<li>我们将实现 <code>symlink(target, path)</code> 系统调用，在指定目录下创建一个指向目标的新符号链接。需要注意的是，系统调用的成功并不需要目标的存在。因此，我们需要选择一个地方来存储符号链接的目标路径（例如，在 inode 下的数据块中）。最后 <code>symlink</code> 应当返回一个整数，代表成功（0）或者失败（-1），类似于 <code>link</code> 和 <code>unlink</code>。</li>
<li>我们需要修改 <code>open</code> 系统调用，以处理路径指向符号链接的情况。如果该文件不存在，<code>open</code> 系统调用需要返回失败。当一个进程在打开标志中指定 <code>O_NOFOLLOW</code> 标志位时，<code>open</code> 应当打开链接（但不跟踪符号链接）。</li>
<li>如果被链接的文件也是一个符号链接，我们必须递归地跟踪他，直到到达一个非链接文件。如果链接形成了一个循环，我们需要返回一个错误代码。我们也可以提前设定一个阈值（例如 10），当链接的深度到达阈值就返回错误代码来近似地处理这个问题。</li>
<li>其他系统调用（例如 <code>link</code> 和 <code>unlink</code>）则不能跟踪符号链接，这些系统调用只能操作符号链接本身。</li>
<li>在这个 Lab 中，我们不需要处理指向文件夹的符号链接。</li>
</ul>
<h4 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h4><ol>
<li>首先是设置symlin，这个之前就讲了很多就不在讲了</li>
<li>之后添加文件类型</li>
<li>然后对symlink进行实现，得到两个str</li>
<li>通过create来进行穿件文件类型，之后就是写入targetpath到这个inode里面</li>
<li>之后对open操作，进行修改，加入判断是不是软连接，然后次数要不要进行递归</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="type">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="comment">// Get params from user space</span></span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, target, MAXPATH)) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="comment">// Create inode of the symlink</span></span><br><span class="line">  <span class="keyword">if</span>((ip = create(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Save the target path to the first data block</span></span><br><span class="line">  <span class="keyword">if</span>(writei(ip, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, n) != n) &#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ip-&gt;type == T_SYMLINK &amp;&amp; !(omode &amp; O_NOFOLLOW))&#123;</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Follow the symlink recursively</span></span><br><span class="line">    <span class="keyword">while</span>(ip-&gt;type == T_SYMLINK)&#123;</span><br><span class="line">      <span class="comment">// Return failure if max recursive depth exceeded</span></span><br><span class="line">      <span class="keyword">if</span>(++depth == MAX_SYMLINK_DEPTH)&#123;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Else read new target path from current symlink inode</span></span><br><span class="line">      <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)path, <span class="number">0</span>, MAXPATH) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="comment">// Check if target is valid</span></span><br><span class="line">      <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// target not exist</span></span><br><span class="line">      &#125;</span><br><span class="line">      ilock(ip);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>终于写完大部分的6.s081，从4月份开始写，一直拖到现在，才填完坑。羞愧。中间一个月去复习软考了。</p>
<p>本身自己是非科班跨考408的，对于操作系统还有计算机组成都只停留在背诵还有做题阶段。对原理却是什么都不知道。</p>
<p>当第一次写第一个作业的时候，我连如何使用ide来辅助编写代码都不会。文件是make文件，我之前之后使用集成IDE来进行一键编译调试，但是第一次我都不知道如何进行调试代码，看着视频里的教授使用gdb调试代码。我都不知道这到底是怎么实现的。</p>
<p>我只好从网上搜索vscode调试6.s081.但是大多数人都知识给了一个一个task还有一个launch.json没有解释是为什么可以调试成功。然后直接复制粘贴进行运行，按住f5来进行调试，再加上前面的题目我几乎都没有自己思考的过程，于是5月份我就准备软考，没有接着写了。</p>
<p>6月份，考完之后，我有重新开始把这之前了题目在做一遍。同时，我具体进行了研究一下，vscode的两个json文件到底是干什么。首先第一个task，顾名思义就是你自己想要进行的任务操作，例如编译就可以是gcc a.c -o a.out直接进行简化，相当于配置好了手动输入的麻烦。接下来的launch.json才是重点</p>
<p>，我们可以设置gdb来进行调试，调试的文件是kernel（因为操作系统最开始初始化的文件就是kernel，首先进行内存加载</p>
<p>，之后设置远程调用gdb，这个是作业里面教授设置的，然后就可以按住f5来进行调试。相当于真正的启动程序。注意还需要我们手动输入make qemu-gdb在命令行。这个任务正好可以被我之前讲解的task来解决，我们只要在task新加一个任务输入 make就行。到这里才真正明白是如何进行调试gdb的。</p>
<p>之后差不多到了那种全忘了的境界，然后去上考场，重新写入题目，可能也是因为软考也复习了一下操作系统吧，做起题目来，比之前好多了，之前没有理解的视频也逐渐就豁然开朗的感觉，重新做会题目前4个，就感觉很快。后面的文件部分，就做的比较慢一点，可能是当初也没复习好文件。</p>
<p>总的来说xv6这个操作系统还是让我对内，存加载，页表操作，陷入内核态，进程切换，这些概念有实打实的认识。不想之前学408只知道什么调度算法，什么直接相连，全相连这种概念性的东西对整个操作系统如何启动，如何使用系统调用，程序如何中断，为什么要换页，出现page falut，还有如何进行线程切换都有了一个打字的了解，可能果断时间就会网络吧。所以记录一下。</p>
<p>最后感谢，网络上这些大佬的题解，不然，我几乎就就有可能放弃了，有些 题目都是参考大佬的题解才实现的。</p>
<p><a target="_blank" rel="noopener" href="https://blog.rayzhang.top/">Ray’s Blog - Welcome to my space btw~ (rayzhang.top)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/wan2njupt/posts">(54 封私信 &#x2F; 81 条消息) 士全 - 知乎 (zhihu.com)</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://yoursite.com">weijia</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2023/04/06/mitos/">http://yoursite.com/2023/04/06/mitos/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/%E5%85%AC%E5%BC%80%E8%AF%BE/">公开课</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/12/%E5%AF%B9%E6%8A%97%E6%97%A0%E8%81%8A/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">对抗无聊</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%B0%8F%E7%BB%93/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">深度学习代码小结</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">weijia</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">92</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#6-S081"><span class="toc-number">1.</span> <span class="toc-text">6.S081</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E9%A2%84%E5%A4%87%E7%8E%AF%E8%8A%82"><span class="toc-number">1.1.</span> <span class="toc-text">0.预备环节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1%E5%AE%89%E8%A3%85linux"><span class="toc-number">1.1.1.</span> <span class="toc-text">0.1安装linux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-2%E5%AE%89%E8%A3%85vscode"><span class="toc-number">1.1.2.</span> <span class="toc-text">0.2安装vscode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-lab-util"><span class="toc-number">1.2.</span> <span class="toc-text">1.lab util</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.1进程和内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-I-x2F-O%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2 I&#x2F;O和文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%AE%A1%E9%81%93"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.3 管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">1.4 文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%E5%AE%9E%E9%AA%8C"><span class="toc-number">1.2.5.</span> <span class="toc-text">1.5实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1boot"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">1.5.1boot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2sleep-easy"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">1.5.2sleep (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3pingpong-easy"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">1.5.3pingpong (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-4primes-moderate-x2F-hard"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">1.5.4primes (moderate)&#x2F;(hard)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#write-a-concurrent-version-of-prime-sieve-using-pipes-This-idea-is-due-to-Doug-McIlroy-inventor-of-Unix-pipes-The-picture-halfway-down-this-page-and-the-surrounding-text-explain-how-to-do-it-Your-solution-should-be-in-the-file-user-primes-c"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user&#x2F;primes.c.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-5find-moderate"><span class="toc-number">1.2.5.6.</span> <span class="toc-text">1.5.5find (moderate)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-lab-syscall"><span class="toc-number">1.3.</span> <span class="toc-text">2.lab syscall</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E7%94%A8%E6%88%B7%E6%80%81%EF%BC%8C%E6%A0%B8%E5%BF%83%E6%80%81%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.2用户态，核心态，以及系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E5%86%85%E6%A0%B8%E7%BB%84%E7%BB%87"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.3内核组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.4进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E5%AE%9E%E9%AA%8C"><span class="toc-number">1.3.4.</span> <span class="toc-text">2.5实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1System-call-tracing-moderate"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">2.5.1System call tracing (moderate)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-lab-pgtble"><span class="toc-number">1.4.</span> <span class="toc-text">3.lab pgtble</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">3.1基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%8A%A0%E9%80%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">3.2实现系统调用的加速</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E6%B1%82%E5%92%8C%E6%8F%90%E7%A4%BA"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">要求和提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E5%AE%9E%E7%8E%B0%E9%A1%B5%E8%A1%A8%E6%89%93%E5%8D%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.3实现页表打印</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E6%B1%82%E5%92%8C%E6%8F%90%E7%A4%BA-1"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">要求和提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E6%9F%A5%E8%AF%A2%E5%86%85%E5%AD%98%E9%A1%B5%E8%AE%BF%E9%97%AE%E6%83%85%E5%86%B5"><span class="toc-number">1.4.4.</span> <span class="toc-text">3.4查询内存页访问情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E6%B1%82%E5%92%8C%E6%8F%90%E7%A4%BA-2"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">要求和提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.5.</span> <span class="toc-text">3.5总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-lab-trap"><span class="toc-number">1.5.</span> <span class="toc-text">4.lab trap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C"><span class="toc-number">1.5.1.</span> <span class="toc-text">实验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E5%9B%9E%E7%AD%94%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.1回答问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E6%89%93%E5%8D%B0"><span class="toc-number">1.5.3.</span> <span class="toc-text">4.2函数调用栈打印</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E6%B1%82%E5%92%8C%E6%8F%90%E7%A4%BA-3"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">要求和提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">4.3实现定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E6%B1%82%E5%92%8C%E6%8F%90%E7%A4%BA-4"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">要求和提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.5.</span> <span class="toc-text">4.4总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-cow"><span class="toc-number">1.6.</span> <span class="toc-text">5.cow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E5%AE%9E%E7%8E%B0-COW-%E4%B8%8B%E7%9A%84-fork"><span class="toc-number">1.6.1.</span> <span class="toc-text">5.1实现 COW 下的 fork</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E6%B1%82%E5%92%8C%E6%8F%90%E7%A4%BA-5"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">要求和提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-1"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">题解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-thread"><span class="toc-number">1.7.</span> <span class="toc-text">6.thread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">1.7.1.</span> <span class="toc-text">用户线程切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E6%B1%82%E5%92%8C%E6%8F%90%E7%A4%BA-6"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">要求和提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-2"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">1.7.2.</span> <span class="toc-text">多线程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E6%B1%82%E5%92%8C%E6%8F%90%E7%A4%BA-7"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">要求和提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-3"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C"><span class="toc-number">1.7.3.</span> <span class="toc-text">实现同步屏障</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E6%B1%82%E5%92%8C%E6%8F%90%E7%A4%BA-8"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">要求和提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.7.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-lock"><span class="toc-number">1.8.</span> <span class="toc-text">7.lock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E5%8A%A0%E9%80%9F"><span class="toc-number">1.8.1.</span> <span class="toc-text">内存分配器加速</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E6%B1%82%E5%92%8C%E6%8F%90%E7%A4%BA-9"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">要求和提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-4"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98%E5%8A%A0%E9%80%9F"><span class="toc-number">1.8.2.</span> <span class="toc-text">磁盘缓存加速</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E6%B1%82%E5%92%8C%E6%8F%90%E7%A4%BA-10"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">要求和提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-5"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.8.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-fs"><span class="toc-number">1.9.</span> <span class="toc-text">8.fs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.1.</span> <span class="toc-text">大文件实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E6%B1%82%E5%92%8C%E6%8F%90%E7%A4%BA-11"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">要求和提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-6"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">题解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.2.</span> <span class="toc-text">符号链接实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E6%B1%82%E5%92%8C%E6%8F%90%E7%A4%BA-12"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">要求和提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3-7"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">1.10.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/10/sovits%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/" title="sovits训练教程"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="sovits训练教程"/></a><div class="content"><a class="title" href="/2023/07/10/sovits%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/" title="sovits训练教程">sovits训练教程</a><time datetime="2023-07-10T03:06:38.000Z" title="Created 2023-07-10 11:06:38">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/09/cs144%E5%AE%9E%E9%AA%8C/" title="cs144实验"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cs144实验"/></a><div class="content"><a class="title" href="/2023/07/09/cs144%E5%AE%9E%E9%AA%8C/" title="cs144实验">cs144实验</a><time datetime="2023-07-09T03:48:37.000Z" title="Created 2023-07-09 11:48:37">2023-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/09/warp%E9%85%8D%E7%BD%AEclash/" title="warp配置clash"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="warp配置clash"/></a><div class="content"><a class="title" href="/2023/07/09/warp%E9%85%8D%E7%BD%AEclash/" title="warp配置clash">warp配置clash</a><time datetime="2023-07-09T03:11:38.000Z" title="Created 2023-07-09 11:11:38">2023-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/14/mmseg%E4%BB%A3%E7%A0%81%E8%AF%BE/" title="mmseg代码课"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mmseg代码课"/></a><div class="content"><a class="title" href="/2023/06/14/mmseg%E4%BB%A3%E7%A0%81%E8%AF%BE/" title="mmseg代码课">mmseg代码课</a><time datetime="2023-06-14T07:45:40.000Z" title="Created 2023-06-14 15:45:40">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/10/mmdet%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/" title="mmdet代码实战"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mmdet代码实战"/></a><div class="content"><a class="title" href="/2023/06/10/mmdet%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/" title="mmdet代码实战">mmdet代码实战</a><time datetime="2023-06-10T09:01:45.000Z" title="Created 2023-06-10 17:01:45">2023-06-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By weijia</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>