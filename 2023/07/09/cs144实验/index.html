<!DOCTYPE html><html data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>cs144实验 | Hexo</title><meta name="keywords" content="cs144,计算机网络"><meta name="author" content="weijia"><meta name="copyright" content="weijia"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="lab0 ：warm up第0张就是温习一下网络的相关知识。 1 Set up GNU&#x2F;Linux配置环境就直接跳过了，按照官方教程就行 2 Networking by hand12345$ telnet cs144.keithw.org httpGET &#x2F;hello HTTP&#x2F;1.1Host: cs144.keithw.orgConnection: close  终端输入上述代码 新建">
<meta property="og:type" content="article">
<meta property="og:title" content="cs144实验">
<meta property="og:url" content="http://yoursite.com/2023/07/09/cs144%E5%AE%9E%E9%AA%8C/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="lab0 ：warm up第0张就是温习一下网络的相关知识。 1 Set up GNU&#x2F;Linux配置环境就直接跳过了，按照官方教程就行 2 Networking by hand12345$ telnet cs144.keithw.org httpGET &#x2F;hello HTTP&#x2F;1.1Host: cs144.keithw.orgConnection: close  终端输入上述代码 新建">
<meta property="og:locale">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-07-09T03:48:37.000Z">
<meta property="article:modified_time" content="2023-07-10T08:23:38.264Z">
<meta property="article:author" content="weijia">
<meta property="article:tag" content="cs144">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2023/07/09/cs144%E5%AE%9E%E9%AA%8C/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'cs144实验',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-10 16:23:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">92</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">cs144实验</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-07-09T03:48:37.000Z" title="Created 2023-07-09 11:48:37">2023-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-07-10T08:23:38.264Z" title="Updated 2023-07-10 16:23:38">2023-07-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="cs144实验"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="lab0-：warm-up"><a href="#lab0-：warm-up" class="headerlink" title="lab0 ：warm up"></a>lab0 ：warm up</h1><p>第0张就是温习一下网络的相关知识。</p>
<h2 id="1-Set-up-GNU-x2F-Linux"><a href="#1-Set-up-GNU-x2F-Linux" class="headerlink" title="1 Set up GNU&#x2F;Linux"></a>1 Set up GNU&#x2F;Linux</h2><p>配置环境就直接跳过了，按照官方教程就行</p>
<h2 id="2-Networking-by-hand"><a href="#2-Networking-by-hand" class="headerlink" title="2 Networking by hand"></a>2 Networking by hand</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ telnet cs144.keithw.org http</span><br><span class="line">GET /hello HTTP/1.1</span><br><span class="line">Host: cs144.keithw.org</span><br><span class="line">Connection: close</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>终端输入上述代码</p>
<p>新建一个会话进行观察</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ netcat -v -l -n -p 9090</span><br><span class="line">$ telnet localhost 9090</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="3-Writing-webget"><a href="#3-Writing-webget" class="headerlink" title="3 Writing webget"></a>3 Writing webget</h2><p>思路<br>实现 apps&#x2F;webget.cc 中的 get_URL().<br>实现思路基本按照实验指导的提示和代码注释, 建立连接后发送 HTTP 请求报文. 然后打印回复报文的内容. 由于回复报文可能不止一个, 因此需要通过检查 EOF 标志位来判断是否接收完毕.</p>
<p>​<br>    void get_URL(const string &amp;host, const string &amp;path) {<br>        &#x2F;&#x2F; Your code here.&#x2F;&#x2F; You will need to connect to the “http” service on<br>    &#x2F;&#x2F; the computer whose name is in the “host” string,<br>    &#x2F;&#x2F; then request the URL path given in the “path” string.</p>
<pre><code>// Then you&#39;ll need to print out everything the server sends back,
// (not just one call to read() -- everything) until you reach
// the &quot;eof&quot; (end of file).

// 直接参照tcp socks的api来哦发请求,使用address,还有
TCPSocket socks&#123;&#125;;
socks.connect(Address(host,&quot;http&quot;));
// 发送api
socks.write(&quot;GET &quot;+path+&quot; HTTP/1.1\r\nHost: &quot;+host+&quot;\r\n\r\n&quot;);
socks.shutdown(SHUT_WR);
while(!socks.eof())&#123;
    cout&lt;&lt;socks.read();
&#125;
// 关闭管道
socks.close();
cerr &lt;&lt; &quot;Function called: get_URL(&quot; &lt;&lt; host &lt;&lt; &quot;, &quot; &lt;&lt; path &lt;&lt; &quot;).\n&quot;;
cerr &lt;&lt; &quot;Warning: get_URL() has not been implemented yet.\n&quot;;
</code></pre>
<p>}</p>
<h2 id="4-in-memory-reliable-byte-stream"><a href="#4-in-memory-reliable-byte-stream" class="headerlink" title="4.in-memory reliable byte stream"></a>4.in-memory reliable byte stream</h2><p>任务二要求我们实现一个内存内的有序可靠字节流：</p>
<ul>
<li><p>字节流可以从写入端写入，并以相同的顺序，从读取端读取</p>
</li>
<li><p>字节流是有限的，写者可以终止写入。而读者可以在读取到字节流末尾时，不再读取。</p>
</li>
<li><p>字节流支持流量控制，以控制内存的使用。当所使用的缓冲区爆满时，将禁止写入操作。</p>
</li>
<li><p>写入的字节流可能会很长，必须考虑到字节流大于缓冲区大小的情况。即便缓冲区只有1字节大小，所实现的程序也必须支持正常的写入读取操作。</p>
</li>
<li><p>在单线程环境下执行，无需考虑多线程生产者-消费者模型下各类条件竞争问题。</p>
</li>
</ul>
<p><img src="https://kiprey.github.io/2021/11/cs144-lab1/image-20211105142904316.png" alt="image-20211105142904316"></p>
<p>参照这张图，我们现在要实现的是bytestream，他的主要功能就是从队头取文件，队尾放文件。符合这个的数据结构是双端队列，dequeue。因此我们需要加入这个数据结构</p>
<p>下面，我们来看他需要实现的方法，还需要那些额外变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! Construct a stream with room for `capacity` bytes.</span></span><br><span class="line">    <span class="built_in">ByteStream</span>(<span class="type">const</span> <span class="type">size_t</span> capacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name &quot;Input&quot; interface for the writer</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Write a string of bytes into the stream. Write as many</span></span><br><span class="line">    <span class="comment">//! as will fit, and return how many were written.</span></span><br><span class="line">    <span class="comment">//! \returns the number of bytes accepted into the stream</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string &amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns the number of additional bytes that the stream has space for</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">remaining_capacity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Signal that the byte stream has reached its ending</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">end_input</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Indicate that the stream suffered an error.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_error</span><span class="params">()</span> </span>&#123; _error = <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name &quot;Output&quot; interface for the reader</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Peek at next &quot;len&quot; bytes of the stream</span></span><br><span class="line">    <span class="comment">//! \returns a string</span></span><br><span class="line">    <span class="function">std::string <span class="title">peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Remove bytes from the buffer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span></span><br><span class="line">    <span class="comment">//! \returns a string</span></span><br><span class="line">    <span class="function">std::string <span class="title">read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns `true` if the stream input has ended</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">input_ended</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns `true` if the stream has suffered an error</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">error</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _error; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns the maximum amount that can currently be read from the stream</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns `true` if the buffer is empty</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">buffer_empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns `true` if the output has reached the ending</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eof</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name General accounting</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Total number of bytes written</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">bytes_written</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Total number of bytes popped</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">bytes_read</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们发现，bool还有size_t是需要进行返回的函数，因此加入 <strong>bool is_eof; size_t _capacity; size_t _written_size; size_t _read_size;</strong> 最后我们还要加上上面推理得到的数据结构双端队列deque <strong>deque<char> _output;</char></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint: This doesn&#x27;t need to be a sophisticated data structure at</span></span><br><span class="line">    <span class="comment">// all, but if any of your tests are taking longer than a second,</span></span><br><span class="line">    <span class="comment">// that&#x27;s a sign that you probably want to keep exploring</span></span><br><span class="line">    <span class="comment">// different approaches.</span></span><br><span class="line">    <span class="type">size_t</span> _capacity;</span><br><span class="line">    <span class="type">bool</span> is_eof;</span><br><span class="line">    <span class="type">size_t</span> _written_size;<span class="comment">//当前已经写入了的</span></span><br><span class="line">    <span class="type">size_t</span> _read_size;<span class="comment">//当前已经写入了的</span></span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">char</span>&gt; _output;</span><br><span class="line">    <span class="type">bool</span> _error&#123;&#125;;  <span class="comment">//!&lt; Flag indicating that the stream suffered an error.</span></span><br></pre></td></tr></table></figure>



<p>首先是实现构造函数，把上面新加入的变量全部初始化</p>
<p><strong>ByteStream::ByteStream(const size_t capacity):  _capacity(capacity),is_eof(false),_written_size(0),_read_size(0),_output() {}</strong></p>
<p>接下来，我们把需要返回的，先进行返回</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123;is_eof=<span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> is_eof; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _output.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _output.<span class="built_in">size</span>()==<span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> is_eof&amp;&amp;_output.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _written_size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _read_size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _capacity-_output.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>结束输入就是设置标识符eof为结束</li>
<li>eof代表牌既不能输入，而且也不能读取，就是没有队列长度</li>
<li>剩余空间就是最先开始的长度-当前buffer占用的长度</li>
</ol>
<p>接下来我们就是实现，双端队列的write</p>
<p>size_t ByteStream::write(const string &amp;data) {</p>
<ol>
<li>我们首先需要判断，还能不能写，不能写就返回</li>
<li>之后进行判断，当前能写的长度和data的长度，哪一个少，我们王少的写，同时写入长度增加</li>
<li>最后返回写入了多少长度</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(data);</span></span><br><span class="line">    <span class="keyword">if</span> (is_eof)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> l1=data.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> l2=_capacity-_output.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> left =<span class="built_in">min</span>(l1,l2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;left;i++)&#123;</span><br><span class="line">        _written_size++;</span><br><span class="line">        _output.<span class="built_in">push_back</span>(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>下一个函数peek_out和队列的输出后汉书一样，输出队头元素</p>
<ol>
<li>判断最长能输出的长度</li>
<li>然后调用队列的输出pop，</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(len);</span></span><br><span class="line">    <span class="type">size_t</span> l1=_output.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> l2=len;</span><br><span class="line">    <span class="type">size_t</span> out_size=<span class="built_in">min</span>(l1,l2);</span><br><span class="line">    string s;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(_output.<span class="built_in">begin</span>(), _output.<span class="built_in">begin</span>() +out_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>下一个pop。和队列的pop一样，参照上面的，但是需要加入到已经读取了read_size</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void ByteStream::pop_output(const size_t len) &#123; </span><br><span class="line">    size_t l1=_written_size;</span><br><span class="line">    size_t l2=len;</span><br><span class="line">    size_t out_size=min(l1,l2);</span><br><span class="line">    // _written_size-=out_size;</span><br><span class="line">    _read_size+=out_size;</span><br><span class="line">    for(size_t i=0;i&lt;out_size;i++)&#123;</span><br><span class="line">        _output.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





<p>现在我们要实现read代码，他的思路就是调用peek，还有pop就行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be popped and returned</span></span><br><span class="line"><span class="comment">//! \returns a string</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    string data=<span class="keyword">this</span>-&gt;<span class="built_in">peek_output</span>(len);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">pop_output</span>(len);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>总体来说第一个还是比较简单的，我们按照这个图发现，byte_stream是最底层的模块，他的作用就是退工读写队列，明白他是双端队列就好办了</p>
<p><img src="https://kiprey.github.io/2021/11/cs144-lab1/image-20211105142904316.png" alt="image-20211105142904316"></p>
<p>明白了，这个，我们需要实现的就是write还有read功能，write写入到队尾，看剩余长度够不够，选择最小的进行写入。read也是选择最小的进行读取。思路和使用普通的队列差不多</p>
<h1 id="lab1-：StreamReassembler"><a href="#lab1-：StreamReassembler" class="headerlink" title="lab1 ：StreamReassembler"></a>lab1 ：StreamReassembler</h1><p>在我们所实现的流重组器中，有以下几种特性：</p>
<ul>
<li><p>接收子字符串。这些子字符串中包含了一串字节，以及该字符串在<strong>总的数据流</strong>中的<strong>第一个字节的索引</strong>。</p>
<p>流的每个字节都有自己唯一的索引，从零开始向上计数。</p>
</li>
<li><p>StreamReassembler 中存在一个 ByteStream 用于输出，当重组器知道了流的下一个字节，它就会将其写入至 ByteStream中。</p>
</li>
</ul>
<p>需要注意的是，传入的子串中：</p>
<ul>
<li><p>子串之间可能相互重复，存在重叠部分</p>
<blockquote>
<p>但假设重叠部分数据完全重复。</p>
<p>不存在某些 index 下的数据在某个子串中是一种数据，在另一个子串里又是另一种数据。</p>
</blockquote>
<blockquote>
<p>重叠部分的处理最为麻烦。</p>
</blockquote>
</li>
<li><p>可能会传一些已经被装配了的数据</p>
</li>
<li><p>如果 ByteStream 已满，则必须暂停装配，将未装配数据暂时保存起来</p>
</li>
</ul>
<p>除了上面的要求以外，容量 Capacity 需要严格限制：</p>
<p><img src="https://kiprey.github.io/2021/11/cs144-lab1/image-20211107124153476.png" alt="image-20211107124153476"></p>
<p>为了便于说明，将图中的<strong>绿色区域</strong>称为 ByteStream，将图中<strong>存放红色区域的内存范围（即 first unassembled - first unacceptable）</strong>称为 Unassembled_strs。</p>
<p>CS144 要求将 <strong>ByteStream + Unassembled_strs 的内存占用总和</strong>限制在 <strong>Reassember 中构造函数传入的 capacity 大小</strong>。因此我们在构造 Reassembler 时，需要既将传入的 capacity 参数设置为 <code>ByteStream</code>的缓冲区大小上限，也将其设置为<strong>first unassembled - first unacceptable</strong>的范围大小，以避免极端情况下的内存使用。</p>
<blockquote>
<p>思路：</p>
<ol>
<li><p>这一个的任务是要求我们实现重组机器reassemble</p>
</li>
<li><p>主要功能包括对收到的字符串进行排序，之后传入到之前的byte_stream写入到缓存里面</p>
</li>
<li><p>根据上面的图，我们可以确定，绿色的是已经排序好了的，是在byte_tream里面的</p>
</li>
<li><p>绿色的+红色的是capacity，我们目前能放入到assemble的只有红色的</p>
</li>
<li><p>我们确定还没有排好序的为next_index,最大读取的就是next_index+(capacity-byte_stream。size)</p>
</li>
<li><p>同时在红色地区可能有元素，就是没有排序，我们使用unordered_map&lt;int，char&gt;来进行记录，下表的值，例如rec[100]&#x3D;”c”这也是为了让byte_stream容易write</p>
</li>
</ol>
</blockquote>
<p><strong>因此我们需要</strong></p>
<p>根据上面的思路，我们来看api， <strong>void push_substring(const std::string &amp;data, const uint64_t index, const bool eof);</strong>  </p>
<ol>
<li>需要我们把data放入到index的位置，并且设置eof</li>
<li>首先根据上面的分析，最长能够到达的是next_index+(capacity-byte_stream。size)，如果大于等于，就说明超过了，直接return</li>
<li>接下来就是如果index+data.size()&lt;&#x3D;next_index+_output.remaining_capacity()&amp;&amp;eof表示写入完成，那么我们设置，stream_byte的is_eof为true</li>
<li>之后就是开始加载到reassemble的流程，和之前一样，data的前半部分可能已经被加载到重组器里面了，我们选择最大的开始，max(next_index,index),然后选择最小的长度，作为能放入到重组器的min（iondex+data.size，next_index+(capacity-byte_stream。size)，作为读取的开始，然后我们放入到rec作为缓冲   <strong>注意（rec可能当前索引i已经有值了，这时候直接跳过</strong></li>
</ol>
<p>上半部分代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// DUMMY_CODE(data, index, eof);</span></span><br><span class="line">    <span class="comment">// 首先进行检索,看当前的index是不是超过</span></span><br><span class="line">    <span class="keyword">if</span>(index&gt;=next_index+_output.<span class="built_in">remaining_capacity</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 直接结束,说明索引,已经超过剩下的buffer里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(eof&amp;&amp;index+data.<span class="built_in">size</span>()&lt;=next_index+_output.<span class="built_in">remaining_capacity</span>())&#123;</span><br><span class="line">        is_eof=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 代表写入结束,next+out是写入</span></span><br><span class="line">        <span class="comment">// output是之前那个byte</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index+data.<span class="built_in">size</span>()&gt;next_index)&#123;</span><br><span class="line">        <span class="comment">// 首先选最小的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i=(index &gt; next_index? index: next_index); i &lt; next_index+ _output.<span class="built_in">remaining_capacity</span>() &amp;&amp; i &lt; index + data.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* code */</span></span><br><span class="line">            <span class="comment">// 直接选择最小的,然后这是输入的</span></span><br><span class="line">            <span class="keyword">if</span> (rec.<span class="built_in">count</span>(i)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//set里面没有这个,进行加入data</span></span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">size</span>()&lt;=i)</span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/* code */</span></span><br><span class="line">                    <span class="function">string <span class="title">add</span><span class="params">(i,<span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">//                    s.reserve(2*i);</span></span><br><span class="line">                    s+=add;</span><br><span class="line"><span class="comment">//                    cout&lt;&lt;s.capacity();</span></span><br><span class="line">                    <span class="comment">//扩容</span></span><br><span class="line">                &#125;</span><br><span class="line">                s[i]=data[i-index];</span><br><span class="line">                <span class="comment">//直接写入</span></span><br><span class="line">                rec.<span class="built_in">insert</span>(i);</span><br><span class="line">                unassembled_bytes_++;</span><br><span class="line">                <span class="comment">//这是没有整理的,放入到字符串里面</span></span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在已经写完了的情况下，我们就是对rec进行重拍程字符串，丢到stream_byte来进行写入，遍历next_index，看当前是不是有索引值，悠久进行加入，然后同事，构造一个新的字符串，直到next_index没有值，我们就不在进行while。结束之后，如果有eof标志，也要进行设置byte_stream为写入完成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//写入结束,放入到output里面</span></span><br><span class="line">        <span class="type">size_t</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="type">size_t</span> back=next_index;</span><br><span class="line">        <span class="keyword">while</span> (rec.<span class="built_in">count</span>(next_index)&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* code */</span></span><br><span class="line">            n++;</span><br><span class="line">            rec.<span class="built_in">erase</span>(next_index);</span><br><span class="line">            next_index++;</span><br><span class="line">            unassembled_bytes_--;</span><br><span class="line">            <span class="comment">//这是已经写好了,然后进行减少</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        string x=s.<span class="built_in">substr</span>(back,n);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;x;</span></span><br><span class="line">        _output.<span class="built_in">write</span>(x);</span><br><span class="line">        <span class="comment">//写入这个单词</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is_eof &amp;&amp; <span class="built_in">empty</span>()) &#123;</span><br><span class="line">       _output.<span class="built_in">end_input</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>整体代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(data, index, eof);</span></span><br><span class="line">    <span class="comment">// 首先进行检索,看当前的index是不是超过</span></span><br><span class="line">    <span class="keyword">if</span>(index&gt;=next_index+_output.<span class="built_in">remaining_capacity</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 直接结束,说明索引,已经超过剩下的buffer里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(eof&amp;&amp;index+data.<span class="built_in">size</span>()&lt;=next_index+_output.<span class="built_in">remaining_capacity</span>())&#123;</span><br><span class="line">        is_eof=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 代表写入结束,next+out是写入</span></span><br><span class="line">        <span class="comment">// output是之前那个byte</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index+data.<span class="built_in">size</span>()&gt;next_index)&#123;</span><br><span class="line">        <span class="comment">// 首先选最小的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i=(index &gt; next_index? index: next_index); i &lt; next_index+ _output.<span class="built_in">remaining_capacity</span>() &amp;&amp; i &lt; index + data.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* code */</span></span><br><span class="line">            <span class="comment">// 直接选择最小的,然后这是输入的</span></span><br><span class="line">            <span class="keyword">if</span> (rec.<span class="built_in">count</span>(i)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//set里面没有这个,进行加入data</span></span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">size</span>()&lt;=i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* code */</span></span><br><span class="line">                    <span class="function">string <span class="title">add</span><span class="params">(i,<span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">//                    s.reserve(2*i);</span></span><br><span class="line">                    s+=add;</span><br><span class="line"><span class="comment">//                    cout&lt;&lt;s.capacity();</span></span><br><span class="line">                    <span class="comment">//扩容</span></span><br><span class="line">                &#125;</span><br><span class="line">                s[i]=data[i-index];</span><br><span class="line">                <span class="comment">//直接写入</span></span><br><span class="line">                rec.<span class="built_in">insert</span>(i);</span><br><span class="line">                unassembled_bytes_++;</span><br><span class="line">                <span class="comment">//这是没有整理的,放入到字符串里面</span></span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//写入结束,放入到output里面</span></span><br><span class="line">        <span class="type">size_t</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="type">size_t</span> back=next_index;</span><br><span class="line">        <span class="keyword">while</span> (rec.<span class="built_in">count</span>(next_index)&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* code */</span></span><br><span class="line">            n++;</span><br><span class="line">            rec.<span class="built_in">erase</span>(next_index);</span><br><span class="line">            next_index++;</span><br><span class="line">            unassembled_bytes_--;</span><br><span class="line">            <span class="comment">//这是已经写好了,然后进行减少</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        string x=s.<span class="built_in">substr</span>(back,n);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;x;</span></span><br><span class="line">        _output.<span class="built_in">write</span>(x);</span><br><span class="line">        <span class="comment">//写入这个单词</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is_eof &amp;&amp; <span class="built_in">empty</span>()) &#123;</span><br><span class="line">       _output.<span class="built_in">end_input</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的我们，直接返回所需要的元素就行。设置那个重组器构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">StreamReassembler::StreamReassembler(const size_t capacity) : next_index(0),rec(),s(capacity,&#x27;\0&#x27;),is_eof(false),unassembled_bytes_(0),_output(capacity), _capacity(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line">//! \details This function accepts a substring (aka a segment) of bytes,</span><br><span class="line">size_t StreamReassembler::unassembled_bytes() const &#123; return unassembled_bytes_; &#125;</span><br><span class="line"></span><br><span class="line">bool StreamReassembler::empty() const &#123; return unassembled_bytes_==0; &#125;</span><br></pre></td></tr></table></figure>





<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一个的作业，主要是处理充排气，我们都知道tcp接受的时候，可能会先收到后发来的tcp分段，乱序到达，需要进行排列之后才能写入，所以这一届的任务就是实现重拍器实现tcp发送的一个任务。主要的难点就是完全理解这张图</p>
<p><img src="https://kiprey.github.io/2021/11/cs144-lab1/image-20211107124153476.png" alt="image-20211107124153476"></p>
<p>知道这个容量是byte_stream+还没有重组的，然后使用数据结构map，记录每一个位置的索引值</p>
<h1 id="Lab-2-the-TCP-receiver"><a href="#Lab-2-the-TCP-receiver" class="headerlink" title="Lab 2: the TCP receiver"></a>Lab 2: the TCP receiver</h1><p>经典看不懂到底说的是什么</p>
<p>结合 Lab1 中实现的字节流重组器，可以发现，在数据的收发过程中存在几种序列号：</p>
<ul>
<li>序列号 <code>seqno</code>：32bit 无符号整数，从初始序列号 ISN 开始递增，SYN 和 FIN 各占一个编号，溢出之后从 0 开始接着数</li>
<li>绝对序列号 <code>absolute seqno</code>：64bit 无符号整数，从 0 开始递增，0 对应 ISN，不会溢出</li>
<li>字节流索引 <code>stream index</code>：64bit 无符号整数，从 0 开始递增，不考虑 SYN 报文段，所以 0 对应 ISN + 1，不会溢出</li>
</ul>
<p>假设 ISN 为 232−2232−2，待传输的数据为 <code>cat</code>，那么三种编号的关系如下表所示：</p>
<p><a target="_blank" rel="noopener" href="https://img2023.cnblogs.com/blog/2065884/202304/2065884-20230425145852558-156889302.png"><img src="https://img2023.cnblogs.com/blog/2065884/202304/2065884-20230425145852558-156889302.png" alt="img"></a></p>
<p>由于 <code>uint32_t</code> 的数值范围为 0∼232−10∼232−1，所以 <code>a</code> 对应的报文段序列号溢出，又从 0 开始计数了。</p>
<p>处于安全性考虑，以及避免与之前的 TCP 报文混淆，TCP 需要让每个 seqno 都不可被猜测到，并且降低重复的可能性。因此 TCP seqno 不会从 0 开始，而是从一个 32 位随机数起步（称为<strong>初始序列号 ISN</strong>）</p>
<p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16888898613871688889861341.png" alt="16888898613871688889861341.png"></p>
<p>思路：</p>
<blockquote>
<ol>
<li>首先实现序列号转绝对序列号，因为我们发送的是32位的seqno，但是接受之后，他会变成64位的，但是因为64位的位置更大，所以我们需要checkpoint，做为基准点，看他到底是哪一个</li>
<li>从64位转到32位，就容易点，根据上面的公式，进行移项，我们只需要abs+isn,强转到32位就行</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! Transform an &quot;absolute&quot; 64-bit sequence number (zero-indexed) into a WrappingInt32</span></span><br><span class="line"><span class="comment">//! \param n The input absolute 64-bit sequence number</span></span><br><span class="line"><span class="comment">//! \param isn The initial sequence number</span></span><br><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="type">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123; <span class="keyword">return</span> WrappingInt32&#123;isn + <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(n)&#125;; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint64_t unwrap(WrappingInt32 n, WrappingInt32 isn, uint64_t checkpoint) </span><br></pre></td></tr></table></figure>

<p>对于这个api，我们根据上面的分析是checkpoint是附近的值，来基于确认的我们知道（seqno之间的差距）一定等于abs之间的差距，所以我们可以先把chekpoint转到32来，计算他与n之间的差别，然后checkpoint与差值进行计算，因为是uint，所以一定大于0.如果小于0，需要加上2的32</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="type">uint64_t</span> checkpoint)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    DUMMY_CODE(n, isn, checkpoint);</span></span><br><span class="line"><span class="type">int32_t</span> min_step = n - <span class="built_in">wrap</span>(checkpoint, isn);</span><br><span class="line"><span class="comment">// 将步数加到checkpoint上</span></span><br><span class="line"><span class="type">int64_t</span> ret = checkpoint + min_step;</span><br><span class="line"><span class="comment">// 如果反着走的话要加2^32</span></span><br><span class="line"><span class="keyword">return</span> ret &gt;= <span class="number">0</span> ? <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(ret) : ret + (<span class="number">1ul</span> &lt;&lt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="TCPReceiver-实现"><a href="#TCPReceiver-实现" class="headerlink" title="TCPReceiver 实现"></a>TCPReceiver 实现<img src="https://img2023.cnblogs.com/blog/2065884/202304/2065884-20230425160212576-1281077767.png" alt="img"></h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>需要实现一些类成员函数</p>
<ul>
<li><p><code>segment_received()</code>: 该函数将会在每次获取到 TCP 报文时被调用。该函数需要完成：</p>
<ul>
<li><p>如果接收到了 SYN 包，则设置 ISN 编号。</p>
<p>注意：SYN 和 FIN 包<strong>仍然可以携带用户数据并一同传输</strong>。同时，<strong>同一个数据包下既可以设置 SYN 标志也可以设置 FIN 标志</strong>。</p>
</li>
<li><p>将获取到的数据传入流重组器，并在接收到 FIN 包时终止数据传输。</p>
</li>
</ul>
</li>
<li><p><code>ackno()</code>：返回接收方<strong>尚未获取到的第一个字节的字节索引</strong>。如果 ISN 暂未被设置，则返回空。</p>
</li>
<li><p><code>window_size()</code>：返回接收窗口的大小，即<strong>第一个未组装的字节索引</strong>和<strong>第一个不可接受的字节索引</strong>之间的长度。</p>
</li>
</ul>
<p>这是 CS144 对 TCP receiver 的期望执行流程：</p>
<p><img src="https://kiprey.github.io/2021/11/cs144-lab2/image-20211107122822566.png" alt="image-20211107122822566"></p>
<p>第三个我们可以直接返回，因为我们在重组器就知道，这个串口就是容量-byte_stream的长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPReceiver::window_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _capacity-_reassembler.<span class="built_in">stream_out</span>().<span class="built_in">buffer_size</span>(); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>然后我们看这个api，**void TCPReceiver::segment_received(const TCPSegment &amp;seg) **， 作用就是把收到的tcp片段，进行设置，如果我们自己没有syn，这个有，就设置他为isn,并且在把这个包传入到重组器里面。同时我们进行写入的是index，需要转换成64位（上文的unwarp），然后索引还需要-1，data是在seg的payload字段</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPReceiver::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这个题目的意识就是要求我们把这个seg代码来进行写入到我们的接收器里面</span></span><br><span class="line"><span class="comment">// 首先没有isn，就直接失败</span></span><br><span class="line">    <span class="keyword">if</span>(!_set_syn_flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!seg.<span class="built_in">header</span>().syn)<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 没有开头直接就是失败</span></span><br><span class="line">        _set_syn_flag=<span class="literal">true</span>;</span><br><span class="line">        _isn=seg.<span class="built_in">header</span>().seqno;</span><br><span class="line">        <span class="comment">// 序列化在头文件里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接下来我们就是来进行计算seq转化为绝对值，因为seq是32，所以需要我们上面的unwrap</span></span><br><span class="line">    <span class="comment">// 得到相对值checkpoint</span></span><br><span class="line">    <span class="type">uint64_t</span> checkpoint =_reassembler.<span class="built_in">stream_out</span>().<span class="built_in">bytes_written</span>()+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 已经写入了的，作为相对值，这个是在stream里面的，已经排好序的，可以作为相对值</span></span><br><span class="line">    <span class="type">uint64_t</span> convert_seq = <span class="built_in">unwrap</span>(seg.<span class="built_in">header</span>().seqno,_isn,checkpoint);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个知识相对值，我们的stream index</span></span><br><span class="line">    <span class="comment">// 要在上面进行减少1</span></span><br><span class="line">    <span class="keyword">auto</span> stream_index = convert_seq <span class="number">-1</span> +(seg.<span class="built_in">header</span>().syn);</span><br><span class="line">    <span class="comment">// 接下来是写入，调用之前的代码</span></span><br><span class="line">    _reassembler.<span class="built_in">push_substring</span>(seg.<span class="built_in">payload</span>().<span class="built_in">copy</span>(),stream_index,seg.<span class="built_in">header</span>().fin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我接下来，我们看 <strong>optional<WrappingInt32> TCPReceiver::ackno() const</WrappingInt32></strong>，这个作用就是返回ackno，代表，下一次可以接受的位置，就是上一个实验的next_index位置，那么我们只需要把64位，转成32位，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">optional&lt;WrappingInt32&gt; <span class="title">TCPReceiver::ackno</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//    返回ack</span></span><br><span class="line">    <span class="keyword">if</span>(!_set_syn_flag)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算下一个，就是相当于之前的next——index，只需要求出</span></span><br><span class="line">     <span class="type">uint64_t</span> abs_ack_no = _reassembler.<span class="built_in">stream_out</span>().<span class="built_in">bytes_written</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果当前处于 FIN_RECV 状态，则还需要加上 FIN 标志长度</span></span><br><span class="line">    <span class="keyword">if</span> (_reassembler.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>())</span><br><span class="line">        ++abs_ack_no;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">WrappingInt32</span>(_isn) + abs_ack_no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这一届的任务就是让我们知道接收器的作用。</p>
<ol>
<li>接受分段，设置isn，然后交给重拍器进行处理</li>
<li>返回ackno，下一个需要对方发来的序列号</li>
<li>计算串口，能容纳多少，为了拥塞控制</li>
</ol>
<h1 id="lab-3-：TCPSender-实现"><a href="#lab-3-：TCPSender-实现" class="headerlink" title="lab 3 ：TCPSender 实现"></a>lab 3 ：TCPSender 实现</h1><p><img src="https://kiprey.github.io/2021/11/cs144-lab1/image-20211105142904316.png" alt="image-20211105142904316"></p>
<p>我们已经实现了receiver部分，现在就是sende部分。</p>
<p>在该实验中，我们需要完成 TCPSender 的以下四个接口：</p>
<ul>
<li><p><strong>fill_window</strong>：TCPSender 从 ByteStream 中读取数据，并以 TCPSegement 的形式发送，尽可能地填充接收者的<strong>窗口</strong>。但每个TCP段的大小不得超过 <code>TCPConfig::MAX PAYLOAD SIZE</code>。</p>
<blockquote>
<p>若接收方的 Windows size 为 0，则发送方将按照接收方 window size 为 1 的情况进行处理，持续发包。</p>
<p>因为虽然此时发送方发送的数据包可能会被接收方拒绝，但接收方可以在反向发送 ack 包时，将自己最新的 window size 返回给发送者。否则若双方停止了通信，那么当接收方的 window size 变大后，发送方仍然无法得知接收方可接受的字节数量。</p>
<p>若远程没有 ack 这个在 window size 为 0 的情况下发送的一字节数据包，那么发送者重传时<strong>不要将 RTO 乘2</strong>。这是因为将 RTO 双倍的目的是为了避免网络拥堵，但此时的数据包丢弃并不是因为网络拥堵的问题，而是远程放不下了。</p>
</blockquote>
</li>
<li><p><strong>ack_received</strong>：对接收方返回的 ackno 和 window size 进行处理。丢弃那些<strong>已经完全确认但仍然处于追踪队列</strong>的数据包。同时如果 window size 仍然存在空闲，则继续发包。</p>
</li>
<li><p><strong>tick</strong>：该函数将会被调用以指示经过的时间长度。发送方可能需要重新发送一些超时且没有被确认的数据包。</p>
</li>
<li><p><strong>send_empty_segment</strong>：生成并发送一个<strong>在 seq 空间中长度为 0</strong> 并<strong>正确设置 seqno</strong> 的 TCPSegment，这可让用户发送一个空的 ACK 段。</p>
</li>
</ul>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>我们首先拿最简单的trick进行分析，**void TCPSender::tick(const size_t ms_since_last_tick)**，这个函数的作用就是传入时间来进行模拟时钟，如果景观这些时间超过了定时器规定的时间，就需要进行重新发送文件，同事重启定时器。</p>
<p>为了使用方便，我们自定义一个定时器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">uint32_t</span> _rto;          <span class="comment">// 超时时间</span></span><br><span class="line">    <span class="type">uint32_t</span> _remain_time;	<span class="comment">// 剩余时间</span></span><br><span class="line">    <span class="type">bool</span> _is_running;		<span class="comment">// 是否在运行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Timer</span>(<span class="type">uint32_t</span> rto);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动计时器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止计时器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否超时</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_time_out</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置过去了多少时间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">elapse</span><span class="params">(<span class="type">size_t</span> eplased)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时时间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_time_out</span><span class="params">(<span class="type">uint32_t</span> duration)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>剩余时间，规定的超时时间，还有是否开启的定时器，我们只需要一下几个函数，开启，关闭，是不是超时，设置rto时间，还有更新剩余时间。</p>
<p>对于trick这个函数，思路就是</p>
<ol>
<li>首先更新定时器剩余时间，如果没有超过，就直接return</li>
<li>如果超过，再看待确认队列是不是空的，是空的，就初始化为最开始的rto，然后返回</li>
<li>不是，就需要进行重传，重新放入到sender的发送队列，并且更新rto，加倍红船时间（timer的设置时间函数）</li>
<li>最后打开定时器</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123; </span><br><span class="line">    _timer.<span class="built_in">elapse</span>(ms_since_last_tick);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!_timer.<span class="built_in">is_time_out</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_outstand_segments.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> _timer.<span class="built_in">set_time_out</span>(_initial_retransmission_timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时需要重发第一个报文段，同时将超时时间翻倍</span></span><br><span class="line">    _segments_out.<span class="built_in">push</span>(_outstand_segments.<span class="built_in">front</span>().first);</span><br><span class="line">    <span class="keyword">if</span>(_window_size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">         _consecutive_retxs += <span class="number">1</span>;</span><br><span class="line">    _timer.<span class="built_in">set_time_out</span>(_initial_retransmission_timeout * (<span class="number">1</span> &lt;&lt; _consecutive_retxs));</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">    _timer.<span class="built_in">start</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





<p>接下来就是返回能直接返回的，我们设置重传变量，到时候直接返回</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">TCPSender::consecutive_retransmissions</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _outstand_bytes; &#125;</span><br></pre></td></tr></table></figure>

<p>返回没有被确认的字节数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">TCPSender::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _outstand_bytes; &#125;</span><br></pre></td></tr></table></figure>



<p>‘<img src="https://img2023.cnblogs.com/blog/2065884/202304/2065884-20230425140312132-987858718.png" alt="img"></p>
<p><img src="https://kiprey.github.io/2021/11/cs144-lab1/image-20211107124153476.png" alt="image-20211107124153476"></p>
<p>现在我们研究fill_windows这个函数，void TCPSender::fill_window()，函数的意识，就是让我们发送byte_stream里面的byte，这个就是发送代码。由于tcp是可靠传输，他有选择重传还有超时重传的机制，保证tcp发送seg能够被确认。因此这个ill_window的作用，就是进行发送seg。</p>
<p>整个作用就是</p>
<ol>
<li>发送最大的长度seg，加入到待确认队列里面</li>
<li>如果还没有设置syn表示，就自己先发一个syn包</li>
<li>最后，如果是byte——stream已经发送完了，而且窗口还有剩余的，那就发送fin停止包</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/b798399e091a4c02bb94f6a47d8f7ca3.png" alt="在这里插入图片描述"></p>
<p><strong>（注意）L:haishi需要按照上面这幅图来理解，ack代表已经进行确认的,next代表下一个序列号,那么我们最大能发送的max(_window_size, static_cast<uint16_t>(1)) + _ack_seq - _next_seqno</uint16_t></strong>,ack只是没有进行确认，next是还没有进行发送的，这和上面接受的重组器差不多，ackno相当于第一个没有阅读的，next和上面的next一样都是第一个没有使用的。</p>
<ol>
<li>如果当前还没有建立通信syn，而且等待队列也是空的，那么首先我发syn</li>
<li>如果不是，就首先计算，当前最大的剩余大小max(_window_size, static_cast<uint16_t>(1)) + _ack_seq - _next_seqno</uint16_t></li>
<li>然后计算byte_stream能够发送的最大值，之后，剩余减去最大值，一直while</li>
<li>去除data，构建seg（我们自己实现了一个新的发送seg方法</li>
<li>之后如果把byte发送完了，但是窗口还有剩余，我们就发送fin结束包</li>
</ol>
<blockquote>
<p>发送代码</p>
<ol>
<li>首先构造seg，之后进行设置他head，包括，syn，fin，还有序列号（这个直接用next——seqno）生成</li>
<li>放入到待确认的队列，更新待确认的byte的长度</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::send_segment</span><span class="params">(string &amp;&amp;data, <span class="type">bool</span> syn, <span class="type">bool</span> fin)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建报文段</span></span><br><span class="line">    TCPSegment segment;</span><br><span class="line">    segment.<span class="built_in">header</span>().syn = syn;</span><br><span class="line">    segment.<span class="built_in">header</span>().fin = fin;</span><br><span class="line">    segment.<span class="built_in">header</span>().seqno = <span class="built_in">next_seqno</span>();</span><br><span class="line">    segment.<span class="built_in">payload</span>() = std::<span class="built_in">move</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将报文段放到发送队列中</span></span><br><span class="line">    _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">    _outstand_segments.<span class="built_in">push</span>(&#123;segment, _next_seqno&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新序号</span></span><br><span class="line">    <span class="keyword">auto</span> len = segment.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">    _outstand_bytes += len;</span><br><span class="line">    _next_seqno += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>整体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!_is_syned) &#123;</span><br><span class="line">        <span class="comment">// 等待 SYN 超时</span></span><br><span class="line">        <span class="keyword">if</span> (!_outstand_segments.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送一个 SYN 包</span></span><br><span class="line">        <span class="built_in">send_segment</span>(<span class="string">&quot;&quot;</span>, <span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> remain_size = <span class="built_in">max</span>(_window_size, <span class="built_in">static_cast</span>&lt;<span class="type">uint16_t</span>&gt;(<span class="number">1</span>)) + _ack_seq - _next_seqno;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当缓冲区中有待发送数据时就发送数据报文段</span></span><br><span class="line">        <span class="keyword">while</span> (remain_size &gt; <span class="number">0</span> &amp;&amp; !_stream.<span class="built_in">buffer_empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ws = <span class="built_in">min</span>(<span class="built_in">min</span>(remain_size, TCPConfig::MAX_PAYLOAD_SIZE), _stream.<span class="built_in">buffer_size</span>());</span><br><span class="line">            remain_size -= ws;</span><br><span class="line"></span><br><span class="line">            string &amp;&amp;data = _stream.<span class="built_in">peek_output</span>(ws);</span><br><span class="line">            _stream.<span class="built_in">pop_output</span>(ws);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 置位 FIN</span></span><br><span class="line">            _is_fin |= (_stream.<span class="built_in">eof</span>() &amp;&amp; !_is_fin &amp;&amp; remain_size &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">send_segment</span>(std::<span class="built_in">move</span>(data), <span class="literal">false</span>, _is_fin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓冲区输入结束时发送 FIN（缓冲区为空时不会进入循环体，需要再次发送）</span></span><br><span class="line">        <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp; !_is_fin &amp;&amp; remain_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _is_fin = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">send_segment</span>(<span class="string">&quot;&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>这个代码就相当于是tcp里面的发送代码，建立绘画，并且把没有进行确认的seg放入到待确认的队列里面</p>
<hr>
<p>下面我们来看 <strong>void TCPSender::ack_received(const WrappingInt32 ackno, const uint16_t window_size)</strong> 这个api</p>
<p>他传入的是返回号ackno，还有更新发送窗口的大小。这个就相当于得到ack号来进行确认之前传的文件是不是已经收到</p>
<ol>
<li>如果当前ack号&lt;&#x3D;我自己的ackno，相当于返回的是没有，直接return</li>
<li>如果当前的ack，大于我要法的next_seqno，那也是没用</li>
<li>我们只要接受到ack号，就把拥塞控制回复到最开始，重传次数也变成0</li>
<li>之后就是累计确认</li>
<li>确认完成之后，我们再次进行发送使用fill_window</li>
<li>最后如果还有没有进行确认的，就需要我们进行使用打开计时器了</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="type">const</span> WrappingInt32 ackno, <span class="type">const</span> <span class="type">uint16_t</span> window_size)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ack_seq = <span class="built_in">unwrap</span>(ackno, _isn, _ack_seq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// absolute ackno 不能落在窗口外</span></span><br><span class="line">    <span class="keyword">if</span> (ack_seq &gt; _next_seqno)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    _window_size = window_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略已处理过的确认应答号</span></span><br><span class="line">    <span class="keyword">if</span> (ack_seq &lt;= _ack_seq)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    _ack_seq = ack_seq;</span><br><span class="line">    _is_syned = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置超时时间为初始值</span></span><br><span class="line">    _timer.<span class="built_in">set_time_out</span>(_initial_retransmission_timeout);</span><br><span class="line">    _consecutive_retxs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除已被确认的报文段</span></span><br><span class="line">    <span class="keyword">while</span> (!_outstand_segments.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;[segment, seqno] = _outstand_segments.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (seqno &gt;= ack_seq)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        _outstand_bytes -= segment.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">        _outstand_segments.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次填满发送窗口</span></span><br><span class="line">    <span class="built_in">fill_window</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还有没被确认的报文段就重启计时器</span></span><br><span class="line">    <span class="keyword">if</span> (!_outstand_segments.<span class="built_in">empty</span>())</span><br><span class="line">        _timer.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _timer.<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这一部分主要是为了完成，ack发送器的确认，确认成功之后，我就接着再次发送，相当于tcp的三次握手，首先，是建立syn，没有收到syn，那就是我来进行发送，之后获取到ack，那么我们就代表建立成功，更新syn为true，同事更新本地ack为接收到的ack，然后累计确认已近收到了的seg，最后收到确认之后，sender还是需要进行发送，调用fill—windows，最后来进行设置计时器打开与关闭</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这一届需要我们实现的是tcp的发送端，我们需要完成发送byte里面的字段，然后放入到待确认的队列里面，根据会传来的ackno来进行累计确认还有更新，相当于实现tcp的三次握手阶段，我们需要进行发送的文件方法，然后使用累计确认，来确保tcp完整的连接。</p>
<h1 id="lab4-tcp-connection"><a href="#lab4-tcp-connection" class="headerlink" title="lab4 tcp connection"></a>lab4 tcp connection</h1><p>投降了，这一个，直接抄的<a target="_blank" rel="noopener" href="https://kiprey.github.io/2021/11/cs144-lab4/">CS144计算机网络 Lab4 | Kiprey’s Blog</a>，完全看不懂到底在说什么，不知所云，边界测试条件也是一堆，放弃了</p>
<p>TCPConnection 需要将 TCPSender 和 TCPReceiver 结合，实现成一个 TCP 终端，同时收发数据。</p>
<p>TCPConnection 有几个规则需要遵守：</p>
<p>对于<strong>接收数据段</strong>而言：</p>
<ul>
<li><p>如果接收到的数据包设置了 RST 标志，则将输入输出字节流全部设置为 错误 状态，并永久关闭 TCP 连接。</p>
</li>
<li><p>如果没有收到 RST 标志，则将该数据包传达给 TCPReceiver 来处理，它将对数据包中的 seqno、SYN、payload、FIN 进行处理。</p>
</li>
<li><p>如果接收到的数据包中设置了 ACK 标志，则向<strong>当前 TCPConnection</strong> 中<strong>它自己的 TCPSender</strong> 告知远程终端的 ackno 和 window_size。</p>
<blockquote>
<p>这一步相当重要，因为数据包在网络中以乱序形式发送，因此远程发送给本地的 ackno 存在滞后性。</p>
<p>将远程的 ackno 和 window size 附加至发送数据中可以降低这种滞后性，提高 TCP 效率。</p>
</blockquote>
</li>
<li><p>如果接收到的 TCP 数据包包含了一个<strong>有效 seqno</strong>，则 TCPConnection 必须至少返回一个 TCP 包作为回复，以告知远程终端 此时的 ackno 和 window size。</p>
</li>
<li><p>如果接收到的 TCP 数据包<strong>包含的 seqno 是无效</strong>的，则 TCPConnection 也需要回复一个类似的无效数据包。这是因为远程终端可能会发送无效数据包以确认当前连接是否有效，同时查看此时接收方的 ackno 和 window size。这被称为 TCP 的 <code>keep-alive</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPYif (_receiver.ackno().has_value() &amp;&amp; seg.length_in_sequence_space() == 0 &amp;&amp; seg.header().seqno == _receiver.ackno().value() - 1) &#123;</span><br><span class="line">  _sender.send_empty_segment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>对于<strong>发送数据段</strong>来说：</p>
<ul>
<li>当 TCPSender 将一个 TCPSegment 数据包添加到待发送队列中时，TCPConnection 需要从中取出并将其发送。</li>
<li>在发送当前数据包之前，TCPConnection 会获取当前<strong>它自己的 TCPReceiver</strong> 的 ackno 和 window size，将其放置进待发送 TCPSegment 中，并设置其 ACK 标志。</li>
</ul>
<p>TCPConnection 需要检测时间的流逝。它存在一个 tick 函数，该函数将会被操作系统持续调用。当 TCPConnection 的 tick 函数被调用后，它需要</p>
<ul>
<li>告知 TCPSender 时间的流逝，这可能会让 TCPSender 重新发送被丢弃的数据包</li>
<li>如果连续重传次数超过 <code>TCPConfig::MAX RETX ATTEMPTS</code>，则发送一个 RST 包。</li>
<li>在条件适合的情况下关闭 TCP 连接（当处于 TCP 的 TIME_WAIT 状态时）。</li>
</ul>
<p>TCP 连接的关闭稍微麻烦一些，主要有以下几种情况需要考虑：</p>
<ul>
<li><p><strong>接收方收到 RST 标志或者发送方发送 RST 标志</strong>后，设置当前 TCPConnection 的输入输出字节流的状态为错误状态，并<strong>立即</strong>停止退出。这种属于暴力退出（unclear shutdown），可能会导致<strong>尚未传输完成的数据丢失</strong>（例如仍然在网络中运输的数据包在<strong>接收方收到RST标志后</strong>被丢弃）。</p>
</li>
<li><p>若想让双方都在数据流收发完整后退出（clear shutdonw），则情况略微麻烦一点。先上张四次挥手的图：</p>
<p><img src="https://kiprey.github.io/2021/11/cs144-lab4/image-20210515092825158.png" alt="img"></p>
<p>简单讲下挥手的流程：</p>
<ul>
<li><p>当<strong>客户端</strong>的数据全部发送完成，则将会发送 FIN 包以告知服务器 <strong>客户端数据全部发送完成</strong>（发送完成，不等于<strong>被接收完成</strong>）。但请注意，此时的服务器仍然可以发送数据至客户端。</p>
</li>
<li><p>当服务器对 客户端的 FIN 进行 ack 后，则说明<strong>服务器确认接收客户端的全部数据</strong>。</p>
</li>
<li><p>服务器继续发送数据，直到服务器的数据已经全部发送完成，则向客户端发送 FIN 包以告知<strong>服务端数据全部发送完成</strong>。</p>
</li>
<li><p>当客户端对服务端的 FIN <strong>发送</strong> ack 后，则说明<strong>客户端确认接收服务端的全部数据</strong>。注意，此时客户端可以确认：</p>
<ul>
<li><strong>服务端</strong>成功接收<strong>客户端</strong>全部数据</li>
<li><strong>客户端</strong>成功接收<strong>服务端</strong>的全部数据</li>
</ul>
<p>此时客户端可以百分百相信，<strong>此时断开连接对客户端是没有任何危害的</strong>。</p>
<p>但是！当服务器没接收到 客户端的 ACK 时，</p>
<ul>
<li>服务器可以确认它成功接收客户端全部数据</li>
<li>服务器<strong>不知道客户端是否成功接收服务端的全部数据</strong></li>
</ul>
<p>也就是说，服务器一定要获得到客户端的 ACK 才能关闭。</p>
<p>若服务器在超时时间内没获得到客户端的 FIN ACK，则会重发 FIN 包。但假如此时客户端已经断连，那么服务器将<strong>永远无法获取到客户端的 FIN ACK</strong>。因此即便客户端已经完成了它的所有任务，它仍然需要等待服务器端一小段时间，以便于处理服务端的 FIN 包。</p>
<p>当服务器获取到了客户端的 FIN_ACK 后，它就直接关闭连接。而客户端也会在超时后静默关闭。此时双方均成功获取对方的全部数据，没有造成任何危害。</p>
<blockquote>
<p>这里有个很重要的点是，<strong>TCP 不会对 ACK 包来进行 ACK</strong>。例如服务端不会对客户端发来的 FIN_ACK</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>常见的返回值，直接调用receiver或者sender得到，或者自己加入这个值</p>
<p>[<a target="_blank" rel="noopener" href="https://blog.csdn.net/LostUnravel/article/details/124870729">CS144] Lab 4: The TCP connection_cs144 lab4 tcpconnection实现笔记_PeakCrosser的博客-CSDN博客</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">unassembled_bytes</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _time_since_last_segment_received; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _active; &#125;</span><br></pre></td></tr></table></figure>



<p>首先还是先用trick函数来实现，void TCPConnection::tick(const size_t ms_since_last_tick) ，这个传入的是时间，我们需要用这个歌时间，进行更新sender的trick，还有更新，上次接受到的时间片段。如果经过这个sender的trick，定时器重传次数超时了，我们就需要关闭这个连接，使用rst的方式关闭连接。如果是正常关闭，那就设置active为false就行，然后发送segment</p>
<blockquote>
<p>对于<strong>发送数据段</strong>来说：</p>
<ul>
<li>当 TCPSender 将一个 TCPSegment 数据包添加到待发送队列中时，TCPConnection 需要从中取出并将其发送。</li>
<li>在发送当前数据包之前，TCPConnection 会获取当前<strong>它自己的 TCPReceiver</strong> 的 ackno 和 window size，将其放置进待发送 TCPSegment 中，并设置其 ACK 标志。</li>
</ul>
</blockquote>
<p>参照上面的思路，我们需要做的就是，从sender里面的发送队列选择seg，然后，加入ackno，来作为发送的标识（这个是receiver）里面进行得到，最后就是设置窗口大小，然后放入到connection的发送队列里面</p>
<p><strong>主要功能就是从sender取值，然后装配ack，之后放入到connection的</strong></p>
<ol>
<li>sender获取seg</li>
<li>receiver获取ackno进行装配</li>
<li>放入到connection得到发送队列里面</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::send_segments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment segment = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        optional&lt;WrappingInt32&gt; ackno = _receiver.<span class="built_in">ackno</span>();</span><br><span class="line">        <span class="comment">// if TCP does not receive SYN segments from the remote peer, i.e. at SYN_SENT state</span></span><br><span class="line">        <span class="comment">// TCP will not set ACK flag and seqno</span></span><br><span class="line">        <span class="keyword">if</span> (ackno.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            segment.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            segment.<span class="built_in">header</span>().ackno = ackno.<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set the local receiver&#x27;s window size</span></span><br><span class="line">        segment.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>() &lt;= numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>()</span><br><span class="line">                                   ? _receiver.<span class="built_in">window_size</span>()</span><br><span class="line">                                   : numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        _segments_out.<span class="built_in">emplace</span>(segment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>下面实现connect这个，这个代码只会在刚开始建立连接的时候才是用，我们的作用就是发送数据到sender，然后connection从sender进行取值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>write()</code> 方法</p>
<p>该方法即上层应用向 TCP 的字节流中写入数据进行发送.写数据</p>
<p>调用sender的byte进行写入数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_active) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> ret = _sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<blockquote>
<p>对于<strong>接收数据段</strong>而言：</p>
<ul>
<li><p>如果接收到的数据包设置了 RST 标志，则将输入输出字节流全部设置为 错误 状态，并永久关闭 TCP 连接。</p>
</li>
<li><p>如果没有收到 RST 标志，则将该数据包传达给 TCPReceiver 来处理，它将对数据包中的 seqno、SYN、payload、FIN 进行处理。</p>
</li>
<li><p>如果接收到的数据包中设置了 ACK 标志，则向<strong>当前 TCPConnection</strong> 中<strong>它自己的 TCPSender</strong> 告知远程终端的 ackno 和 window_size。</p>
<blockquote>
<p>这一步相当重要，因为数据包在网络中以乱序形式发送，因此远程发送给本地的 ackno 存在滞后性。</p>
<p>将远程的 ackno 和 window size 附加至发送数据中可以降低这种滞后性，提高 TCP 效率。</p>
</blockquote>
</li>
<li><p>如果接收到的 TCP 数据包包含了一个<strong>有效 seqno</strong>，则 TCPConnection 必须至少返回一个 TCP 包作为回复，以告知远程终端 此时的 ackno 和 window size。</p>
</li>
<li><p>如果接收到的 TCP 数据包<strong>包含的 seqno 是无效</strong>的，则 TCPConnection 也需要回复一个类似的无效数据包。这是因为远程终端可能会发送无效数据包以确认当前连接是否有效，同时查看此时接收方的 ackno 和 window size。这被称为 TCP 的 <code>keep-alive</code>。</p>
</li>
</ul>
</blockquote>
<p>那句上面的介绍，我们知道connection的接送流程是什么。</p>
<ol>
<li>判断是不是rst，是就设置rxt，然后直接非正常关闭</li>
<li>不是就交给receiver处理，使用receiver的segment-receiver（得到index，还有数据交给重组器进行处理）</li>
<li>同事这个接受端如果设置ack，就要交给sender进行处理，这样构成tcp可靠传输，更新窗口</li>
<li>同时接收到欧晓的seqno，就需要我们进行返回我们的窗口大小</li>
<li>如果无效，发送一个空的seg</li>
</ol>
<p><code>end_input_stream()</code> 方法</p>
<p>该方法即结束需要发送的数据流, 即出站流. 因此需要调用 <code>_sender.steam_in().end_input()</code> 方法. 而结束流的隐含信息是要<strong>发送一个 FIN 报文段</strong>,</p>
<p>sender的作用就是进行发送byte—stream的数据，所以我们首先进行设置byte-stream为结束状态，然后调用这个fill，进行发送fin挥手包，最后还是需要发送到connection的</p>
<p>（只要使用fill-windows，就一定要进行发送到connection</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    _time_since_last_segment_received_ms = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果发来的是一个 ACK 包，则无需发送 ACK</span></span><br><span class="line">    <span class="type">bool</span> need_send_ack = seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line"><span class="comment">// 读取并处理接收到的数据</span></span><br><span class="line"><span class="comment">// _receiver 足够鲁棒以至于无需进行任何过滤</span></span><br><span class="line">_receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是 RST 包，则直接终止</span></span><br><span class="line"><span class="comment">//! <span class="doctag">NOTE:</span> 当 TCP 处于任何状态时，均需绝对接受 RST。因为这可以防止尚未到来数据包产生的影响</span></span><br><span class="line"><span class="keyword">if</span> (seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">    _set_rst_state(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果收到了 ACK 包，则更新 _sender 的状态并补充发送数据</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> _sender 足够鲁棒以至于无需关注传入 ack 是否可靠</span></span><br><span class="line"><span class="built_in">assert</span>(_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>());</span><br><span class="line"><span class="keyword">if</span> (seg.<span class="built_in">header</span>().ack) &#123;</span><br><span class="line">    _sender.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win);</span><br><span class="line">    <span class="comment">// _sender.fill_window(); // 这行其实是多余的，因为已经在 ack_received 中被调用了，不过这里显示说明一下其操作</span></span><br><span class="line">    <span class="comment">// 如果原本需要发送空ack，并且此时 sender 发送了新数据，则停止发送空ack</span></span><br><span class="line">    <span class="keyword">if</span> (need_send_ack &amp;&amp; !_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>())</span><br><span class="line">        need_send_ack = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是 LISEN 到了 SYN</span></span><br><span class="line"><span class="keyword">if</span> (TCPState::<span class="built_in">state_summary</span>(_receiver) == TCPReceiverStateSummary::SYN_RECV &amp;&amp;</span><br><span class="line">    TCPState::<span class="built_in">state_summary</span>(_sender) == TCPSenderStateSummary::CLOSED) &#123;</span><br><span class="line">    <span class="comment">// 此时肯定是第一次调用 fill_window，因此会发送 SYN + ACK</span></span><br><span class="line">    <span class="built_in">connect</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 TCP 断开连接时是否时需要等待</span></span><br><span class="line"><span class="comment">// CLOSE_WAIT</span></span><br><span class="line"><span class="keyword">if</span> (TCPState::<span class="built_in">state_summary</span>(_receiver) == TCPReceiverStateSummary::FIN_RECV &amp;&amp;</span><br><span class="line">    TCPState::<span class="built_in">state_summary</span>(_sender) == TCPSenderStateSummary::SYN_ACKED)</span><br><span class="line">    _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果到了准备断开连接的时候。服务器端先断</span></span><br><span class="line"><span class="comment">// CLOSED</span></span><br><span class="line"><span class="keyword">if</span> (TCPState::<span class="built_in">state_summary</span>(_receiver) == TCPReceiverStateSummary::FIN_RECV &amp;&amp;</span><br><span class="line">    TCPState::<span class="built_in">state_summary</span>(_sender) == TCPSenderStateSummary::FIN_ACKED &amp;&amp; !_linger_after_streams_finish) &#123;</span><br><span class="line">    _is_active = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果收到的数据包里没有任何数据，则这个数据包可能只是为了 keep-alive</span></span><br><span class="line"><span class="keyword">if</span> (need_send_ack)</span><br><span class="line">    _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">_trans_segments_to_out_with_ack_and_win();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>总体流程如下</p>
<ol>
<li>检测是不是还不是alive</li>
<li>检查是不是rst</li>
<li>接下来看，是不是刚开始建立绘画的ack状态，（没有ackno还有next发送的，刚开始进行建立）</li>
<li>之后就是receiver接受这个seg，同事如果有ack，那么sender也需要进行校验</li>
<li>如果是刚建立的，那么还是需要进行发送fill_windows作为返回放入到sender的发送器</li>
<li>如果自己的发送器还有接收器都为空，那么就说明彻底结束，不需要继续keep alive</li>
<li>如果接收到的 TCP 数据包<strong>包含的 seqno 是无效</strong>的，则 TCPConnection 也需要回复一个类似的无效数据包，返回处理特殊情况</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_active) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reset the timer</span></span><br><span class="line">    _time_since_last_segment_received = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> TCPHeader &amp;header = seg.<span class="built_in">header</span>();</span><br><span class="line">    <span class="comment">// if TCP does not receive SYN from remote peer, and not send SYN to remote peer</span></span><br><span class="line">    <span class="keyword">if</span> (!_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; _sender.<span class="built_in">next_seqno_absolute</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// at this time, TCP acts as a server,</span></span><br><span class="line">        <span class="comment">// and should not receive any segment except it has SYN flag</span></span><br><span class="line">        <span class="keyword">if</span>(!header.syn) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">        <span class="comment">// try to send SYN segment, use for opening TCP at the same time</span></span><br><span class="line">        <span class="built_in">connect</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the TCP ends in an unclean shutdown when receiving RST segment</span></span><br><span class="line">    <span class="keyword">if</span> (header.rst) &#123;</span><br><span class="line">        <span class="built_in">unclean_shutdown</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">    <span class="comment">// if TCP sends SYN segment as a client but does not receive SYN from remote peer,</span></span><br><span class="line">    <span class="comment">// the local TCP should not handle it, too. </span></span><br><span class="line">    <span class="keyword">if</span> (!_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the `_linger_after_streams_finish` the first time the inbound stream ends</span></span><br><span class="line">    <span class="keyword">if</span> (!_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>()) &#123;</span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// use the remote peer&#x27;s ackno and window size to update the local sending window</span></span><br><span class="line">    <span class="keyword">if</span> (header.ack) &#123;</span><br><span class="line">        _sender.<span class="built_in">ack_received</span>(header.ackno, header.win);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="comment">// makes sure that at least one segment is sent in reply</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() &gt; <span class="number">0</span> &amp;&amp; _sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// an extra special case to respond to a keep-alive segment</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span> &amp;&amp; header.seqno == _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>最后一个就是关闭，分为正常操作，还有不正常。正常直接就是不在activate活跃，不正常全部进入error状态</p>
<p>下面是正常关闭</p>
<blockquote>
<p>TCP 的正常关闭即 TCP 的四次挥手, 是本实验中最为复杂的地方, 其中也有笔者不是很确定的地方.<br>TCP 正常关闭的四个前提已经在 #要点 中提到, 如下即前提与代码的对应:</p>
<p>Prereq#1: _receiver.unassembled_bytes()&#x3D;&#x3D;0 &amp;&amp; _receiver.stream_out().input_ended(), 实际上可以直接转化为 _receiver.stream_out().input_ended()(此处使用 _receiver.stream_out().eof() 方法同样能通过测试, 任务指导中描述使用的 ended, 因此这里笔者选择了前者).<br>Prereq#2: _sender.stream_in().eof(). 这里需要是 eof() 方法而非 input_ended(), 因为要确保发送字节流的所有数据已经全部发送出去.<br>Prereq#3: _sender.bytes_in_flight()&#x3D;&#x3D;0</p>
</blockquote>
<p>主要就是发送器为eof，接收器为eof，然后还没有没被确认的byte</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// TCP clean shutdown</span><br><span class="line">if (_receiver.stream_out().input_ended() &amp;&amp; _sender.stream_in().eof() &amp;&amp; _sender.bytes_in_flight() == 0 &amp;&amp; (!_linger_after_streams_finish || _time_since_last_segment_received &gt;= 10 * _cfg.rt_timeout)) &#123;</span><br><span class="line">    _active = false;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>不正常的关闭就是设置为error，然后也是关闭</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">TCPConnection::unclean_shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _active = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>最后一个就是rst，这个作用就是封装的时候，我们从sender里面提取的seg加入一个rst标志位，然后再次调用connection的发送代码来进行发送。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::send_RST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    TCPSegment segment = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">    _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">    optional&lt;WrappingInt32&gt; ackno = _receiver.<span class="built_in">ackno</span>();</span><br><span class="line">    <span class="keyword">if</span> (ackno.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        segment.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">        segment.<span class="built_in">header</span>().ackno = ackno.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    segment.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>() &lt;= numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>()</span><br><span class="line">                               ? _receiver.<span class="built_in">window_size</span>()</span><br><span class="line">                               : numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    segment.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">    _segments_out.<span class="built_in">emplace</span>(segment);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unclean_shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<p>整体代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_connection.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy implementation of a TCP connection</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For Lab 4, please replace with a real implementation that passes the</span></span><br><span class="line"><span class="comment">// automated checks run by `make check`.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;...<span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">unassembled_bytes</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _time_since_last_segment_received; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_active) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reset the timer</span></span><br><span class="line">    _time_since_last_segment_received = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> TCPHeader &amp;header = seg.<span class="built_in">header</span>();</span><br><span class="line">    <span class="comment">// if TCP does not receive SYN from remote peer, and not send SYN to remote peer</span></span><br><span class="line">    <span class="keyword">if</span> (!_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; _sender.<span class="built_in">next_seqno_absolute</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// at this time, TCP acts as a server,</span></span><br><span class="line">        <span class="comment">// and should not receive any segment except it has SYN flag</span></span><br><span class="line">        <span class="keyword">if</span> (!header.syn) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">        <span class="comment">// try to send SYN segment, use for opening TCP at the same time</span></span><br><span class="line">        <span class="built_in">connect</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the TCP ends in an unclean shutdown when receiving RST segment</span></span><br><span class="line">    <span class="keyword">if</span> (header.rst) &#123;</span><br><span class="line">        <span class="built_in">unclean_shutdown</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">    <span class="comment">// if TCP sends SYN segment as a client but does not receive SYN from remote peer,</span></span><br><span class="line">    <span class="comment">// the local TCP should not handle it, too.</span></span><br><span class="line">    <span class="keyword">if</span> (!_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the `_linger_after_streams_finish` the first time the inbound stream ends</span></span><br><span class="line">    <span class="keyword">if</span> (!_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>()) &#123;</span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// use the remote peer&#x27;s ackno and window size to update the local sending window</span></span><br><span class="line">    <span class="keyword">if</span> (header.ack) &#123;</span><br><span class="line">        _sender.<span class="built_in">ack_received</span>(header.ackno, header.win);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="comment">// makes sure that at least one segment is sent in reply</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() &gt; <span class="number">0</span> &amp;&amp; _sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// an extra special case to respond to a keep-alive segment</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span> &amp;&amp; header.seqno == _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _active; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_active) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> ret = _sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_active) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _time_since_last_segment_received += ms_since_last_tick;</span><br><span class="line">    _sender.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line">    <span class="comment">// TCP unclean shutdown if the number of consecutive retransmissions</span></span><br><span class="line">    <span class="comment">// is more than an upper limit</span></span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">consecutive_retransmissions</span>() &gt; TCPConfig::MAX_RETX_ATTEMPTS) &#123;</span><br><span class="line">        <span class="built_in">send_RST</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TCP clean shutdown if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (!_linger_after_streams_finish || _time_since_last_segment_received &gt;= <span class="number">10</span> * _cfg.rt_timeout)) &#123;</span><br><span class="line">        _active = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// send segments when `_sender.tick()` has a retransmission</span></span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCPConnection::~<span class="built_in">TCPConnection</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">active</span>()) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Warning: Unclean shutdown of TCPConnection\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Your code here: need to send a RST segment to the peer</span></span><br><span class="line">            <span class="built_in">send_RST</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception destructing TCP FSM: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::send_segments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment segment = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        optional&lt;WrappingInt32&gt; ackno = _receiver.<span class="built_in">ackno</span>();</span><br><span class="line">        <span class="comment">// if TCP does not receive SYN segments from the remote peer, i.e. at SYN_SENT state</span></span><br><span class="line">        <span class="comment">// TCP will not set ACK flag and seqno</span></span><br><span class="line">        <span class="keyword">if</span> (ackno.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            segment.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            segment.<span class="built_in">header</span>().ackno = ackno.<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set the local receiver&#x27;s window size</span></span><br><span class="line">        segment.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>() &lt;= numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>()</span><br><span class="line">                                   ? _receiver.<span class="built_in">window_size</span>()</span><br><span class="line">                                   : numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        _segments_out.<span class="built_in">emplace</span>(segment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::send_RST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    TCPSegment segment = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">    _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">    optional&lt;WrappingInt32&gt; ackno = _receiver.<span class="built_in">ackno</span>();</span><br><span class="line">    <span class="keyword">if</span> (ackno.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        segment.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">        segment.<span class="built_in">header</span>().ackno = ackno.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    segment.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>() &lt;= numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>() ? _receiver.<span class="built_in">window_size</span>()</span><br><span class="line">                                                                                      : numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    segment.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">    _segments_out.<span class="built_in">emplace</span>(segment);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unclean_shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">TCPConnection::unclean_shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _active = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>这一届主要是实现如何建立连接，在两个对等节点之间。我们调用之前实现的sender还有receiver来进行处理。这一节的边界条件太多，直接参考的别人的实现。</p>
<p>主要实现的功能就是发送还有接受</p>
<p>connection的发送功能就是从sender里面获取seg，然后进行封装ack来发送，放入到自己的connection的队列</p>
<p>connection的接受功能就比较多，建立会话联系，1.刚开始建立syn的时候收到seg，这个歌时候要看他有没有syn标识，有就直接交给receiver处理，因为这个时候不需要进行校验ack，保证tcp的完整性。2.如果是rst错误，直接不安全的关闭连接。3.普通的seg，来确保收到的正确，这个时候就需要receiver还有sender，receiver手机seg，sender使用ackno更新窗口还有确认之前发送的已经到达，之后还需要发送自己文件，sender使用fill-windows来发送。最后是特殊条件，还有放入到sender队列里面，这个时候，就需要connection进行发送。</p>
<p>trick的功能</p>
<ol>
<li>更新sender里面的定时器</li>
<li>然后超时设置rst</li>
<li>之后就是接着发送send（因为重传，可能会放入新的seg到sender的队列里面）</li>
</ol>
<p>剩下的就是普通的代码，可以直接返回的。</p>
<p>总体来说，这个代码还是非常难得。不像xv6那种有提示，这个代码的提示基本没有，操作说明说了和没有说一样，只能按照别人已经实现了的代码，来倒退这个函数到底是要干什么。这几个la做完，的确对tcp的可靠传输，还有拥塞控制有了更一步的了解。主要的是还是要参考，下面2张图。</p>
<p>知道sender，还有receiver的底层</p>
<p><img src="https://img2023.cnblogs.com/blog/2065884/202304/2065884-20230425140312132-987858718.png" alt="img"></p>
<p>然后重组器的实现机制，和发送器能发送的窗口。</p>
<ol>
<li>重组器的next就是第一个没有assemble的</li>
<li>发送器的窗口大小是ack+windows—next，ack是第一个还没有读入到的，绿色的就是没有确认的</li>
</ol>
<p><img src="https://kiprey.github.io/2021/11/cs144-lab1/image-20211107124153476.png" alt="image-20211107124153476"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://yoursite.com">weijia</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2023/07/09/cs144%E5%AE%9E%E9%AA%8C/">http://yoursite.com/2023/07/09/cs144%E5%AE%9E%E9%AA%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cs144/">cs144</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/10/sovits%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">sovits训练教程</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/09/warp%E9%85%8D%E7%BD%AEclash/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">warp配置clash</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">weijia</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">92</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lab0-%EF%BC%9Awarm-up"><span class="toc-number">1.</span> <span class="toc-text">lab0 ：warm up</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Set-up-GNU-x2F-Linux"><span class="toc-number">1.1.</span> <span class="toc-text">1 Set up GNU&#x2F;Linux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Networking-by-hand"><span class="toc-number">1.2.</span> <span class="toc-text">2 Networking by hand</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Writing-webget"><span class="toc-number">1.3.</span> <span class="toc-text">3 Writing webget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-in-memory-reliable-byte-stream"><span class="toc-number">1.4.</span> <span class="toc-text">4.in-memory reliable byte stream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">5 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lab1-%EF%BC%9AStreamReassembler"><span class="toc-number">2.</span> <span class="toc-text">lab1 ：StreamReassembler</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab-2-the-TCP-receiver"><span class="toc-number">3.</span> <span class="toc-text">Lab 2: the TCP receiver</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCPReceiver-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.</span> <span class="toc-text">TCPReceiver 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E6%B1%82"><span class="toc-number">3.1.1.</span> <span class="toc-text">要求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lab-3-%EF%BC%9ATCPSender-%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">lab 3 ：TCPSender 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">4.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">4.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lab4-tcp-connection"><span class="toc-number">5.</span> <span class="toc-text">lab4 tcp connection</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">5.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">5.2.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/10/sovits%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/" title="sovits训练教程"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="sovits训练教程"/></a><div class="content"><a class="title" href="/2023/07/10/sovits%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/" title="sovits训练教程">sovits训练教程</a><time datetime="2023-07-10T03:06:38.000Z" title="Created 2023-07-10 11:06:38">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/09/cs144%E5%AE%9E%E9%AA%8C/" title="cs144实验"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cs144实验"/></a><div class="content"><a class="title" href="/2023/07/09/cs144%E5%AE%9E%E9%AA%8C/" title="cs144实验">cs144实验</a><time datetime="2023-07-09T03:48:37.000Z" title="Created 2023-07-09 11:48:37">2023-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/09/warp%E9%85%8D%E7%BD%AEclash/" title="warp配置clash"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="warp配置clash"/></a><div class="content"><a class="title" href="/2023/07/09/warp%E9%85%8D%E7%BD%AEclash/" title="warp配置clash">warp配置clash</a><time datetime="2023-07-09T03:11:38.000Z" title="Created 2023-07-09 11:11:38">2023-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/14/mmseg%E4%BB%A3%E7%A0%81%E8%AF%BE/" title="mmseg代码课"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mmseg代码课"/></a><div class="content"><a class="title" href="/2023/06/14/mmseg%E4%BB%A3%E7%A0%81%E8%AF%BE/" title="mmseg代码课">mmseg代码课</a><time datetime="2023-06-14T07:45:40.000Z" title="Created 2023-06-14 15:45:40">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/10/mmdet%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/" title="mmdet代码实战"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mmdet代码实战"/></a><div class="content"><a class="title" href="/2023/06/10/mmdet%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/" title="mmdet代码实战">mmdet代码实战</a><time datetime="2023-06-10T09:01:45.000Z" title="Created 2023-06-10 17:01:45">2023-06-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By weijia</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>