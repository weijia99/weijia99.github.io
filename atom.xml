<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-06-03T12:30:29.987Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>weijia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MMPose实战</title>
    <link href="http://yoursite.com/2023/06/03/MMPose%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2023/06/03/MMPose%E5%AE%9E%E6%88%98/</id>
    <published>2023-06-03T11:33:33.000Z</published>
    <updated>2023-06-03T12:30:29.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-mmpose实战"><a href="#1-mmpose实战" class="headerlink" title="1.mmpose实战"></a>1.mmpose实战</h1><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/1685794454339MMPose%E5%AE%9E%E6%88%98.png"></p><p>主要包括安装，mmdet实战，mmpose实战等三部分</p><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>安装方法，可以直接去看官网教程，主要是是首先下载pytorch，之后下载mmcv，使用mim来进行安装。然后在github下载源码，使用源码进行安装。难点包括网速原因（ladder或者是搜索加速网站）</p><p>建议新装一个环境，pytorch和mmcv要一一对应。我之前是2.0.安装之后无法训练，是版本原因。所以重装了一个conda环境。</p><h2 id="2-mmdet"><a href="#2-mmdet" class="headerlink" title="2.mmdet"></a>2.mmdet</h2><p>mmlab代码的整体训练流程</p><ol><li>数据集同意处理程coco的格式，使用lableme</li><li>设置cfg配置文件，这个歌文件包括模型，优化器，超参数，数据集还有pipeline，和权重</li><li>使用train来训练上述cfg或者是分布式训练使用bash脚本bash dist——train模型cfg</li><li>之后就是使用test来进行验证文件 test 模型 +pth进行验证</li><li>之后就是预测，一般使用命令行得到结果</li></ol><h2 id="3-mmpose"><a href="#3-mmpose" class="headerlink" title="3.mmpose"></a>3.mmpose</h2><p>与mmdet同理，还是多个步骤</p><p>最后一步是集合mmdet的权重+mmpose的权重来指定向下来进行预测</p><h2 id="4-作业"><a href="#4-作业" class="headerlink" title="4.作业"></a>4.作业</h2><p>关于中医耳朵</p><ol><li>首先是数据集下载，使用bypy这个python包进行下载</li><li>使用mmdet的训练流程来进行训练</li><li>使用mmposexunlliucheng进行训练</li><li>使用test来进行计算准确率</li><li>集合上述两个一起进行结果预测</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-mmpose实战&quot;&gt;&lt;a href=&quot;#1-mmpose实战&quot; class=&quot;headerlink&quot; title=&quot;1.mmpose实战&quot;&gt;&lt;/a&gt;1.mmpose实战&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://fastly.jsdelivr.net/</summary>
      
    
    
    
    
    <category term="mmlab" scheme="http://yoursite.com/tags/mmlab/"/>
    
  </entry>
  
  <entry>
    <title>人体关键点检测</title>
    <link href="http://yoursite.com/2023/06/02/%E4%BA%BA%E4%BD%93%E5%85%B3%E9%94%AE%E7%82%B9%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2023/06/02/%E4%BA%BA%E4%BD%93%E5%85%B3%E9%94%AE%E7%82%B9%E6%A3%80%E6%B5%8B/</id>
    <published>2023-06-02T13:28:46.000Z</published>
    <updated>2023-06-02T13:49:41.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人体关键点检测"><a href="#人体关键点检测" class="headerlink" title="人体关键点检测"></a>人体关键点检测</h1><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/1685712470039%E4%BA%BA%E4%BD%93%E5%85%B3%E9%94%AE%E6%A3%80%E6%B5%8B.png"></p><p>今天，这一节课的内容主要可以看成，人体关键点检测的综述。包括2d，3d人天姿态检测。主要介绍上述的算法，还有包括常用评价指标。</p><h2 id="1-检测思路"><a href="#1-检测思路" class="headerlink" title="1.检测思路"></a>1.检测思路</h2><h3 id="1-1自顶向下"><a href="#1-1自顶向下" class="headerlink" title="1.1自顶向下"></a>1.1自顶向下</h3><p>思路就是首先识别出人，之后在进行关键点识别，这样的缺点就是整体精度收到检测器算法，还有一个就是计算量太大了。</p><h3 id="1-2自底向上"><a href="#1-2自底向上" class="headerlink" title="1.2自底向上"></a>1.2自底向上</h3><p>先识别关键点，之后再次识别人类。计算量就少很多。</p><h3 id="1-3基于回归的"><a href="#1-3基于回归的" class="headerlink" title="1.3基于回归的"></a>1.3基于回归的</h3><p>根据图像直接回归出来坐标</p><h3 id="1-4基于热力图"><a href="#1-4基于热力图" class="headerlink" title="1.4基于热力图"></a>1.4基于热力图</h3><p>热力图是输出与原图比例一样的图像，但是每一个通道里面，关键点的坐标是1.预测出关键点既可以进行绘制。同时关键点一般使用max，或者是进行求期望获得</p><h2 id="2-2d检测"><a href="#2-2d检测" class="headerlink" title="2.2d检测"></a>2.2d检测</h2><h3 id="2-1自顶向下"><a href="#2-1自顶向下" class="headerlink" title="2.1自顶向下"></a>2.1自顶向下</h3><p>回归：包括DeepPOse（直接输出坐标），级联DeepPose，RLE（借鉴Flow思想，把分布运用多个高斯分布来进行拟合）</p><p>热力图：HourGlass（跳连接，是对称的自己），baseline（resnet+反卷积），HRNET（高分辨率，自己生成高分辨率+低分辨率的）</p><h3 id="2-2自底向上"><a href="#2-2自底向上" class="headerlink" title="2.2自底向上"></a>2.2自底向上</h3><p>openPose：先进行预测关键点，然后计算亲和度，高得就是同一个人</p><h3 id="2-3单阶段"><a href="#2-3单阶段" class="headerlink" title="2.3单阶段"></a>2.3单阶段</h3><p>一个阶段就可以结算出来结果。</p><p>包括：SPM（回归位置+方向向量），层级SPM（分部位来进行回归）</p><h3 id="2-4TRansform"><a href="#2-4TRansform" class="headerlink" title="2.4TRansform"></a>2.4TRansform</h3><p>PPTR：都是用一套DeRT个骨干网络，先框选人，之后关键点预测的时候把transform里面的q换成关键点）</p><p>TokenPose：cnn得到特征信息，之后在与pose信息一起add，然后放入到transform进行炼丹</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="3-3d检测"><a href="#3-3d检测" class="headerlink" title="3.3d检测"></a>3.3d检测</h2><p>难点就是如何从2位换源到3维</p><p>解决思路：</p><ol><li>直接2d还原生成3d   coarse</li><li>利用视频，首先生成单帧的2d ，之后2d再次生3d  cideoPOse</li><li>利用多个视角   voxelPose</li></ol><h2 id="4-评价指标"><a href="#4-评价指标" class="headerlink" title="4.评价指标"></a>4.评价指标</h2><p>PCP：准确率</p><p>PDJ：在一定比例</p><p>PCK：在阈值范围里</p><p>oks：计算公式</p><h2 id="5-DensePOse"><a href="#5-DensePOse" class="headerlink" title="5.DensePOse"></a>5.DensePOse</h2><p>把人体划分成24块，每一个部分256*256，有14个关键点</p><p>主要算法包括：rcnn+dense reg，SMPL，SMPLisy和HMR</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;人体关键点检测&quot;&gt;&lt;a href=&quot;#人体关键点检测&quot; class=&quot;headerlink&quot; title=&quot;人体关键点检测&quot;&gt;&lt;/a&gt;人体关键点检测&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://fastly.jsdelivr.net/gh/weijia99/</summary>
      
    
    
    
    
    <category term="MMPose" scheme="http://yoursite.com/tags/MMPose/"/>
    
    <category term="cv" scheme="http://yoursite.com/tags/cv/"/>
    
  </entry>
  
  <entry>
    <title>mmlab简介</title>
    <link href="http://yoursite.com/2023/06/01/mmlab%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2023/06/01/mmlab%E7%AE%80%E4%BB%8B/</id>
    <published>2023-06-01T11:50:44.000Z</published>
    <updated>2023-06-01T12:01:14.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mmlab简介"><a href="#mmlab简介" class="headerlink" title="mmlab简介"></a>mmlab简介</h1><p>mmlab算法库是mmlab实验室在github上开源的一系列算法。由港中文的汤晓鸥教授建立的。本节主要介绍mmlab算法库相关简介</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16856202144211685620214365.png"></p><p>思维导图如上。主要包括目标检测，3d点云，图像分割，图像识别，视频理解，还有AIGC等相关应用。最后还有部署的算法库mmdeploy。目前几乎涵盖了计算机视觉相关的所有领域。在学术界还有工业界都被广泛的使用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mmlab简介&quot;&gt;&lt;a href=&quot;#mmlab简介&quot; class=&quot;headerlink&quot; title=&quot;mmlab简介&quot;&gt;&lt;/a&gt;mmlab简介&lt;/h1&gt;&lt;p&gt;mmlab算法库是mmlab实验室在github上开源的一系列算法。由港中文的汤晓鸥教授建立的。本节</summary>
      
    
    
    
    
    <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
    <category term="mmlab" scheme="http://yoursite.com/tags/mmlab/"/>
    
  </entry>
  
  <entry>
    <title>deepin安装docker和pytorch</title>
    <link href="http://yoursite.com/2023/06/01/deepin%E5%AE%89%E8%A3%85docker/"/>
    <id>http://yoursite.com/2023/06/01/deepin%E5%AE%89%E8%A3%85docker/</id>
    <published>2023-06-01T09:28:58.000Z</published>
    <updated>2023-06-01T10:18:44.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deepin安装docker和pytorch"><a href="#deepin安装docker和pytorch" class="headerlink" title="deepin安装docker和pytorch"></a>deepin安装docker和pytorch</h1><p>总体的流程图大致如下，首先是安装linux，这个直接跳过，接下来就是安装docker，之后，安装docker之后，安装pytorch image，然后使用vscode来进行深度学习开发。这样。不需要每次都要进行配置环境，直接使用这个镜像，构建多个容器，可以互不影响。</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/1685611681945deepin%E5%AE%89%E8%A3%85docker.png"></p><h2 id="1-docker相关设置"><a href="#1-docker相关设置" class="headerlink" title="1.docker相关设置"></a>1.docker相关设置</h2><h3 id="1-docker安装"><a href="#1-docker安装" class="headerlink" title="1.docker安装"></a>1.docker安装</h3><blockquote><p>前情提示，由于dockerhub，最近几天已经被gfw给404了，建议首先安装好了就来进行更换镜像。</p></blockquote><p>由于deepin是Debian的分支，因此我们选择Debian的安装命令，详细教程参考<a href="https://www.runoob.com/docker/debian-docker-install.html">Debian Docker 安装 | 菜鸟教程 (runoob.com)</a></p><p>主要命令就是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure><p><strong>注意，安装完成之后，请务必换源</strong></p><p><a href="https://www.runoob.com/docker/docker-mirror-acceleration.html">Docker 镜像加速 | 菜鸟教程 (runoob.com)</a></p><p>主要是在下面进行在  &#x2F;etc&#x2F;docker&#x2F;daemon.json 下面增加源，这个地方也可以修改，image默认下载的地方</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl restart docker</span></span><br></pre></td></tr></table></figure><p>之后执行重启。</p><h3 id="1-2加入到docker用户组"><a href="#1-2加入到docker用户组" class="headerlink" title="1.2加入到docker用户组"></a>1.2加入到docker用户组</h3><p>之后，因为使用docker默认是需要特权docker组里的成员才能使用，所以我们需要把当前用户加入到docker组里面</p><p>主要参考的是这个博文，首先查看是不是已经有了docker用户组，已经有了我们直接进行加入当前用户，然后进行重启。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /etc/group | grep docker</span><br><span class="line"></span><br><span class="line">sudo usermod -aG docker 要添加的user</span><br><span class="line"></span><br><span class="line">sudo chmod a+rw /var/run/docker.sock</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3附加内容（配置自己的images）"><a href="#1-3附加内容（配置自己的images）" class="headerlink" title="1.3附加内容（配置自己的images）"></a>1.3附加内容（配置自己的images）</h3><p>每次换到一个新电脑的时候，最麻烦的事情就是进行环境配置，下载所需要的安装软件，一个个的执行。现在有了docker，我们可以直接去dockerhub你输入命令来得到所需要的环境。例如java开发的环境（mysql，MongoDB和redis等）。</p><p>参考下面的教程：</p><p><a href="https://blog.chennn.com/docker-build-java-development-environment/">Docker搭建Java开发环境 (chennn.com)</a></p><p>现在我要构建一个属于自己的开发环境，例如只需要java和maven，那么我们改如何得到呢。现在，这里我们需要使用的是dockerfile这个文件，通过这个文件看我们可以构建出来哦自己的images。</p><p>。dockerfile语法如下 ：<a href="https://www.runoob.com/docker/docker-dockerfile.html">Docker Dockerfile | 菜鸟教程 (runoob.com)</a></p><p>首先需要定义一个from，这个就相当于原始文件，我们首先定义from openjdk，来作为自己的原始image，之后根据自己的需要来进行修改。之后，我们需要使用maven，这里我们选择编译安装。分为下面几步。</p><ol><li>下载maven源码</li><li>进行解压</li><li>然后进行移动到local目录里面</li><li>设置环境变量</li></ol><p>我们使用run 来执行每一个shell 命令，</p><p>之后就是设置环境变量，因为gfw的原因，有时候，我们需要使用代理，还有吧上面的源码放入到env上面，所以需要使用或者其他端口隐射到envv来进行设置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8</span><br><span class="line"></span><br><span class="line">RUN wget https://dlcdn.apache.org/maven/maven-3/3.8.6/binaries/apache-maven-3.8.6-bin.zip</span><br><span class="line">RUN unzip apache-maven-3.8.6-bin.zip</span><br><span class="line">RUN mv apache-maven-3.8.6 /usr/local/maven</span><br><span class="line">RUN rm -rf apache-maven-3.8.6-bin.zip</span><br><span class="line"></span><br><span class="line">ENV MAVEN_HOME=/usr/local/maven</span><br><span class="line">ENV PATH=$MAVEN_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>这样，我们就构建好了自己的开发包。</p><p>上面的代码还可以精简，我们只需要使用一个run ，剩下的全部用&amp;&amp;连接shell命令就可以</p><p>然后 我们进行构建，使用这个dockerfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t java-env:8 .</span><br></pre></td></tr></table></figure><p>最后我们就是启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name java-base-env java-env:8</span><br></pre></td></tr></table></figure><p>如果需要进入到容器内部，我们可以使用docker exec -it 容器名称</p><hr><blockquote><p>扩展：使用gateway来进行远程开发。我们可以在images里面安装openssherver，然后修改、etc&#x2F;ssh&#x2F;sshd_config里面的允许root登录还有密码登录，之后，设置这个为自动启动。</p></blockquote><p>参考下面这个连接：<a href="https://zhuanlan.zhihu.com/p/80099904">VSCode+Docker: 打造最舒适的深度学习环境 - 知乎 (zhihu.com)</a></p><p>之后，我们在docker启动的时候设置端口映射这个容器，吧9001或者其他端口映射到22，然后使用gateway进行远程连接，输入端口9001，账户密码，就可以进行开发了。</p><h2 id="2-deepin配置pytorch镜像"><a href="#2-deepin配置pytorch镜像" class="headerlink" title="2.deepin配置pytorch镜像"></a>2.deepin配置pytorch镜像</h2><h3 id="2-1deepin的设置"><a href="#2-1deepin的设置" class="headerlink" title="2.1deepin的设置"></a>2.1deepin的设置</h3><p>首先，我们需要对deepin进行设置，默认没有安装cuda，我们直接使用deepin官方的命令，安装cuda-toolkit，还有nvidia-smi进行apt安装。之后就完成了。有些版本是需屏蔽自己显卡，然后才能安装，笔者目前没有与到，安装比较简单。命令都在开始的思维导图上面。</p><h3 id="2-2（可选）配置proxychains"><a href="#2-2（可选）配置proxychains" class="headerlink" title="2.2（可选）配置proxychains"></a>2.2（可选）配置proxychains</h3><p>来进行国内访问加速，直接apt 进行安装就行，然后修改配置文件 &#x2F;etc&#x2F;proxychains.conf。</p><p>参考这篇文章 <a href="https://zhuanlan.zhihu.com/p/166375631">linux命令行代理神器-proxychains - 知乎 (zhihu.com)</a></p><p>在.bashrc里面设置alias pr &#x3D;proxychains，进行缩短单词</p><h3 id="2-3安装pytorch"><a href="#2-3安装pytorch" class="headerlink" title="2.3安装pytorch"></a>2.3安装pytorch</h3><p>直接根据沐神的github推荐的image来使用</p><p><a href="https://github.com/mli/transformers-benchmarks">mli&#x2F;transformers-benchmarks: real Transformer TeraFLOPS on various GPUs (github.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --gpus all -it --rm -p 8888:8888 -v ~:/workspace \</span><br><span class="line">--ipc=host --ulimit memlock=-1 --ulimit stack=67108864 \</span><br><span class="line">nvcr.io/nvidia/pytorch:22.07-py3</span><br></pre></td></tr></table></figure><p>这样我们直接进入到容器里面了。我们使用screen 吧这个容器放入到后台执行。</p><p>这样就安装完成。同事还把我们的home目录隐射到workdir里面，我们可以访问到workdir的文件来找到服务器的文件</p><h2 id="3-vscode-x2F-idea-x2F-pycharm的使用"><a href="#3-vscode-x2F-idea-x2F-pycharm的使用" class="headerlink" title="3.vscode&#x2F;idea&#x2F;pycharm的使用"></a>3.vscode&#x2F;idea&#x2F;pycharm的使用</h2><h3 id="3-1vscode进行配置"><a href="#3-1vscode进行配置" class="headerlink" title="3.1vscode进行配置"></a>3.1vscode进行配置</h3><p>我们首先进去插件商店，安装dev dontainer。之后使用远程连接到docker宿主机上 </p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16856142119451685614211207.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16856142399431685614239438.png"></p><p>在宿主机上面选择开发容器，我们就可以进入到刚刚的pytorch容器里面</p><h3 id="3-2idea的设置"><a href="#3-2idea的设置" class="headerlink" title="3.2idea的设置"></a>3.2idea的设置</h3><p>这里直接使用gateway来进行设置，选择新建一个ssh，我们输入之前映射到22的端口，还有账号密码（详情加1.3），然后进行连接，之后选择后端版本的idea，这样idea后端就部署到容器里面。之后，我们就可以进行远程及开发</p><h3 id="3-2pycharm设置"><a href="#3-2pycharm设置" class="headerlink" title="3.2pycharm设置"></a>3.2pycharm设置</h3><p>对于pycharm，不需要上述那么复杂，我们直接进行远程开发，ssh到宿主机器的22端口，然后我们选择解释器interpret为docker里面的容器，就可以直接执行python代码，来进行调试开发了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;deepin安装docker和pytorch&quot;&gt;&lt;a href=&quot;#deepin安装docker和pytorch&quot; class=&quot;headerlink&quot; title=&quot;deepin安装docker和pytorch&quot;&gt;&lt;/a&gt;deepin安装docker和pytor</summary>
      
    
    
    
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
    <category term="torch" scheme="http://yoursite.com/tags/torch/"/>
    
    <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>mysql学习</title>
    <link href="http://yoursite.com/2023/04/19/mysql%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2023/04/19/mysql%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-04-19T11:25:58.000Z</published>
    <updated>2023-04-24T09:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL是怎样运行的"><a href="#MySQL是怎样运行的" class="headerlink" title="MySQL是怎样运行的"></a>MySQL是怎样运行的</h1><h2 id="0-语法篇"><a href="#0-语法篇" class="headerlink" title="0.语法篇"></a>0.语法篇</h2><p>常用的关键字:</p><ol><li>distinct,select distinct* from来进行去重</li><li>排序order by id des(下降</li><li>in(a,b)&#x3D;&#x3D;a or b</li><li>查询的时候,列可以直接进行操作,如果我们要求对(欸一个分数+10)&#x3D;&#x3D;select score+10 from</li><li>null无论什么操作还是null</li><li>字符串函数啊,left,right,substr都是进行截取</li><li>count(列名)就是来进行统计由多少个</li><li>分组查询,这个相当于多个目录(省,市,县来进行分段)使用group by province</li><li>例如求语文,英语,数学的平均分,写三个函数太累,select avg(subject) from group by subject</li><li>分组之后先接着进行过滤,例如,只想统计分数平均值大于60,后面市having by(不能用where,因为这是计算后的结果)</li><li>多表查询,外连接,分为做连接,还有右连接(核心就是完整的保留那一边),内连接就是只有都相等才进行保留</li><li>子查询,select * where id&#x3D;(查询语句),根据查询语句返回的结果再次进行查询</li><li>并集查询,使用union查询多个,会过滤重复的结果</li><li>视图view,相当于自己预先定义函数,然后进行了查询的结果存放的地方,再视图里操作页会影响原始表</li><li>储存程序,相当于函数,可以设定变量,@a来进行对变量a来进行赋值,会有返回值</li><li>储存过程,没有返回值,直接进行操作</li><li>下一个就是游标,相当于list</li><li>trigger触发器,就是进行检查,可以自定义每次增加删除,检查分数是不是小于100</li></ol><h2 id="1-前言篇"><a href="#1-前言篇" class="headerlink" title="1.前言篇"></a>1.前言篇</h2><blockquote><p>执行一条sql,都发生了什么</p></blockquote><p>主要包含一下流程,首先是连接启,之后查询缓存,缓存失败,进行语法分析,解析阿来就是对语法进行优化,然后才是执行,之后返回结果</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p><ol><li>server负责api的调用,分析还有执行sql,常用的存储过程还有触发器,视图都在这一层</li><li>存储层负责的是数据的存放还读取,数据库的innodb索引都在这一层</li></ol><h3 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1.连接器"></a>1.连接器</h3><p>负责身份认证还有权限相关的(登录mysql的时候)</p><p>show processlist查看当前的连接数目,空闲时间超过wait_time会哦被断开,最大的连接再max_connection上面,</p><h3 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2.查询缓存"></a>2.查询缓存</h3><p>mysql8.0删除这个功能了因为对于更新比较频繁的表,这个缓存基本就没有用,更新一次就删除缓存一次.</p><h3 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3.分析器"></a>3.分析器</h3><p>作用就是对语句进行分析,看这条语句要干什么.主要包括语法分析还有此法分析,语法分析就是看你是不是输入错误的单词,此法分析就是提取关键词</p><h3 id="4-执行器"><a href="#4-执行器" class="headerlink" title="4.执行器"></a>4.执行器</h3><p>执行sql查询语句,首先第一步就是看你有没有权限来查这个</p><ol><li>预处理器,检查是不是含有这个字段,把*替换成全表</li><li>优化器主要确定查询方案,因为一个数据库可能有多条索引,查找时间最小的</li><li>执行器执行,主键索引查询,全表查询,索引下推(建立二级索引agename,这个索引,直接根据开闭原则来进行判断)</li></ol><h2 id="2-mysql的一行记录是怎么存放的"><a href="#2-mysql的一行记录是怎么存放的" class="headerlink" title="2.mysql的一行记录是怎么存放的"></a>2.mysql的一行记录是怎么存放的</h2><blockquote><p>可以看到，共有三个文件，这三个文件分别代表着：</p><ul><li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li><li>t_order.frm ，t_order 的<strong>表结构</strong>会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li><li>t_order.ibd，t_order 的<strong>表数据</strong>会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。</li></ul><p>好了，现在我们知道了一张数据库表的数据是保存在「 表名字.ibd 」的文件里的，这个文件也称为独占表空间文件</p></blockquote><p>一张表的结构再frm里面,数据再ibd里面</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p><p>一个表空间可以由多个段组成,段是可以由多个不连续的区构成,区是由连续的页构成,页是由连续的记录进行组成</p><p><strong>页:</strong></p><p>​一个页大小是16kb,mysql的读写都是以页为单位,长江的页还有数据页面,undo页面,还有redo</p><p>区:</p><p>一个区的大小是1MB,那么就有64个页面,为了让相邻的两个页面的物理位置相邻,划分的一个1MB物理空间,这样就是顺序io</p><blockquote><p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了</strong>。</p><h4 id><a href="#" class="headerlink" title></a></h4></blockquote><p>段:</p><p>段是由多个区间构成的,一般分为索引段</p><p>​</p><ul><li>索引段：存放 B + 树的非叶子节点的区的集合；</li><li>数据段：存放 B + 树的叶子节点的区的集合；</li><li>回滚段：存放的是回滚数据的区的集合，之前讲<a href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离 (opens new window)</a>的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。</li></ul><p>索引都在非叶子节点上面,数据都在叶子上面,还有回滚数据</p><h2 id="3-索引"><a href="#3-索引" class="headerlink" title="3.索引"></a>3.索引</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%8F%90%E7%BA%B2.png" alt="img"></p><h3 id="3-1索引简介"><a href="#3-1索引简介" class="headerlink" title="3.1索引简介"></a>3.1索引简介</h3><p>索引是一种排好序的数据结构,作用相当于数据的目录 </p><p>优缺点:</p><ol><li>减少查询时间</li><li>但是数据增删改的时候会更新索引</li><li>会浪费一定的物理空间</li></ol><h3 id="3-2索引的分类"><a href="#3-2索引的分类" class="headerlink" title="3.2索引的分类"></a>3.2索引的分类</h3><p>数据结构;b+,hash,full-text</p><p>物理结构:主键索引,耳机索引(两个关键字何在一起)</p><p>字段:主键,唯一(unique),普通,前</p><p>数据结构:</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.drawio.png" alt="img"></p><p>主键查询,</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95btree.drawio.png" alt="二级索引 B+Tree"></p><p>最后一层才是数据节点,主键索引的是全部数据,耳机索引知识主键值,然后进行徽标才能得到值</p><blockquote><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul></blockquote><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E5%9B%9E%E8%A1%A8.drawio.png" alt="回表"></p><h3 id="3-3B树与B-树"><a href="#3-3B树与B-树" class="headerlink" title="3.3B树与B+树"></a>3.3B树与B+树</h3><ol><li>B树每个节点都有数据,b+树只有页节点才有数据</li><li>b树的叶节点是单独存在的,但是b+树是用单链表连接到下一个的</li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdgV8QoMTlAsFLK9yrPWQiapWzXLEtpJD3IsGAXyTsJQvXibTAnIYHKkIekK7licSTVftymQZ2gs4kEw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><blockquote><p>因为 <strong>B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助</strong>，比如说我们想知道 12 月 1 日和 12 月 12 日之间的订单，这个时候可以先查找到 12 月 1 日所在的叶子节点，然后利用链表向右遍历，直到找到 12 月12 日的节点，这样就不需要从根节点查询了，进一步节省查询需要的时间</p></blockquote><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推:"></a>索引下推:</h2><blockquote><ul><li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li><li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li></ul></blockquote><p>就是说,可以直接用联合索引来进行提权哦判断不符合的数据</p><h3 id="3-4什么时候需要索引"><a href="#3-4什么时候需要索引" class="headerlink" title="3.4什么时候需要索引"></a>3.4什么时候需要索引</h3><ol><li>id唯一</li><li>经常使用where,order by,groupby的字段</li></ol><p>不用的情况:不用where的字段,大量重复数据sex</p><h2 id="4-InnoDB引擎"><a href="#4-InnoDB引擎" class="headerlink" title="4.InnoDB引擎"></a>4.InnoDB引擎</h2><blockquote><p>这一章主要是讲MySQL默认引擎，包括基本单位，还有管理的基本单位</p></blockquote><h3 id="4-1简介"><a href="#4-1简介" class="headerlink" title="4.1简介"></a>4.1简介</h3><ol><li>盘与内存使用的是页，一个页大小是16kB</li><li>innoDB存放每一条记录叫做行</li><li>行是由头信息还有数据信息组成</li><li>主要有下面四种格式，compact，redunnat</li><li>首先是compact，（前面得到头信息，记录可变唱的字段，然后从小到大来记录，每一个字段的长度）</li><li>第二个就是记录这一行的null的数量（记录方法是one-hot方法，每一个列都是01表示）</li></ol><p>插入代码块如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alterr table student row_format = compact</span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE.png" alt="img"></p><p>记录的真实数据,包含三个隐藏列,默认idrow,trx表示食物id,是哪一个事务生成的,roll point代表回滚的</p><p><strong>varchar(n) 中 n 最大取值为多少？</strong></p><p>一行记录最大能存储 <strong>65535 字节的数据</strong>，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。</p><p>如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。</p><p>计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL<strong>值列表所占用的字</strong>节数 &#x3D; 65535 - 2 - 1 &#x3D; 65532。</p><p>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;&#x3D; 65535。</p><blockquote><p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p></blockquote><h3 id="4-2INnoDB数据页结构"><a href="#4-2INnoDB数据页结构" class="headerlink" title="4.2INnoDB数据页结构"></a>4.2INnoDB数据页结构</h3><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16819843724461681984371693.png"></p><blockquote><p>这一张主要讲解的是数据页，还有B+树的实现，介绍数据页的结构，包括记录，还有头结构</p></blockquote><ol><li>每一条记录都是存放在user record</li><li>n_owned 记录拥有的小弟</li><li>next记录吓一跳页面</li><li>还有两条虚拟记录，一个是infir+super</li><li>free space是记录空闲空间</li><li>page dir表示这是不是叶子节点</li></ol><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16819844104451681984409840.png">****</p><p>这是一条记录头信息，有包括id，还有拥有的小弟</p><p><strong>头信息：</strong>del——flag，next record吓一跳记录，heap_no相对记录在堆，还有一个type，表示是</p><p>删除记录：并不是在页面实际删除，而是设置一个del标记为1</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16819846234451681984623071.png"></p><blockquote><p>主每一条记录都用于n——cow这个适用于分组的，然后del代表为是不删除，还有相对位置，之后就是下一个记录的位置</p></blockquote><p>然后有两条虚拟记录，一个是最小的，还有一个是最大记录，当相当于虚拟头结点还有虚拟尾结点</p><p>这两个位置是最靠前的一个是0，一个是1，</p><p>page dire：这个作用就是为了把之前的记录进行3-4个一组来进行结合，记录最后一个索引最大的值为slot，n_row代表的是还有几个小弟</p><p>每一个slot代表</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16819850594441681985058988.png"></p><p>每一个slot代表一个地址</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16819852004481681985200031.png"></p><ol><li>一个页面是包含多个记录的</li><li>一个页面要进行分组,最小记录还有最大记录,之后就是数据记录来进行分组</li><li>分组最大的放入slot里面,他记录自己包含的小弟</li></ol><blockquote><p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p></blockquote><p>B+树每一个节点都是数据页</p><blockquote><ul><li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li><li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li><li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li></ul></blockquote><h2 id="5-事务"><a href="#5-事务" class="headerlink" title="5.事务"></a>5.事务</h2><p>事务是逻辑上一组操作,要么执行,要么不执行.实现事务,要遵循4个特性,aicd(原子性,一致性,隔离性,最后就是持久性)一只猩猩,就是操作完成,还是满足约束,隔离性,不会对其他事务进行影响.</p><h3 id="5-1并发事务带来的影响"><a href="#5-1并发事务带来的影响" class="headerlink" title="5.1并发事务带来的影响"></a>5.1并发事务带来的影响</h3><p>会出现,脏读,不可重复,幻读.</p><p>脏读:读取没有提交的值,然后值又进行回滚了</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/10b513008ea35ee880c592a88adcb12f.png" alt="图片"></p><p>不可重复读:</p><p>读取的值被修改,两次读取不一样</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/f5b4f8f0c0adcf044b34c1f300a95abf.png" alt="图片"></p><p>幻读:</p><p>读取了值,结果下一次读取的时候被删除了</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/d19a1019dc35dfe8cfe7fbff8cd97e31.png" alt="图片"></p><p>四种隔离级别:</p><ol><li>未提交读(脏读,幻读,可重复)</li><li>提交读(幻读,可重复)</li><li>可重复读(幻读)</li><li>可串行化</li></ol><p>可重复读很大程度避免了幻读</p><p>并发事务 的控制方法:基于锁还有mvcc(多版本并发控制)乐观</p><p>mvcc:hi一份数据多个版本,可以通过事务id,查找之前的版本</p><blockquote><h3 id="MySQL-的隔离级别是基于锁实现的吗？"><a href="#MySQL-的隔离级别是基于锁实现的吗？" class="headerlink" title="MySQL 的隔离级别是基于锁实现的吗？"></a>MySQL 的隔离级别是基于锁实现的吗？</h3></blockquote><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p><p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><hr><p><strong>对于四种隔离事务的实现方法</strong></p><ol><li>读未提交:直接读取最新的就行</li><li>可串行化通过枷锁来进行读取</li><li>读提交,使用read view来进行创建快照,读取事务处理王的结果.可重复读是只读取,生成时候的视图值</li></ol><p><strong>mvcc版本控制的实现</strong></p><blockquote><p>在内部，<code>InnoDB</code> 存储引擎为每行数据添加了三个 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">隐藏字段open in new window</a>：</p><ul><li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。此外，<code>delete</code> 操作在内部被视为更新，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除</li><li><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</li><li><code>DB_ROW_ID（6字节）</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</li></ul><hr></blockquote><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p><ol><li>create:创建的时候的id</li><li>m_id,当前的事务id列表(启动了,但是没有提交的事务)</li><li>min是最小的事务id</li><li>max是下一次事务的id</li></ol><p><img src="https://cdn.xiaolincoding.com//mysql/other/f595d13450878acd04affa82731f76c5.png" alt="图片"></p><p>每次进行事务操作的时候,会把trx_id更新为当前id,然后roll_point只想前一个版本,同时把前一个版本写入到undo文件里面</p><blockquote><p>undo文件:用来回滚的,还有一个作用就是mvcc</p></blockquote><ol><li>小于min的事务都可见</li><li>大于max的都不可见</li><li>处于min与max之间的,需要判断是不是再ids列表里面,不在就是可见</li></ol><blockquote><p>可重复读是如何实现的</p></blockquote><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE-new.png" alt="img"></p><p>开始的时候createid是自己,列表也是只有自己,所以a是可以一直</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE2.png" alt="img"></p><p> B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时<strong>发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的</strong>，也就是事务 B 可以获取到这条记录。</p><p>接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将小林的余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成<strong>版本链</strong>，如下图：</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16823261923071682326191600.png"></p><blockquote><p>你可以在上图的「记录的字段」看到，由于事务 A 修改了该记录，以前的记录就变成旧版本记录了，于是最新记录和旧版本记录通过链表的方式串起来，而且最新记录的 trx_id 是事务 A 的事务 id（trx_id &#x3D; 51）。</p><p>然后事务 B 第二次去读取该记录，<strong>发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录</strong>，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p><p>最后，当事物 A 提交事务后，<strong>由于隔离级别时「可重复读」，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事物 A 将小林余额修改为 200 万并提交了事务， 事务 B 第三次读取记录时，读到的记录都是小林余额是 100 万的这条记录</strong>。</p></blockquote><p><strong>就是说:对于事务a已经完成了,他的记录里面的trx更新为51,但是51再事务b里面,所以他要往前寻找第一个小于事务b的min的trx,然后就是50,因此取出50来作为记录</strong></p><blockquote><p>读提交是怎么实现的</p></blockquote><p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E8%AF%BB%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.png" alt="img"></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E8%AF%BB%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A12.drawio.png" alt="img"></p><blockquote><p>而对于幻读现象，不建议将隔离级别升级为串行化，因为这会导致数据库并发时性能很差。MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇<a href="https://xiaolincoding.com/mysql/transaction/phantom.html">文章 (opens new window)</a>），解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：</p><ul><li>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味<strong>着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，</strong>因为可能这期间另外一个事务修改了该记录，并提交了事务。</li><li>「可重复读」隔离级别是<strong>启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>，这样就保证了在事务期间读到的数据都是事务启动前的记录。</li></ul><p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p><p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL是怎样运行的&quot;&gt;&lt;a href=&quot;#MySQL是怎样运行的&quot; class=&quot;headerlink&quot; title=&quot;MySQL是怎样运行的&quot;&gt;&lt;/a&gt;MySQL是怎样运行的&lt;/h1&gt;&lt;h2 id=&quot;0-语法篇&quot;&gt;&lt;a href=&quot;#0-语法篇&quot; class</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>pve折腾</title>
    <link href="http://yoursite.com/2023/04/15/pve%E6%8A%98%E8%85%BE/"/>
    <id>http://yoursite.com/2023/04/15/pve%E6%8A%98%E8%85%BE/</id>
    <published>2023-04-15T13:31:59.000Z</published>
    <updated>2023-04-15T14:43:05.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pve折腾"><a href="#pve折腾" class="headerlink" title="pve折腾"></a>pve折腾</h1><p>自己的老电脑用了5年了，cpu还是4核心的，显卡是1050.硬盘还是1t的机械，都没多少剩余空间了。随着最近的硬盘内存大降价，我就凑巨资300买了一个1t的SATA固态，谁能想到，现在的nvme比SATA还便宜（我当初可是花费500元买的500g的nvme），然后硬盘前几天就到了。于是我就直接安装虚拟机了，想着在虚拟机你运行多个系统，目前已经完成的有openwrt，kali，deepin，安卓x86还有win11.但是win11没有进行显卡直通，其余都接近完美了。下面就对这几天的行为进行一次复盘。</p><h2 id="1-pve安装"><a href="#1-pve安装" class="headerlink" title="1.pve安装"></a>1.pve安装</h2><p>直接去官网进行下载，连接是选择<a href="https://pve.proxmox.com/wiki/Downloads%EF%BC%8C%E9%80%89%E6%8B%A9%E6%9C%80%E6%96%B0%E7%9A%84%E7%89%88%E6%9C%AC%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%EF%BC%8C%E7%84%B6%E5%90%8E%E5%AE%89%E8%A3%85%E7%9A%84%E8%AF%9D%E4%BD%BF%E7%94%A8ventoy%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E6%8A%8Apve%E6%94%BE%E5%85%A5%E5%88%B0u%E7%9B%98%E5%B0%B1%E5%8F%AF%E4%BB%A5%E3%80%82">https://pve.proxmox.com/wiki/Downloads，选择最新的版本就可以进行下载，然后安装的话使用ventoy，只需要把pve放入到u盘就可以。</a></p><p><a href="https://zhuanlan.zhihu.com/p/510216630">https://zhuanlan.zhihu.com/p/510216630</a></p><p>可以参考上面的教程，只不过需要注意的是，要填写的ip,是需要和你的局域网在一个网段里面。我自己定义的网络是192.168.100.2，gate：192.168.100.1。</p><h2 id="2-openwrt安装"><a href="#2-openwrt安装" class="headerlink" title="2.openwrt安装"></a>2.openwrt安装</h2><p>固件是在这个大神的网站下载的，自动编译，还可以进行自定义插件。<a href="https://supes.top/">https://supes.top/</a></p><ol><li>首先把img上传到pve上面</li><li>然后就是新建一个虚拟机，但是不要创建iso</li><li>之后使用img2iso，记住我们的磁盘id，使用qm importdisk 100 &#x2F;openwrt.img local-lvm</li><li>然后再启动项，把这个磁盘进行加入。</li><li>之后进行启动，设置网络ip vim etc</li></ol><p><a href="https://post.smzdm.com/p/a7nqp3r9/">https://post.smzdm.com/p/a7nqp3r9/</a></p><p>参考上面的安装流程</p><p><strong>2.1op作为主路由</strong></p><p>在openwrt里面进行PPPoE拨号，那么op就是要进行桥接2个电脑的网口，一个作为lan，一个作为lan，wan口连接宽带，然后去进行pppoe拨号。</p><p><strong>2.2op作为胖路由</strong></p><p>只需要桥接一个网络口，然后连接主路由的时候，需要进行设置。进入接口里面的lan设置ip为静态ip，然后gate设置为192.168.100.1（主路由的ip），然后dns也是主路由的ip，同时关闭DHCP，这样就不会干扰DHCP。</p><p>主要的痛点就是看你要做旁路由还是主路由，主路由就是没有</p><h2 id="3-deepin安装"><a href="#3-deepin安装" class="headerlink" title="3.deepin安装"></a>3.deepin安装</h2><p>deepin安装就是普通的linux安装流程，但是有一点就是安装pcie直通（把wifi）给deepin，无限网卡教程参考如下</p><p><a href="https://www.orcy.net.cn/185.html">https://www.orcy.net.cn/185.html</a></p><ol><li>修改grup，允许iommu</li><li>更新grub</li><li>重启</li><li>之后增加模块在module里面</li><li>然后就直接在虚拟机上添加pcie设备就行</li></ol><h2 id="4-primeos安装"><a href="#4-primeos安装" class="headerlink" title="4.primeos安装"></a>4.primeos安装</h2><p>目前测试了几个x86的系统在虚拟机上，都无法进行安装，只有三哥的这个才可以，选择的系统是classical版本，安卓7.0，然后也是正常的安装流程，要注意的是在安装的使用，你需要新建一个分区，然后再次写入。就可以了。然后功能都有，play商店也有。</p><h2 id="5-win10-x2F-11的坑"><a href="#5-win10-x2F-11的坑" class="headerlink" title="5.win10&#x2F;11的坑"></a>5.win10&#x2F;11的坑</h2><p>主要是为了远程玩游戏，但是看知乎这篇文章说，原神，不让用虚拟机，然后显卡直通弄了半天也没有成功，可能是win11的问题吧，等有时间了换成win10 ltsc试试。主要参考如下的教程</p><p><a href="https://zhuanlan.zhihu.com/p/571224296">https://zhuanlan.zhihu.com/p/571224296</a></p><p>这个大佬的目前还没有成功</p><p><a href="https://www.youtube.com/watch?v=00GxKDGUhxA&amp;ab_channel=VedioTalk">https://www.youtube.com/watch?v=00GxKDGUhxA&amp;ab_channel=VedioTalk</a></p><p>有关这个大佬得到是核显进行驱动</p><p><a href="https://blog.csdn.net/Qwertyuiop2016/article/details/127940349">https://blog.csdn.net/Qwertyuiop2016/article/details/127940349</a></p><p>这个大佬是直接进行ltsc驱动的，不知道是不是我的版本原因，下次再试试吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pve折腾&quot;&gt;&lt;a href=&quot;#pve折腾&quot; class=&quot;headerlink&quot; title=&quot;pve折腾&quot;&gt;&lt;/a&gt;pve折腾&lt;/h1&gt;&lt;p&gt;自己的老电脑用了5年了，cpu还是4核心的，显卡是1050.硬盘还是1t的机械，都没多少剩余空间了。随着最近的硬盘内</summary>
      
    
    
    
    
    <category term="pve，虚拟机" scheme="http://yoursite.com/tags/pve%EF%BC%8C%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>对抗无聊</title>
    <link href="http://yoursite.com/2023/04/12/%E5%AF%B9%E6%8A%97%E6%97%A0%E8%81%8A/"/>
    <id>http://yoursite.com/2023/04/12/%E5%AF%B9%E6%8A%97%E6%97%A0%E8%81%8A/</id>
    <published>2023-04-12T07:49:53.000Z</published>
    <updated>2023-04-12T08:01:34.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对抗无聊"><a href="#对抗无聊" class="headerlink" title="对抗无聊"></a>对抗无聊</h1><p><a href="https://www.bilibili.com/video/BV1RM4y117yB?share_source=copy_web">https://www.bilibili.com/video/BV1RM4y117yB?share_source=copy_web</a></p><p>视频来源于上方,为什么我们总是感觉到无聊,市因为我们的阈值越来越高了了,很难在感到高兴了. </p><h2 id="1-原因"><a href="#1-原因" class="headerlink" title="1.原因"></a>1.原因</h2><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16812861701951681286169442.png"></p><p>及时满足了乐趣,立刻产生了多巴胺,但是每一次产生的阈值都会减少,这就是为什么我们的乐趣越来越多,但会越来越感觉到无聊.(没有延迟满足,)</p><h2 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h2><p><strong>提升多巴胺基准线</strong></p><ol><li>长期每天有接触到阳光(10-20分钟的阳光散步)</li><li>充足的睡眠(减少褪黑素的摄入)</li><li>多吃芝麻,牛肉,鱼肉,奶酪</li><li>多适量的咖啡因(早上开始来喝)</li></ol><p><strong>应对多巴胺低估</strong></p><p>做更难受的事情</p><ol><li>洗冷水澡</li><li>健身</li><li>看书(比当前更难受)</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对抗无聊&quot;&gt;&lt;a href=&quot;#对抗无聊&quot; class=&quot;headerlink&quot; title=&quot;对抗无聊&quot;&gt;&lt;/a&gt;对抗无聊&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1RM4y117yB?share_sou</summary>
      
    
    
    
    
    <category term="心理学" scheme="http://yoursite.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>mitos</title>
    <link href="http://yoursite.com/2023/04/06/mitos/"/>
    <id>http://yoursite.com/2023/04/06/mitos/</id>
    <published>2023-04-06T14:24:59.000Z</published>
    <updated>2023-04-29T02:41:24.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-S081"><a href="#6-S081" class="headerlink" title="6.S081"></a>6.S081</h1><p>这是mit的公开课，使用xv6来自己实现一个小的操作系统。</p><h2 id="0-预备环节"><a href="#0-预备环节" class="headerlink" title="0.预备环节"></a>0.预备环节</h2><h3 id="0-1安装linux"><a href="#0-1安装linux" class="headerlink" title="0.1安装linux"></a>0.1安装linux</h3><p>本人直接使用的是wsl，安装的是debian系统，可以参照官网的实验步骤。唯一的坑点就是git残酷使用的ssh，不知道是梯子问题，还是校园网问题，一直git不了，课允许lan，一直没有反应，最后还是直接在windows下使用git http才弄下来。</p><h3 id="0-2安装vscode"><a href="#0-2安装vscode" class="headerlink" title="0.2安装vscode"></a>0.2安装vscode</h3><p>vscode主要是讲解如何来配置wsl。需要安装2个插件，一个wsl还有一个是c语言插件。然后重点就是下面三个文件的配置，一个task，一个launch，还有一个是c++——properties，参考下面的连接</p><p><a href="https://code.visualstudio.com/docs/cpp/config-wsl">Visual Studio Code 中的 Linux C++ 和 Windows 子系统入门</a></p><ol><li>tasks。json（配置编译器的位置，还有编译时候所需要的参数-o，-g</li><li>这个是调试选项launch，这个是放入gdb的，有工作目录，还有调试的程序</li><li>最后一个properties就是配置gcc还有gdb的位置</li></ol><h2 id="1-lab-util"><a href="#1-lab-util" class="headerlink" title="1.lab util"></a>1.lab util</h2><p><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/util.html">Lab: Xv6 and Unix utilities (mit.edu)</a></p><p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec01-introduction-and-examples">Lec01 Introduction and Examples (Robert) - MIT6.S081 (gitbook.io)</a></p><p><a href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c1/s0.html">第一章 操作系统接口 · 6.S081 All-In-One (dgs.zone)</a></p><p><a href="https://blog.rayzhang.top/2022/06/27/mit-6.s081-lab-util/">MIT 6.S081 Lab Util 实验 | Ray’s Blog (rayzhang.top)</a></p><p>本次实验主要参考以上四个网站,视频没有看,直接看的博主翻译的文稿,感觉翻译的文稿比视频好很多.</p><p>考研的时候学过操作系统了的,就没怎么看视频,直接找的几个重点章节看了一下.现在复习一下基础知识.</p><p><a href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c1/s0.html">第一章 操作系统接口 · 6.S081 All-In-One (dgs.zone)</a></p><p>直接看这本书就行,主要第一张江的是进程相关的内容,应该算进程管理吧.</p><h3 id="1-1进程和内存"><a href="#1-1进程和内存" class="headerlink" title="1.1进程和内存"></a>1.1进程和内存</h3><p>用户态通过调用内核态的fork接口来进行创建内存,对于子进程来讲,自己的pid是0,但是对于父进程来讲,自己的pid是大于0的,因此,我们考研来进行判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fork()在父进程中返回子进程的PID</span></span><br><span class="line"><span class="comment">// 在子进程中返回0</span></span><br><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">    pid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个是会反应两个结果的,一个是父进程输出parent,通过调用fork达到子进程,此时自己的pid是0,所以输出child</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent: child=1234</span><br><span class="line">child: exiting</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时我们可以使用exec来执行相关shell命令,直接在用户太执行.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char* argv[3];</span><br><span class="line">argv[0] = &quot;echo&quot;;</span><br><span class="line">argv[1] = &quot;hello&quot;;</span><br><span class="line">argv[2] = 0;</span><br><span class="line">exec(&quot;/bin/echo&quot;, argv);</span><br><span class="line">printf(&quot;exec error\n&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-2-I-x2F-O和文件描述符"><a href="#1-2-I-x2F-O和文件描述符" class="headerlink" title="1.2 I&#x2F;O和文件描述符"></a>1.2 I&#x2F;O和文件描述符</h3><p>主要讲的是io的读取和写入的api使用,使用write还有read.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span> buf);</span><br></pre></td></tr></table></figure><p>0代表标准输入流,就是我们输入的东西,buf就是要接受储存的字符串,最后一个是长度,我要接受多长的字符串.</p><p>同理,write就是写入,这个是写入到标准输出流.第一个是要写的保存的地方,然后就是要写的字符串,还有长度.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><h3 id="1-3-管道"><a href="#1-3-管道" class="headerlink" title="1.3 管道"></a>1.3 管道</h3><p>管道就是用于进程通信的,一个用来读取,一个写入 .只能单向联通,半双工.写入的时候读取必须关闭.</p><p>使用方法就是创建一个二位数组,通过pipe来进行调用创建管道,使用close来关闭管道一端然后调用上次的read还有write方法来进行读取还有写入.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序调用<code>pipe</code>，创建一个新的管道，并在数组p中记录读写文件描述符。在<code>fork</code>之后，父子进程都有指向管道的文件描述符。子进程调用<code>close</code>和<code>dup</code>使文件描述符0指向管道的读取端（前面说过优先分配最小的未使用的描述符），然后关闭p中所存的文件描述符，并调用<code>exec</code>运行<code>wc</code>。当<code>wc</code>从它的标准输入读取时，就是从管道读取。父进程关闭管道的读取端，写入管道，然后关闭写入端。</p><blockquote><p>接起来。然后对管道的左端调用<code>fork</code>和<code>runcmd</code>，对管道的右端调用<code>fork</code>和<code>runcmd</code>，并等待两者都完成。管道的右端可能是一个命令，该命令本身包含一个管道(例如，<code>a | b | c</code>)，该管道本身<code>fork</code>为两个新的子进程(一个用于b，一个用于c)。因此，shell可以创建一个进程树。这个树的叶子是命令，内部节点是等待左右两个子进程完成的进程。</p></blockquote><p>队友左右节点都是自己进行创建一个新的fork然后执行之后来返回</p><h3 id="1-4-文件系统"><a href="#1-4-文件系统" class="headerlink" title="1.4 文件系统"></a>1.4 文件系统</h3><p>文件系统就是文件分为文件还有文件夹,文件夹是一个特殊的数据结构,里面包含当前文件夹的所有名称还有他的大小.</p><p>通过调用这个方法来得到答案</p><p>这个stat是类型,如果是文件夹还有一个数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR 1    <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE 2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE 3 <span class="comment">// Device</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> dev;     <span class="comment">// 文件系统的磁盘设备</span></span><br><span class="line">    uint ino;    <span class="comment">// Inode编号</span></span><br><span class="line">    <span class="type">short</span> type;  <span class="comment">// 文件类型</span></span><br><span class="line">    <span class="type">short</span> nlink; <span class="comment">// 指向文件的链接数</span></span><br><span class="line">    uint64 size; <span class="comment">// 文件字节数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-5实验"><a href="#1-5实验" class="headerlink" title="1.5实验"></a>1.5实验</h3><h4 id="1-5-1boot"><a href="#1-5-1boot" class="headerlink" title="1.5.1boot"></a>1.5.1boot</h4><p>启动过程,首先就是git’数据,直接登录网页使用github来进行下载,使用ssh一直卡死.之后切换分支到util就行,然后执行 make qemu.毕竟这个实验是在qemu上进行模拟的</p><h4 id="1-5-2sleep-easy"><a href="#1-5-2sleep-easy" class="headerlink" title="1.5.2sleep (easy)"></a>1.5.2sleep (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h4><p>实现sleep函数.我们可以根据下面提示来进行做</p><blockquote><ul><li>Before you start coding, read Chapter 1 of the <a href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">xv6 book</a>.</li><li>Look at some of the other programs in <code>user/</code> (e.g., <code>user/echo.c</code>, <code>user/grep.c</code>, and <code>user/rm.c</code>) to see how you can obtain the command-line arguments passed to a program.</li><li>If the user forgets to pass an argument, sleep should print an error message.</li><li>The command-line argument is passed as a string; you can convert it to an integer using <code>atoi</code> (see user&#x2F;ulib.c).</li><li>Use the system call <code>sleep</code>.</li><li>See <code>kernel/sysproc.c</code> for the xv6 kernel code that implements the <code>sleep</code> system call (look for <code>sys_sleep</code>), <code>user/user.h</code> for the C definition of <code>sleep</code> callable from a user program, and <code>user/usys.S</code> for the assembler code that jumps from user code into the kernel for <code>sleep</code>.</li><li>Make sure <code>main</code> calls <code>exit()</code> in order to exit your program.</li><li>Add your <code>sleep</code> program to <code>UPROGS</code> in Makefile; once you’ve done that, <code>make qemu</code> will compile your program and you’ll be able to run it from the xv6 shell.</li><li>Look at Kernighan and Ritchie’s book <em>The C programming language (second edition)</em> (K&amp;R) to learn about C.</li></ul></blockquote><p>看ls是如何获取到参数的,如果没有参数,直接反悔哦失败,传递的参数是字符串,你需要使用atoi,直接使用系统调用的sleep功能.然后调用exit来推出这个程序.最后把这个给功能加入到makefile里面.</p><p>上面已经给出了了具体思路,我们只需要写代码就行.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: sleep &lt;ticks&gt;\n&quot;</span>);  <span class="comment">//参数数量不正确，打印错误信息</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> time = atoi(argv[<span class="number">1</span>]);  <span class="comment">//使用atoi转换，见user.h和ulib.c</span></span><br><span class="line">    sleep(time);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>argc是参数个数,argv是参数字符串列表,如果c&lt;2就是不合法,然后直接进行执行调用系统api.之后就是加入到makefile里面.</p><h4 id="1-5-3pingpong-easy"><a href="#1-5-3pingpong-easy" class="headerlink" title="1.5.3pingpong (easy)"></a>1.5.3pingpong (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h4><p>实现pingpong功能就是,具体要求就是两个管道,一个父亲写,儿子读取,一个儿子读取谷歌的父亲管道,然后写入到自己的管道,父亲来读取.使用wait可以保真先后顺序.</p><blockquote><p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</pid></pid></pid></p></blockquote><blockquote><ul><li>Use <code>pipe</code> to create a pipe.</li><li>Use <code>fork</code> to create a child.</li><li>Use <code>read</code> to read from the pipe, and <code>write</code> to write to the pipe.</li><li>Use <code>getpid</code> to find the process ID of the calling process.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li><li>User programs on xv6 have a limited set of library functions available to them. You can see the list in <code>user/user.h</code>; the source (other than for system calls) is in <code>user/ulib.c</code>, <code>user/printf.c</code>, and <code>user/umalloc.c</code>.</li></ul></blockquote><p>根据上面提示,使用pipe创建两个管道,然后使用fork创建孩子进程,之后是以哦那个read来读取,和write来写入.注意要进行关闭管道的一端.只允许单项流通.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[] = &#123;<span class="string">&#x27;P&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> parent2child[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> child2parent[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(parent2child) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create pipe parent2child\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(child2parent) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create pipe child2parent\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();  <span class="comment">// create child process</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create the child process!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child process, read from pipe parent2child,</span></span><br><span class="line">        <span class="comment">// write to pipe child2parent</span></span><br><span class="line">        close(parent2child[<span class="number">1</span>]);</span><br><span class="line">        close(child2parent[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (read(parent2child[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Child: Failed to read from pipe parent2child!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">        <span class="keyword">if</span> (write(child2parent[<span class="number">1</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Child: Failed to write to pipe child2parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent process, write to pipe parent2child,</span></span><br><span class="line">        <span class="comment">// read from pipe child2parent</span></span><br><span class="line">        close(parent2child[<span class="number">0</span>]);</span><br><span class="line">        close(child2parent[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (write(parent2child[<span class="number">1</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Failed to write to pipe parent2child!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (read(child2parent[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to read from pipe child2parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先if的是孩子进程,所以我们关闭父亲写入的,来进行读取,同时关闭孩子的读取来进行写入,把读取的写入到矮子里面.之后就是父亲,父亲是自己先进行写入,然后读取孩子的,也要进行关闭程序.</p><h4 id="1-5-4primes-moderate-x2F-hard"><a href="#1-5-4primes-moderate-x2F-hard" class="headerlink" title="1.5.4primes (moderate)&#x2F;(hard)"></a>1.5.4primes (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)&#x2F;(<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</h4><blockquote><h4 id="write-a-concurrent-version-of-prime-sieve-using-pipes-This-idea-is-due-to-Doug-McIlroy-inventor-of-Unix-pipes-The-picture-halfway-down-this-page-and-the-surrounding-text-explain-how-to-do-it-Your-solution-should-be-in-the-file-user-primes-c"><a href="#write-a-concurrent-version-of-prime-sieve-using-pipes-This-idea-is-due-to-Doug-McIlroy-inventor-of-Unix-pipes-The-picture-halfway-down-this-page-and-the-surrounding-text-explain-how-to-do-it-Your-solution-should-be-in-the-file-user-primes-c" class="headerlink" title="write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user/primes.c."></a>write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</h4></blockquote><p>题目要求,并发使用管道来进行读取输出2-35的素数.思路是一个写入2-35的管道,另外一个管道来进行输出.</p><blockquote><ul><li>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</li><li>Once the first process reaches 35, it should wait until the entire pipeline terminates, including all children, grandchildren, &amp;c. Thus the main primes process should only exit after all the output has been printed, and after all the other primes processes have exited.</li><li>Hint: <code>read</code> returns zero when the write-side of a pipe is closed.</li><li>It’s simplest to directly write 32-bit (4-byte) <code>int</code>s to the pipes, rather than using formatted ASCII I&#x2F;O.</li><li>You should create the processes in the pipeline only as they are needed.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li></ul></blockquote><p>这个提示没什么用,直接看的大佬的版本,思路就是使用快速筛,蠡口上有讲解.主要思路就是第一遍把2的倍数全被设置true,剩下的从false里面读取,如果是当前的倍数的,也设置成true,指导到最后一个值.(这个给可以使用并发执行).</p><blockquote><p>所以这个问题就像是流水线一样，第一个进程将 <code>2~n</code> 依次写给第二个进程，第二个进程筛选非 <code>2</code> 倍数的数输出给第三个进程，第三个进程筛选非 <code>3</code> 倍数的数给第四个进程… 以此类推，单个阶段不一定要全部做完才交给后一阶段，完全可以像流水线一样进行。</p><p>我们的目标是使用 <code>pipe</code> 和 <code>fork</code> 来实现这样的流水线，我们将处理 <code>2~35</code> 的数字，进行素数筛。由于 xv6 的文件描述符和进程数量有限，第一个进程可以在 <code>35</code> 时停止。</p></blockquote><p>使用wait来保真先后顺序,父亲之后才是孩子.在每一个管道的最后一端加入-1,代表管道内容已经结束了.</p><p>整体代码,蠡口刷多了,写起来不是会很费力的.读取老的管道,同时把数字写入到新的管道,创建新进程调用新的管道作为输入,注意也要在最后加入-1作为结尾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prime_num 35</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_child</span><span class="params">(<span class="type">int</span> *read_pipe)</span> &#123;</span><br><span class="line">    close(read_pipe[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> n, status;</span><br><span class="line">    <span class="keyword">if</span> ((status = read(read_pipe[<span class="number">0</span>], &amp;n, <span class="keyword">sizeof</span>(<span class="type">int</span>))) == <span class="number">0</span>) &#123; <span class="comment">// fetch the first number in the row</span></span><br><span class="line">        close(read_pipe[<span class="number">0</span>]);  <span class="comment">// no more numbers in the pipeline</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(status == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to read from pipe!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, n);  <span class="comment">// print out the first number as the prime</span></span><br><span class="line">    <span class="type">int</span> parent_pipe[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(parent_pipe) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create pipe!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create child process!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(read_pipe[<span class="number">0</span>]);</span><br><span class="line">        run_child(parent_pipe);  <span class="comment">// receive number in the new child process</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(parent_pipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="keyword">while</span> ((status = read(read_pipe[<span class="number">0</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">// filter and send numbers to new child process</span></span><br><span class="line">            <span class="keyword">if</span> (num % n != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(write(parent_pipe[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to write to pipe!\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(status == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to read from pipe!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(parent_pipe[<span class="number">1</span>]);</span><br><span class="line">        wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> input_pipe[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(input_pipe) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create pipe!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create child process!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        run_child(input_pipe); <span class="comment">// child process to filter the numbers</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(input_pipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= prime_num; i++) &#123; <span class="comment">// send 2~35 to the child process</span></span><br><span class="line">            <span class="keyword">if</span>(write(input_pipe[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to write to pipe!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(input_pipe[<span class="number">1</span>]);</span><br><span class="line">        wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-5find-moderate"><a href="#1-5-5find-moderate" class="headerlink" title="1.5.5find (moderate)"></a>1.5.5find (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h4><p>实现查找功能</p><blockquote><ul><li>Look at user&#x2F;ls.c to see how to read directories.</li><li>Use recursion to allow find to descend into sub-directories.</li><li>Don’t recurse into “.” and “..”.</li><li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li><li>You’ll need to use C strings. Have a look at K&amp;R (the C book), for example Section 5.5.</li><li>Note that &#x3D;&#x3D; does not compare strings like in Python. Use strcmp() instead.</li><li>Add the program to <code>UPROGS</code> in Makefile</li></ul></blockquote><p>提示是要我们区看ls的实现,ls把通过switch来对不同的来做判断,我们的现在要求就是根据判断末尾是不是要查找的目标,来进行输出.那么这一个题目就是变成字符串的截取题目.因为对c不是很熟.所以对这个题的代码卡了很久.char *a&#x3D;p.a&#x3D;a+strlen(a).这个意思是把a得到位置移动到最末尾,通过这样就变成截取字符串的操作.</p><ol><li>首先对与目标我们加上&#x2F;,因为每一个文件都是&#x2F;a&#x2F;a&#x2F;b这样的</li><li>然后我们使用ls一样的测策略,对于文件,移动到和目标文件一样长的地方,看他们想不想等,相等就进行输出</li><li>对于文件夹,我们使用递归,但是对于&#x2F;..还有&#x2F;.这个文件夹我们就不在进行递归 </li><li></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory is a file containing a sequence of dirent structures.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>文件夹的数据结构</p><p>实现代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="comment">// Find first character after last slash.</span></span><br><span class="line">    <span class="keyword">for</span> (p = path + <span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">        ;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//返回末尾的文件名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *directory, <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(directory, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot open %s\n&quot;</span>, directory);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot stat %s\n&quot;</span>, directory);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123; <span class="comment">//查看路径类型</span></span><br><span class="line">        <span class="keyword">case</span> T_FILE: <span class="comment">//是文件</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(fmtname(directory), filename) == <span class="number">0</span>) &#123; <span class="comment">//比较路径末尾文件名和查找的文件名</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>, directory);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_DIR: <span class="comment">//是目录</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strlen</span>(directory) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;find: path is too long \n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(buf, directory);</span><br><span class="line">            p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">            *p++ = <span class="string">&#x27;/&#x27;</span>; <span class="comment">//拼凑当前目录路径</span></span><br><span class="line">            <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123; <span class="comment">//遍历目录</span></span><br><span class="line">                <span class="keyword">if</span> (de.inum == <span class="number">0</span> || <span class="built_in">strcmp</span>(<span class="string">&quot;.&quot;</span>, de.name) == <span class="number">0</span> ||</span><br><span class="line">                    <span class="built_in">strcmp</span>(<span class="string">&quot;..&quot;</span>, de.name) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                memmove(p, de.name, DIRSIZ); <span class="comment">//拼凑当前文件路径</span></span><br><span class="line">                p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (stat(buf, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                find(buf, filename); <span class="comment">//调用find递归查找</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: find &lt;directory&gt; &lt;filename&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-lab-syscall"><a href="#2-lab-syscall" class="headerlink" title="2.lab syscall"></a>2.lab syscall</h2><p><a href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c2/s2.html">2.2 用户态，核心态，以及系统调用 · 6.S081 All-In-One (dgs.zone)</a></p><p>操作系统的作用是抽象系统同资源,最基本的目的就是互不影响程序,当一个程序出现问题不会影响下一个程序.所以系统管理员是操作系统,他与硬件打交道.</p><h3 id="2-2用户态，核心态，以及系统调用"><a href="#2-2用户态，核心态，以及系统调用" class="headerlink" title="2.2用户态，核心态，以及系统调用"></a>2.2用户态，核心态，以及系统调用</h3><p>用户态和和心态,和心态就是直接与硬件打交道的</p><p>核心态可以使用特权指令,用户通过条用内核函数的程序,把用户态转移到和心态,然后 在内核指定的路口,进入内核(ecall函数)需要写entry(write),然后通过设置一个数字作为这个函数的映射,内核太调用这个数字实际对那个内核里面的函数来实现方法</p><p><img src="https://blog.rayzhang.top/2022/07/05/mit-6.s081-lab-syscall/syscall_fork.png"></p><p>syscall调用sysproc实际方法</p><h3 id="2-3内核组织"><a href="#2-3内核组织" class="headerlink" title="2.3内核组织"></a>2.3内核组织</h3><p>分为大内核还有小内核,大内核就是和Windows差不多,所以的硬件功能都已经实现,小内核就是自己要实现文件这中内核操作,通过组合操作.</p><h3 id="2-4进程"><a href="#2-4进程" class="headerlink" title="2.4进程"></a>2.4进程</h3><p>进程都有自己的结构体,有自己的状态,还有自己的页表(页表,就是一个进程的虚拟地址空间)</p><h3 id="2-5实验"><a href="#2-5实验" class="headerlink" title="2.5实验"></a>2.5实验</h3><h4 id="2-5-1System-call-tracing-moderate"><a href="#2-5-1System-call-tracing-moderate" class="headerlink" title="2.5.1System call tracing (moderate)"></a>2.5.1System call tracing (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h4><p>实现追踪功能,然后追踪的进程的mask是这样得到 <code>trace(1 &lt;&lt; SYS_fork)</code>,这个参数可以通过argint得到</p><blockquote><ul><li>Add <code>$U/_trace</code> to UPROGS in Makefile</li><li>Run make qemu and you will see that the compiler cannot compile <code>user/trace.c</code>, because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. Once you fix the compilation issues, run trace 32 grep hello README; it will fail because you haven’t implemented the system call in the kernel yet.</li><li>Add a <code>sys_trace()</code> function in <code>kernel/sysproc.c</code> that implements the new system call by remembering its argument in a new variable in the <code>proc</code> structure (see <code>kernel/proc.h</code>). The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, and you can see examples of their use in <code>kernel/sysproc.c</code>.</li><li>Modify <code>fork()</code> (see <code>kernel/proc.c</code>) to copy the trace mask from the parent to the child process.</li><li></li></ul></blockquote><p>给定的提示,我们直接运行make是无法编译成功的.提示是因为无法编译trace.c,因为这个给用户态的功能trace在内核态没有对应实现,我们需要实现.首先就是在userh里面添加trace功能(申明,系统提供的api).之后区usys添加入口,这是上面的陷入,然后添加一个数值在syscall</p><blockquote><p>because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. </p></blockquote><p>尽管添加了之后,你还是没有办法实现,因为你要实现systrace功能在sysproc里面,我们需要把追踪的进程的掩码设置成传入的参数,通过argint得到mask,之后对于该进程创建的子进程,我们也许奥把掩码设置成先对应的mask(复制操作,只需要更改fork的逻辑就行),最后我们把掩码一样的在syscall里进行输出.</p><p><strong>这个题的主要重点,就是让我们了解到系统调用的流程,首先是在user里面注册系统调用函数,然后通过entry进行陷入这个函数,之后调用特殊的数值,来作为系统调用的参数.然后我们在sysproc具体实现这个功能</strong></p><p>主要 的流程就是上图所示</p><blockquote><p>所以，需要有一种方式能够让应用程序可以将控制权转移给内核（Entering Kernel）。</p><p>在RISC-V中，有一个专门的指令用来实现这个功能，叫做ECALL。ECALL接收一个数字参数，当一个用户程序想要将程序执行的控制权转移到内核，它只需要执行ECALL指令，并传入一个数字。这里的数字参数代表了应用程序想要调用的System Call。</p><p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MJX963vbIPHKetjGrZN%2F-MJXAkJxD8pTZOm1Tay_%2Fimage.png?alt=media&token=cf3e26a2-3c26-43b8-aee0-6d5787f8dcf5" alt="img"></p><p>ECALL会跳转到内核中一个特定，由内核控制的位置。我们在这节课的最后可以看到在XV6中存在一个唯一的系统调用接入点，每一次应用程序执行ECALL指令，应用程序都会通过这个接入点进入到内核中。举个例子，不论是Shell还是其他的应用程序，当它在用户空间执行fork时，它并不是直接调用操作系统中对应的函数，而是调用ECALL指令，并将fork对应的数字作为参数传给ECALL。之后再通过ECALL跳转到内核。</p><p>下图中通过一根竖线来区分用户空间和内核空间，左边是用户空间，右边是内核空间。在内核侧，有一个位于syscall.c的函数syscall，每一个从应用程序发起的系统调用都会调用到这个syscall函数，syscall函数会检查ECALL的参数，通过这个参数内核可以知道需要调用的是fork（3.9会有相应的代码跟踪介绍）。</p><p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MJX963vbIPHKetjGrZN%2F-MJXO2n90L0ziqU8mTcg%2Fimage.png?alt=media&token=754f49c1-58a2-42d5-9427-094fc95ab613" alt="img"></p></blockquote><ol><li>在makefile进行注册</li><li>在user里面进行注册函数trace在sys里面进行进入entry</li><li>之后在syscall里面进行设置特殊的数值</li><li>然后调用这个sys_trace,之后在sysproc里实现(思路就是调用新的trace函数)</li><li>trace函数就是把当前mask传给当前进程</li><li>然后在syscall调用,调用结束后.我们来对这个掩码做比较,相同就进行输出</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>) &#123;  <span class="comment">//获取trace的参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;               <span class="comment">//获取失败返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trace(mask);  <span class="comment">//调用核心函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个trace函数还需要在defs进行申明,不然没发实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span> mask)</span> &#123; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;mask = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对fork的修改,就是把父进程的mask传授那个给子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br><span class="line">  np-&gt;cwd = idup(p-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">  np-&gt;mask = p-&gt;mask; <span class="comment">//复制mask掩码</span></span><br><span class="line"></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line"></span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;wait_lock);</span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line">  release(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;np-&gt;lock);</span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后根据提示,我们在这里进行符合的输出</p><blockquote><p>The 32 is <code>1&lt;&lt;SYS_read</code>. In the second exam</p></blockquote><p>他的逻辑就是把这个给进程进行移动系统的位数,所以我们只要一回来,然后与1,还是1,就说明这个是需要最终的,我们就进行输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(p-&gt;mask &gt;&gt; num &amp; 1) &#123;</span><br><span class="line">      printf(&quot;%d: syscall %s -&gt; %d\n&quot;,p-&gt;pid, syscalls_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;mask &gt;&gt; num &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid, syscalls_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-lab-pgtble"><a href="#3-lab-pgtble" class="headerlink" title="3.lab pgtble"></a>3.lab pgtble</h2><h4 id="3-2修改页表"><a href="#3-2修改页表" class="headerlink" title="3.2修改页表"></a>3.2修改页表</h4><p>xv6原始是每个程序共享一个页表,现在要求是自己为每一个程序添加页表,陷入时候使用自己的页表</p><h2 id="4-lab-trap"><a href="#4-lab-trap" class="headerlink" title="4.lab trap"></a>4.lab trap</h2><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h3 id="4-1回答问题"><a href="#4-1回答问题" class="headerlink" title="4.1回答问题"></a>4.1回答问题</h3><p>Read the code in call.asm for the functions <code>g</code>, <code>f</code>, and <code>main</code>. The instruction manual for RISC-V is on the <a href="https://pdos.csail.mit.edu/6.S081/2020/reference.html">reference page</a>. Here are some questions that you should answer (store the answers in a file answers-traps.txt):</p><blockquote><p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</p></blockquote><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816327874591681632783414.png"></p><p>a2</p><blockquote><p>Where is the call to function <code>f</code> in the assembly code for <code>main</code>? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</p></blockquote><p>显的可以看到在 <code>0x26</code> 位置，程序直接将 <code>12</code> 写入了 <code>a1</code> 寄存器的位置（也就是第二参数 <code>f(8)+1</code> 的位置），在处理完所有的寄存器参数后直接就调用了 <code>printf</code>。那只有一种解释，就是编译器直接计算出了 <code>f(8)+1</code> 的结果是 <code>12</code>，主函数中并没直接调用这两个函数</p><blockquote><p> At what address is the function <code>printf</code> located?</p></blockquote><p>根据提示他在628，我们直接收地址628</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816337731131681633772533.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816338091161681633808486.png"></p><blockquote><p>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</p></blockquote><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816340951881681634095159.png"></p><p><img src="https://blog.rayzhang.top/2022/09/27/mit-6.s081-lab-traps/jalr.png" alt="img"></p><p>34是pc地址，后面的是指令，手册的pc+4，就是34+4&#x3D;38是ra</p><blockquote><p>Run the following code.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">printf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br><span class="line">     </span><br></pre></td></tr></table></figure><p>What is the output? <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set to in order to yield the same output? Would you need to change to a different value?<code>i``57616</code></p><p><a href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p></blockquote><p>57616十六进制是e110</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816344351111681634434489.png"></p><p>下一个是小段对齐（就是最开始第一位是末尾2个字节，最后的才是开始）</p><p><img src="https://blog.rayzhang.top/2022/09/27/mit-6.s081-lab-traps/hello-world.jpeg" alt="img"></p><blockquote><p>In the following code, what is going to be printed after ? (note: the answer is not a specific value.) Why does this happen? <code>&#39;y=&#39;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;x=%d y=%d&quot;, 3);</span><br></pre></td></tr></table></figure></blockquote><p>a2寄存器没有值，随便产生</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-S081&quot;&gt;&lt;a href=&quot;#6-S081&quot; class=&quot;headerlink&quot; title=&quot;6.S081&quot;&gt;&lt;/a&gt;6.S081&lt;/h1&gt;&lt;p&gt;这是mit的公开课，使用xv6来自己实现一个小的操作系统。&lt;/p&gt;
&lt;h2 id=&quot;0-预备环节&quot;&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="公开课" scheme="http://yoursite.com/tags/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>深度学习代码小结</title>
    <link href="http://yoursite.com/2023/03/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2023/03/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%B0%8F%E7%BB%93/</id>
    <published>2023-03-16T12:03:58.000Z</published>
    <updated>2023-03-16T13:42:37.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-预备知识"><a href="#0-预备知识" class="headerlink" title="0.预备知识"></a>0.预备知识</h1><p>收先我们知道，一般大型公司都有一台机器才能够外网访问，其他机器都只能访问内网，我们把进行外网访问的机器称为跳板机，他的作用就是，我们通过这个机器来远程俩连接到内网的跳板机，然后再这个跳板机上进行连接到真正的内网机器。我们可以使用端口转发，ssh -N来进行转发内网得到机器端口到本地的机器端口，可以转发内网机器node5的端口准发到我自己的windows的 10086端口，字样，我们如果需要连接到内网的机器node5，就不需要通过跳板机连接。<strong>注意，如果需要使用之恩重方案，一般都需要把自己的公钥上传到跳板机还有内网机器上的authority——key’才可以，等待我们自己的机器进行重亲就可以</strong>。以后我们只需要下面代码就可以连接node5机器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 1008600 root@localhost</span><br></pre></td></tr></table></figure><p>本文是首先讲解的是如何进行远程连接，所以作为预备知识。目前远程连接主要是是使用以下两种方案，一种是vscode的 remote ssh还有一种是使用jetbrain 的gateway。下面介绍这两种方案：</p><p>1.vscode进行连接.我们只需要在上面我们已近做好的内网转发上面，进行新建一个vscode远程连接，输入我们 远程连接的上述代码，然后选择我们需要的项目目录就可以了。此时，我们还需要进行设置python解释器，我们一般都是使用自己的虚拟环境，我们我们找到自己虚拟环境所在的vene包里面，然后进行选择到python，就可以了，</p><p>主要优点：连接消耗的内存就比较少，但是代码补全还有debug能力不如gateway。一般我们可以直接在vscode进行修改，然后直接在windterm里面来进行执行代码，使用screen</p><p>2.使用gateway，这个就是jetbrain推出的远程pycharm，可以这么理解，相当于，我们前端只是进行修改 代码，但是真正的操作都是在服务器的后端服务器上，只不过，这个gateway也还是需要授权才可以使用的，我使用的是教育邮箱，所以可以进行使用。</p><p>优点：和我们之前在自己电脑使用pycharm一样，但是由于使用的是远程连接，会造成服务器不稳定，偶尔出现多次断链的情况，也会出现卡死服务器cpu的情况。但是一般都是比较正常（推荐使用gateway）</p><h1 id="1-datasets方面"><a href="#1-datasets方面" class="headerlink" title="1.datasets方面"></a>1.datasets方面</h1><p>深度学习的第一步就是学习如何写数据集,对于深度学习现在已经变成搭积木的游戏,我们只需要根据之前的官网文件,来对我们的自定义我们的数据集，我们只有知道我们的输入输出后，才可以定制自己的模型。由于我们的是分类模型，所以我们的输入是图片的tensor，输出是图片的类型，使用数字就可以。</p><p>对于这个数据集获取器，我们可以使用继承nn的datasets来实现，需要我们写的只有三个函数，一个init，一个len，还有一个getitem。</p><p>下面是通用得到实现方法：</p><blockquote><p>在此之前我们自己制作一个通用的csv，奇艺列是图片的地址，第二列就是属性值，我们的dataset就只需要从csv来读取图片还有表示，就可以了，主要使用load——csv来进行读取csv</p></blockquote><ol><li>首先写init，需要传入的参数有，resize，mode，path，三个是图片的大小，当前是什么模式，还有一个是csv存在的地址，之后我们就进行切割数据集，使用6:2:2来进行切分，主要思路，就是把从loadcsv得到完整的列表，然后进行切分</li><li>之后就是getitem，我们只需要按照给定的idx，返回对应的图片还有属性值就可以，一般transform可以在外面写好，也可以在dataset你写好，使用transform来进行组合所需要的操作，然后对图片来进行执行就可以了，最后返回图片还有属性值</li><li>返回len只需要返回图片列表长度就可以</li></ol><p>这是最简单的dataset，我们只需要想明白我们需要的输入还有输出到底是什么就可以了，然后重点就是如何得到这个csv表格，我们可以使用os还有glob这些包来进行对文件夹操作，然后放入到csv里面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.resize = resize</span><br><span class="line">    self.mode = mode</span><br><span class="line">    self.cur_images ,self.syn_images,self.labels = self.load_csv(<span class="string">&#x27;./p2p.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#划分训练集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&quot;train&quot;</span>:</span><br><span class="line">        self.cur_images = self.cur_images[:<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.cur_images))]</span><br><span class="line">        self.syn_images = self.syn_images[:<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.syn_images))]</span><br><span class="line">        self.labels = self.labels[:<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.labels))]</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">&#x27;val&#x27;</span>:  <span class="comment"># 20% = 60%-&gt;80%</span></span><br><span class="line">        self.cur_images = self.cur_images[<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.cur_images)):<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.cur_images))]</span><br><span class="line">        self.syn_images = self.syn_images[<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.syn_images)):<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.syn_images))]</span><br><span class="line">        self.labels = self.labels[<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.labels)):<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.labels))]</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">&#x27;test&#x27;</span>:  <span class="comment"># 20% = 80%-&gt;9999%</span></span><br><span class="line">        self.cur_images = self.cur_images[<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.cur_images)):<span class="built_in">int</span>(<span class="number">0.99999</span> * <span class="built_in">len</span>(self.cur_images))]</span><br><span class="line">        self.syn_images = self.syn_images[<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.syn_images)):<span class="built_in">int</span>(<span class="number">0.99999</span> * <span class="built_in">len</span>(self.syn_images))]</span><br><span class="line">        self.labels = self.labels[<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.labels)):<span class="built_in">int</span>(<span class="number">0.99999</span> * <span class="built_in">len</span>(self.labels))]</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">         <span class="keyword">def</span> <span class="title function_">load_csv</span>(<span class="params">self, data_csv</span>):</span><br><span class="line">    cur_img = []</span><br><span class="line">    syn_img = []</span><br><span class="line">    labels = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(data_csv, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        reader = csv.reader(f)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">            old, new, label = row</span><br><span class="line">            label = <span class="built_in">int</span>(label)</span><br><span class="line">            cur_img.append(old)</span><br><span class="line">            syn_img.append(new)</span><br><span class="line">            labels.append(label)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(syn_img) == <span class="built_in">len</span>(cur_img)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(labels) == <span class="built_in">len</span>(syn_img)</span><br><span class="line">    <span class="keyword">return</span> cur_img, syn_img, labels</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(self.labels)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">    img, syn_image,label = self.cur_images[idx],self.syn_images[idx], self.labels[idx]</span><br><span class="line"></span><br><span class="line">    tf_cnn = transforms.Compose([</span><br><span class="line">        <span class="keyword">lambda</span> x:Image.<span class="built_in">open</span>(x).convert(<span class="string">&#x27;RGB&#x27;</span>),  <span class="comment"># string path= &gt; image data</span></span><br><span class="line">        transforms.Resize((<span class="built_in">int</span>(self.resize*<span class="number">1.25</span>), <span class="built_in">int</span>(self.resize*<span class="number">1.25</span>))),</span><br><span class="line">        transforms.RandomRotation(<span class="number">15</span>),</span><br><span class="line">        transforms.CenterCrop(self.resize),</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],</span><br><span class="line">                             std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    ])</span><br><span class="line">    tf_swin = transforms.Compose([</span><br><span class="line">        <span class="keyword">lambda</span> x: Image.<span class="built_in">open</span>(x).convert(<span class="string">&#x27;RGB&#x27;</span>),  <span class="comment"># string path= &gt; image data</span></span><br><span class="line">        transforms.Resize((<span class="built_in">int</span>(<span class="number">256</span>), <span class="built_in">int</span>(<span class="number">256</span>))),</span><br><span class="line"></span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],</span><br><span class="line">                             std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    ])</span><br><span class="line">    img = tf_cnn(img)</span><br><span class="line">    syn_image1 = tf_cnn(syn_image)</span><br><span class="line">    syn_swin = tf_swin(syn_image)</span><br><span class="line">    label = torch.tensor(label)</span><br><span class="line">    <span class="keyword">return</span> img,syn_image1,syn_swin,label</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h1 id="2-模型方面"><a href="#2-模型方面" class="headerlink" title="2.模型方面"></a>2.模型方面</h1><p>模型方面，我改的比较少，只能说还是需要两个，一个是forward函数，一个init来进行初始化，我们在init进行设置所需要的cnn，fc层，设计模型架构，然后再forward里面来进行传入图片，吧图片在上面的架构走一次，我们就得到模型所产生的结果了。这个地方改的不是很多，需要日后来讲解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def forward(self, x_old, x_new):</span><br><span class="line">    x_old = self.old_features(x_old)</span><br><span class="line">    x_new = self.new_features(x_new)</span><br><span class="line">    x = x_old + x_new</span><br><span class="line">    heads = []</span><br><span class="line">    for i in range(self.num_head):</span><br><span class="line">        heads.append(getattr(self, &quot;cat_head%d&quot; % i)(x))</span><br><span class="line"></span><br><span class="line">    heads = torch.stack(heads).permute([1, 0, 2])</span><br><span class="line">    if heads.size(1) &gt; 1:</span><br><span class="line">        heads = F.log_softmax(heads, dim=1)</span><br><span class="line"></span><br><span class="line">    out = self.fc(heads.sum(dim=1))</span><br><span class="line">    out = self.bn(out)</span><br><span class="line"></span><br><span class="line">    return out, x, heads</span><br></pre></td></tr></table></figure><h1 id="3-train方面"><a href="#3-train方面" class="headerlink" title="3.train方面"></a>3.train方面</h1><p>train方面这个代码是需要我自己来进行重构的，耦合比较严重。</p><h2 id="3-1参数解析"><a href="#3-1参数解析" class="headerlink" title="3.1参数解析"></a>3.1参数解析</h2><p>首先就是设置相关的参数使用argparser来进行设置，一般我都是直接抄之前的代码，资格不需要自己修改，可以直接看绵绵这个，这个就是我们在服务器你启动代码所需在后面进行添加的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_args_parser</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(<span class="string">&#x27;MAE pre-training&#x27;</span>, add_help=<span class="literal">False</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--batch_size&#x27;</span>, default=<span class="number">200</span>, <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Batch size per GPU (effective batch size is batch_size * accum_iter * # gpus&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, default=<span class="number">200</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--accum_iter&#x27;</span>, default=<span class="number">1</span>, <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Accumulate gradient iterations (for increasing the effective batch size under memory &#x27;</span></span><br><span class="line">                             <span class="string">&#x27;constraints)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Model parameters</span></span><br><span class="line">    <span class="comment"># parser.add_argument(&#x27;--model&#x27;, default=&#x27;mae_vit_large_patch16&#x27;, type=str, metavar=&#x27;MODEL&#x27;,</span></span><br><span class="line">    <span class="comment">#                     help=&#x27;Name of model to train&#x27;)</span></span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--input_size&#x27;</span>, default=<span class="number">224</span>, <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;images input size&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Optimizer parameters</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--weight_decay&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.0001</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;weight decay (default: 0.05)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--lr&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.0001</span>, metavar=<span class="string">&#x27;LR&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;learning rate (absolute lr)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--warmup_epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">40</span>, metavar=<span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;epochs to warmup LR&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Dataset parameters</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--root_path&#x27;</span>, default=<span class="string">&#x27;/home/tonnn/.nas/weijia/datasets/face_dataset/Oulu_CASIA_NIR_VIS/NI&#x27;</span>,</span><br><span class="line">                        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;dataset path&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--output_dir&#x27;</span>, default=<span class="string">&#x27;./output_dir&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;path where to save, empty for no saving&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--pth_path&#x27;</span>, default=<span class="string">&#x27;./checkpoint/image1k/accuracy_loss_change_train_2.pth&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;path where to save, empty for no saving&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--log_dir&#x27;</span>, default=<span class="string">&#x27;./output_dir&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;path where to tensorboard log&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义的模型加载</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--seed&#x27;</span>, default=<span class="number">3407</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--resume&#x27;</span>, default=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;resume from checkpoint&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--start_epoch&#x27;</span>, default=<span class="number">77</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, metavar=<span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;start epoch&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--num_workers&#x27;</span>, default=<span class="number">8</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--pin_memory&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Pin CPU memory in DataLoader for more efficient (sometimes) transfer to GPU.&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--no_pin_mem&#x27;</span>, action=<span class="string">&#x27;store_false&#x27;</span>, dest=<span class="string">&#x27;pin_mem&#x27;</span>)</span><br><span class="line">    parser.set_defaults(pin_mem=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># distributed training parameters</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--world_size&#x27;</span>, default=<span class="number">1</span>, <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;number of distributed processes&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--local_rank&#x27;</span>, default=-<span class="number">1</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--dist_on_itp&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--dist_url&#x27;</span>, default=<span class="string">&#x27;env://&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;url used to set up distributed training&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parser</span><br></pre></td></tr></table></figure><p>上面就是需要的参数，我们可以对着上面来修改epoch还有学习率等其他内容，还有resume等，来进行加载</p><h2 id="3-2构建数据集"><a href="#3-2构建数据集" class="headerlink" title="3.2构建数据集"></a>3.2构建数据集</h2><p>我们使用函数来进行抽取构建数据集这个操作，这样，我们以后更换数据集，只需要更改build’datasest就可以了，方法还是和之前一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_datasets</span>(<span class="params">mode, args</span>):</span><br><span class="line">    dataset = FaceEmotionRecognize(args.root_path, args.input_size, mode)</span><br><span class="line">    <span class="keyword">return</span> dataset</span><br></pre></td></tr></table></figure><p>上面那个face可以换成其他任意的dataset</p><h2 id="3-3分布式训练"><a href="#3-3分布式训练" class="headerlink" title="3.3分布式训练"></a>3.3分布式训练</h2><p>我们首先是需要把os的enviroment环境设置为0,1表示是在两个显卡上进行训练，之后我们还需要使用dataparallel还有cuda，来把模型传入到显卡上面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">os.environ[<span class="string">&#x27;CUDA_VISIBLE_DEVICES&#x27;</span>] = <span class="string">&#x27;0,1&#x27;</span></span><br><span class="line">model_swin = nn.DataParallel(model_swin)</span><br><span class="line">model_swin = model_swin.cuda()</span><br></pre></td></tr></table></figure><h2 id="3-3main函数的构建"><a href="#3-3main函数的构建" class="headerlink" title="3.3main函数的构建"></a>3.3main函数的构建</h2><p>main函数主要写的是整体流程，我们首先是是来进行构建数据集还有dataloader，对于train，我们一般使用shuffle，对于val，我们一般是使用不进行shuffle的。</p><p>之后就是进行构建模型，这一步，下一步就是进行设置loss函数我们一般使用交叉熵就可以了，然后之后就是使用优化器来优化模型，一般使用adam还有sgd，<strong>注意我们需要把模型的参数全部传入到优化器上面才可以（对于想cyclegan’这种，需要联合有何的参数，我们使用uitertools来进行连接两个模型的参数，到这个尤其来进行优化</strong></p><p>之后就是来进行构建tensorboard，我们需要来构建tensorboard所在文件目录，之后就是设置log，还有度量值，这个我们直接使用util来进行设置（不用自己写）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   os.makedirs(args.log_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">        log_writer = SummaryWriter(log_dir=args.log_dir)</span><br><span class="line">        loss_scaler = NativeScaler()</span><br><span class="line"><span class="comment">#加载模型</span></span><br><span class="line">misc.load_model(args=args, model_without_ddp=model, optimizer=optimizer, loss_scaler=loss_scaler)</span><br></pre></td></tr></table></figure><p>下一步就是加载模型，也是使用何开明写好的直接进行加载，我们只需要传入模型，优化器，还有记录的scaler</p><p>这一步是我直接把模型进行保存了，然后直接使用load就可以加载出模型，之后我们还是需要把模型移动到显卡上面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pth_path = <span class="string">&#x27;./checkpoint/swin2_base/accuracy_loss_change_train_11cnn.pth&#x27;</span></span><br><span class="line">   <span class="comment"># pth_path = args.pth_path</span></span><br><span class="line">   <span class="comment"># model = resnet18(pretrained=False)</span></span><br><span class="line">   model_cnn = torch.load(pth_path)</span><br></pre></td></tr></table></figure><p>对于加载好的模型，我们想修改值的话，可以修改最后一层的圈连接层，对于前面的层数我们全部保留，最后一层的fc，我们来使用linear来进行修改就可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model_conv = convnext_tiny(pretrained=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># print(model_conv.head.fc.in_features)</span></span><br><span class="line">    <span class="comment"># exit()</span></span><br><span class="line">    model_conv_ftrs = model_conv.head.fc.in_features</span><br><span class="line">    model_conv.head.fc = nn.Linear(model_conv_ftrs,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>之后就是开始for epoch，首先我们进入到验证阶段</p><ol><li>我们第一步就是设置模型为eval模式，</li><li>然后进入到验证阶段，传入的是数据集，还有模型</li><li>返回的就是记录的misc，之后我们对记录的值，传入到log里面，让他写入到tensorboard里面</li></ol><p>之后我们就是进行train模式，对于train模式，我们首先就是把model的train来进行打开</p><ol><li>传入大还是模型，数据集，还有loss，优化器，log直接在train里面记录到tensor里面</li></ol><h3 id="3-3-1验证阶段代码"><a href="#3-3-1验证阶段代码" class="headerlink" title="3.3.1验证阶段代码"></a>3.3.1验证阶段代码</h3><p>这一步，我们需要设置为torch nograd才可以进行操作，下面是需要学习的，使用装饰器进行让代码处于在nograd状态下，使用misc来进行记录，接下来就是开始进行评估，得到图像还有属性，传入到显卡上面，使用model来得到结果，之后就是使用soft来得到最大的值（这个就是可能的属性），然后就是top1，top5的计算这个直接使用timm的库可以计算。</p><p>之后就是记录在tensorboard里面，记录loss还有acc1还有acc5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line">   metric_logger = misc.MetricLogger(delimiter=<span class="string">&quot; &quot;</span>)</span><br><span class="line">   header = <span class="string">&quot;Test:&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 转入到评测模式</span></span><br><span class="line">   model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> batch <span class="keyword">in</span> metric_logger.log_every(data_loader, <span class="number">10</span>, header):</span><br><span class="line">       images = batch[<span class="number">0</span>]</span><br><span class="line">       target = batch[-<span class="number">1</span>]</span><br><span class="line">       images = images.to(device, non_blocking=<span class="literal">True</span>)</span><br><span class="line">       target = target.to(device, non_blocking=<span class="literal">True</span>)</span><br><span class="line">       <span class="comment"># 计算loss，统计得分</span></span><br><span class="line">       <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">           output = model(images)</span><br><span class="line">           loss = criterion(output, target)</span><br><span class="line"></span><br><span class="line">       output = torch.nn.functional.softmax(output, dim=<span class="number">1</span>)</span><br><span class="line">       acc1, acc5 = accuracy(output, target, topk=(<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">       batch_size = images.shape[<span class="number">0</span>]</span><br><span class="line">       <span class="comment"># 写下在tensorboard</span></span><br><span class="line">       metric_logger.update(loss=loss.item())</span><br><span class="line">       metric_logger.meters[<span class="string">&#x27;acc1&#x27;</span>].update(acc1.item(), n=batch_size)</span><br><span class="line">       metric_logger.meters[<span class="string">&#x27;acc5&#x27;</span>].update(acc5.item(), n=batch_size)</span><br><span class="line">       </span><br><span class="line">        metric_logger.synchronize_between_processes()</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">f&#x27;acc1:<span class="subst">&#123;metric_logger.acc1&#125;</span>, acc5:<span class="subst">&#123;metric_logger.acc5&#125;</span>&#x27;</span>)</span><br><span class="line">   <span class="comment"># return &#123;k: meter.global_avg for k, meter in metric_logger.items()&#125;</span></span><br><span class="line">   <span class="keyword">return</span> &#123;k: meter.global_avg <span class="keyword">for</span> k, meter <span class="keyword">in</span> metric_logger.meters.items()&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>返回的是misc记录的</p><h3 id="3-3-2训练函数代码"><a href="#3-3-2训练函数代码" class="headerlink" title="3.3.2训练函数代码"></a>3.3.2训练函数代码</h3><p>首先是和之前一样的，把图片还有属性传入到显卡上面，之后使用模型来进行预测，然后设置优化器，之后就是计算交叉熵，迭代次数一般是在batch开始来进行zero_grad，这个修改的我有点看不懂，应该是在求loss的时候就进行更新。</p><p>最后一步就是log来进行就misc</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16789737524861678973751741.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_one_epoch</span>(<span class="params">model: torch.nn.Module, criterion: torch.nn.Module,</span></span><br><span class="line"><span class="params">                    data_loader: Iterable, optimizer: torch.optim.Optimizer,</span></span><br><span class="line"><span class="params">                    device: torch.device, epoch: <span class="built_in">int</span>, loss_scaler, max_norm: <span class="built_in">float</span> = <span class="number">0</span>, log_writer=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                    args=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> log_writer <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;log_dir <span class="subst">&#123;log_writer.log_dir&#125;</span>&#x27;</span>)</span><br><span class="line">    model.train(<span class="literal">True</span>)</span><br><span class="line">    print_feq = <span class="number">2</span></span><br><span class="line">    accum_iter = args.accum_iter</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> data_iter_step, (samples, targets) <span class="keyword">in</span> <span class="built_in">enumerate</span>(data_loader):</span><br><span class="line">        samples = samples.to(device, non_blocking=<span class="literal">True</span>)</span><br><span class="line">        targets = targets.to(device, non_blocking=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        output = model(samples)</span><br><span class="line"></span><br><span class="line">        warmup_lr = args.lr</span><br><span class="line">        optimizer.param_groups[<span class="number">0</span>][<span class="string">&quot;lr&quot;</span>] = warmup_lr</span><br><span class="line"></span><br><span class="line">        loss = criterion(output, targets)</span><br><span class="line">        loss /= accum_iter</span><br><span class="line"></span><br><span class="line">        loss_scaler(loss, optimizer, clip_grad=max_norm,</span><br><span class="line">                    parameters=model.parameters(), create_graph=<span class="literal">False</span>,</span><br><span class="line">                    update_grad=(data_iter_step + <span class="number">1</span>) % accum_iter == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        loss_val = loss.item()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 完成一次epoch就进行置为，走</span></span><br><span class="line">        <span class="keyword">if</span> (data_iter_step + <span class="number">1</span>) % accum_iter == <span class="number">0</span>:</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> math.isfinite(loss_val):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;loss is <span class="subst">&#123;loss_val&#125;</span> &amp; stop training&quot;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> log_writer <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> (data_iter_step + <span class="number">1</span>) % accum_iter == <span class="number">0</span>:</span><br><span class="line">            epoch_1000x = <span class="built_in">int</span>((data_iter_step / <span class="built_in">len</span>(data_loader) + epoch) * <span class="number">1000</span>)</span><br><span class="line">            log_writer.add_scalar(<span class="string">&quot;loss&quot;</span>, loss, epoch_1000x)</span><br><span class="line">            log_writer.add_scalar(<span class="string">&quot;lr&quot;</span>, warmup_lr, epoch_1000x)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Epoch:<span class="subst">&#123;epoch&#125;</span>,loss:<span class="subst">&#123;loss&#125;</span>,step:<span class="subst">&#123;data_iter_step&#125;</span>,lr:<span class="subst">&#123;warmup_lr&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # gather the stats from all processes</span></span><br><span class="line">    <span class="comment"># log_writer.synchronize_between_processes()</span></span><br><span class="line">    <span class="comment"># print(&quot;Averaged stats:&quot;, log_writer)</span></span><br><span class="line">    <span class="comment"># return &#123;k: meter.global_avg for k, meter in log_writer.meters.items()&#125;</span></span><br></pre></td></tr></table></figure><p>上面的代码逻辑，可以多次复用不同的模型</p><p>如果要保存模型，使用save就可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.output_dir:</span><br><span class="line">                   <span class="built_in">print</span>(<span class="string">&quot;saving checkpoints....&quot;</span>)</span><br><span class="line">                   misc.save_model(</span><br><span class="line">                       args=args, model=model, model_without_ddp=model,</span><br><span class="line">                       optimizer=optimizer, epoch=epoch, loss_scaler=loss_scaler</span><br><span class="line">                   )</span><br></pre></td></tr></table></figure><h1 id="4-test阶段"><a href="#4-test阶段" class="headerlink" title="4.test阶段"></a>4.test阶段</h1><p>我们可以直接仿照val阶段来进行计算，就可以，变成eval，数据放到test里面，然后使用模型来进行计算</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-预备知识&quot;&gt;&lt;a href=&quot;#0-预备知识&quot; class=&quot;headerlink&quot; title=&quot;0.预备知识&quot;&gt;&lt;/a&gt;0.预备知识&lt;/h1&gt;&lt;p&gt;收先我们知道，一般大型公司都有一台机器才能够外网访问，其他机器都只能访问内网，我们把进行外网访问的机器称为跳</summary>
      
    
    
    
    
    <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>jvm小结</title>
    <link href="http://yoursite.com/2023/03/03/jvm%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2023/03/03/jvm%E5%B0%8F%E7%BB%93/</id>
    <published>2023-03-03T09:11:40.000Z</published>
    <updated>2023-03-05T08:19:37.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-类文件结构详解"><a href="#1-类文件结构详解" class="headerlink" title="1.类文件结构详解"></a>1.类文件结构详解</h1><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktop%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88.png"></p><p>JVM只认识class文件所有的虚拟机都只支持字节码。在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。而且JVM虚拟机</p><p>可以说<code>.class</code>文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</p><p>所以 jvm是跨语言的平台。</p><h2 id="1-2class类文件的结构"><a href="#1-2class类文件的结构" class="headerlink" title="1.2class类文件的结构"></a>1.2class类文件的结构</h2><p>主要包括魔数，class的版本号，常量池，访问标志，当前值，字段表，方法表，睡醒吧IAO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; //Class 文件的标志</span><br><span class="line">    u2             minor_version;//Class 的小版本号</span><br><span class="line">    u2             major_version;//Class 的大版本号</span><br><span class="line">    u2             constant_pool_count;//常量池的数量</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];//常量池</span><br><span class="line">    u2             access_flags;//Class 的访问标记</span><br><span class="line">    u2             this_class;//当前类</span><br><span class="line">    u2             super_class;//父类</span><br><span class="line">    u2             interfaces_count;//接口</span><br><span class="line">    u2             interfaces[interfaces_count];//一个类可以实现多个接口</span><br><span class="line">    u2             fields_count;//Class 文件的字段属性</span><br><span class="line">    field_info     fields[fields_count];//一个类可以有多个字段</span><br><span class="line">    u2             methods_count;//Class 文件的方法数量</span><br><span class="line">    method_info    methods[methods_count];//一个类可以有个多个方法</span><br><span class="line">    u2             attributes_count;//此类的属性表中的属性数</span><br><span class="line">    attribute_info attributes[attributes_count];//属性表集合</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-2-1魔数"><a href="#1-2-1魔数" class="headerlink" title="1.2.1魔数"></a>1.2.1魔数</h3><p>魔数就是进行判断验证，这个文件是不是能被jvm接受的</p><h3 id="1-2-2版本号"><a href="#1-2-2版本号" class="headerlink" title="1.2.2版本号"></a>1.2.2版本号</h3><p>首先是小版本号，接着就是大版本号</p><h3 id="1-2-3常量池"><a href="#1-2-3常量池" class="headerlink" title="1.2.3常量池"></a>1.2.3常量池</h3><p>常量池从1开始，到n-1。</p><p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16780000496321678000048909.png"></p><p>1个word是tag，然后看不同的类型。不同的属性，有name还有length。以utf8位例子，首先是tage，接着2个word是length之后就是这些长度的byte。</p><h3 id="1-2-4访问标志-Access-Flags"><a href="#1-2-4访问标志-Access-Flags" class="headerlink" title="1.2.4访问标志(Access Flags)"></a>1.2.4访问标志(Access Flags)</h3><p>这个就是来进行判断方法是不是抽象类还是公开类，或者是函数是不是抽象的，这个只需要把正确的表示，进行想或</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png"></p><h3 id="1-2-5-当前类（This-Class）、父类（Super-Class）、接口（Interfaces）索引集合"><a href="#1-2-5-当前类（This-Class）、父类（Super-Class）、接口（Interfaces）索引集合" class="headerlink" title="1.2.5 当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合"></a>1.2.5 当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合</h3><p>顺序的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;//当前类</span><br><span class="line">u2             super_class;//父类</span><br><span class="line">u2             interfaces_count;//接口</span><br><span class="line">u2             interfaces[interfaces_count];//一个类可以实现多个接口</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p><p>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中</p><hr><h3 id="1-2-6字段表"><a href="#1-2-6字段表" class="headerlink" title="1.2.6字段表"></a>1.2.6字段表</h3><p>描述的接口生命的变量。然后看他是不静态变量，类变量还是final修饰的</p><p><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</p><p><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；（ 从常量池检查到）</p><p><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；</p><p><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</p><p><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</p><h3 id="1-2-7方法表"><a href="#1-2-7方法表" class="headerlink" title="1.2.7方法表"></a>1.2.7方法表</h3><p>和字段表一样 ，不过这个就是在方法上面了，还是访问表示，名称索引，描述</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png"></p><h3 id="1-2-8属性表"><a href="#1-2-8属性表" class="headerlink" title="1.2.8属性表"></a>1.2.8属性表</h3><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p><hr><h2 id="1-3虚拟机类加载机制"><a href="#1-3虚拟机类加载机制" class="headerlink" title="1.3虚拟机类加载机制"></a>1.3虚拟机类加载机制</h2><p>首先记住加载流程</p><p>加载-linking-初始化-使用</p><h3 id="1-3-1加载"><a href="#1-3-1加载" class="headerlink" title="1.3.1加载"></a>1.3.1加载</h3><p>加载就是把磁盘上的内容存到内存上去</p><p>主动加载（包括new，invoke，静态变量，使用静态方法）</p><p>被动加载：初次之外都是被动</p><h3 id="1-3-2加载过程"><a href="#1-3-2加载过程" class="headerlink" title="1.3.2加载过程"></a>1.3.2加载过程</h3><p>通过类的路径来获得类文件class，讲这个二进制转化俄日运行内存里面的数据结构，最后在内存生成一个对象，作为入口</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li></ol><h3 id="1-3-3链接-验证"><a href="#1-3-3链接-验证" class="headerlink" title="1.3.3链接-验证"></a>1.3.3链接-验证</h3><p>验证代码文件是不是满足class文件的标准，还有语法验证，语义验证（本来是int类型，却是用long的方法），最后一个是符号验证（通常来讲，就是是不是访问了被进制的类，protect对象子类的）</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5.png"></p><h3 id="1-3-4准备"><a href="#1-3-4准备" class="headerlink" title="1.3.4准备"></a>1.3.4准备</h3><p>准备阶段就是进行填入初始值，质包括被static修饰的变量，初始化为全0</p><p><strong>比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。（初始化为0，之后才是进行赋值）</strong></p><p><strong>敞常量就是原始状态</strong></p><p><strong>特殊情况：比如给 value 变量加上了 final 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</strong></p><h3 id="1-3-5解析"><a href="#1-3-5解析" class="headerlink" title="1.3.5解析"></a>1.3.5解析</h3><p>进行减符号引用，转化为内存地址</p><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作<strong>主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符</strong> 7 类符号引用进行。</p><p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><p>**符号引用（如类的全限定名）解析为直接引用（类在实际内存中的地址） **</p><hr><h3 id="1-3-6类初始化"><a href="#1-3-6类初始化" class="headerlink" title="1.3.6类初始化"></a>1.3.6类初始化</h3><p>就是执行clinit方法</p><p>在这个阶段把之前的static变量进行赋值，这个时候才会UI变成113，不是一开始就是113</p><p>有静态方法就是由clint</p><h3 id="1-3-7常用的类加载器"><a href="#1-3-7常用的类加载器" class="headerlink" title="1.3.7常用的类加载器"></a>1.3.7常用的类加载器</h3><p>一个最开始的bootstrap，一个ext，一个app，最低那个曾就是开始的bootstrap</p><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li><li><strong>AppClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><p>自定义只需要实现loadclass，找到这个全限定的地址的二进制</p><h3 id="1-3-8双亲委派"><a href="#1-3-8双亲委派" class="headerlink" title="1.3.8双亲委派"></a>1.3.8双亲委派</h3><p>就是递归寻找，首先智商往下到达最顶层bootstrap，之后才是ext，最后才是app，看他的父类能不能处理，不能就自己进行加载</p><p>除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，很明显需要继承 <code>ClassLoader</code>。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-类文件结构详解&quot;&gt;&lt;a href=&quot;#1-类文件结构详解&quot; class=&quot;headerlink&quot; title=&quot;1.类文件结构详解&quot;&gt;&lt;/a&gt;1.类文件结构详解&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-be</summary>
      
    
    
    
    
    <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>resnet基础模型</title>
    <link href="http://yoursite.com/2023/02/17/resnet%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2023/02/17/resnet%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B/</id>
    <published>2023-02-17T09:09:49.000Z</published>
    <updated>2023-02-18T08:13:51.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据集搭建"><a href="#1-数据集搭建" class="headerlink" title="1.数据集搭建"></a>1.数据集搭建</h1><p>使用经典的csv读取数据，然后再进行构建自己的dataset的时候，通过csv ，直接获得图片地址，使用pil来读取图像，使用int强转label（label本来是是string，通过构建字典dict来得到的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">    img, label = self.images[idx], self.labels[idx]</span><br><span class="line">    <span class="comment"># 返回图像,下面的std是来自imagenet</span></span><br><span class="line">    tf = transforms.Compose([</span><br><span class="line">        <span class="keyword">lambda</span> x: Image.<span class="built_in">open</span>(x).convert(<span class="string">&#x27;RGB&#x27;</span>),  <span class="comment"># string path= &gt; image data</span></span><br><span class="line">        transforms.Resize((<span class="built_in">int</span>(self.resize * <span class="number">1.25</span>), <span class="built_in">int</span>(self.resize * <span class="number">1.25</span>))),</span><br><span class="line">        transforms.RandomRotation(<span class="number">15</span>),</span><br><span class="line">        transforms.CenterCrop(self.resize),</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],</span><br><span class="line">                             std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    img = tf(img)</span><br><span class="line">    label = torch.tensor(label)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img, label</span><br></pre></td></tr></table></figure><p>直接读取所有的文件，构建csv</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_csv</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构建csv，返回当前路径的图片的属性</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    file_name = <span class="string">&#x27;./label.csv&#x27;</span></span><br><span class="line">    type_dir = glob.glob(os.path.join(self.root, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">        writer = csv.writer(csvfile)</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">type</span> <span class="keyword">in</span> type_dir:</span><br><span class="line">            person_dir = glob.glob(os.path.join(<span class="built_in">type</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">            <span class="keyword">for</span> person <span class="keyword">in</span> person_dir:</span><br><span class="line">                emotion_dir = glob.glob(os.path.join(person, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">                <span class="keyword">for</span> emotion <span class="keyword">in</span> emotion_dir:</span><br><span class="line">                    label = emotion.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">                    img_dir = glob.glob(os.path.join(emotion, <span class="string">&#x27;*.jpeg&#x27;</span>))</span><br><span class="line">                    <span class="keyword">for</span> img <span class="keyword">in</span> img_dir:</span><br><span class="line">                        writer.writerow([img, label])</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;writting one person&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;process ok&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>、</p><p>之后就是进行分割数据集，train，val，test&#x3D;6:2：2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, path, resize, mode</span>):</span><br><span class="line">    <span class="built_in">super</span>(NIREmotionDatasets, self).__init__()</span><br><span class="line">    <span class="comment"># 进行自定义标签</span></span><br><span class="line">    self.class_dir = &#123;<span class="string">&quot;Anger&quot;</span>: <span class="number">0</span>, <span class="string">&quot;Disgust&quot;</span>: <span class="number">1</span>, <span class="string">&quot;Fear&quot;</span>: <span class="number">2</span>, <span class="string">&quot;Happiness&quot;</span>: <span class="number">3</span>, <span class="string">&quot;Sadness&quot;</span>: <span class="number">4</span>, <span class="string">&quot;Surprise&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">    self.root = path</span><br><span class="line">    self.resize = resize</span><br><span class="line">    self.images, self.labels = self.load_csv(<span class="string">&#x27;./label.csv&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&quot;train&quot;</span>:</span><br><span class="line">        self.images = self.images[:<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.images))]</span><br><span class="line">        self.labels = self.labels[:<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.labels))]</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">&#x27;val&#x27;</span>:  <span class="comment"># 20% = 60%-&gt;80%</span></span><br><span class="line">        self.images = self.images[<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.images)):<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.images))]</span><br><span class="line">        self.labels = self.labels[<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.labels)):<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.labels))]</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">&#x27;test&#x27;</span>:  <span class="comment"># 20% = 80%-&gt;9999%</span></span><br><span class="line">        self.images = self.images[<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.images)):<span class="built_in">int</span>(<span class="number">0.99999</span> * <span class="built_in">len</span>(self.images))]</span><br><span class="line">        self.labels = self.labels[<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.labels)):<span class="built_in">int</span>(<span class="number">0.99999</span> * <span class="built_in">len</span>(self.labels))]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-train模板"><a href="#2-train模板" class="headerlink" title="2.train模板"></a>2.train模板</h1><p>因为resnet在timm库里直接由，我们直接进行调用</p><p>构建代码步骤</p><ol><li>构建argparse，直接复制粘贴</li><li>构建dataloader，传入我们的datasets，然后进行shuttle，设置batch</li><li>进行设置crition，adam还有model，模型直接进行调用，然后传入之前的pth，使用load</li><li>设置model的最后一层为class层数 ，进行修改后放入device</li><li>之后就是for语句了，在epoch里面</li><li>首先是进行验证，验证，是计算正确率（这个就是，accurate的计算方法</li><li>之后就是train，train需要设置为train模式，然后这个是计算loss的</li><li>上面的常规就是zerograd，然后计算pred，pred与y计算loss，之后，loss进行反串，优化器进行更新</li><li>一轮后更新学习率lr</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">best_acc = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(args.input_size)</span><br><span class="line">    datasets_train = build_datasets(<span class="string">&#x27;train&#x27;</span>, args)</span><br><span class="line">    datasets_val = build_datasets(<span class="string">&#x27;test&#x27;</span>, args)</span><br><span class="line">    emotion_idx = datasets_train.class_dir</span><br><span class="line">    train_loader = torch.utils.data.DataLoader(datasets_train, batch_size=args.batch_size, shuffle=<span class="literal">True</span>,</span><br><span class="line">                                               num_workers=args.num_workers)</span><br><span class="line">    val_loader = torch.utils.data.DataLoader(datasets_val, batch_size=args.batch_size, shuffle=<span class="literal">True</span>,</span><br><span class="line">                                             num_workers=args.num_workers)</span><br><span class="line">    model_resnet = resnet18(pretrained=<span class="literal">True</span>)</span><br><span class="line">    checkpoint = torch.load(<span class="string">&#x27;/home/tonnn/.nas/weijia/work/fer/baseline/resnet_base/resnet18_msceleb .pth&#x27;</span>)</span><br><span class="line">    model_resnet.load_state_dict(checkpoint[<span class="string">&#x27;state_dict&#x27;</span>], strict=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    model = nn.Sequential(*<span class="built_in">list</span>(model_resnet.children())[:-<span class="number">1</span>],</span><br><span class="line">                          Flatten(),</span><br><span class="line">                          nn.Linear(<span class="number">512</span>, <span class="number">6</span>)</span><br><span class="line">                          ).to(device)</span><br><span class="line">    val_num = <span class="built_in">len</span>(val_loader)</span><br><span class="line">    train_num = <span class="built_in">len</span>(train_loader)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;using &#123;&#125; images for training, &#123;&#125; images for validation.&quot;</span>.<span class="built_in">format</span>(train_num, val_num))</span><br><span class="line"></span><br><span class="line">    params = <span class="built_in">list</span>(model.parameters())</span><br><span class="line">    optimizer = torch.optim.SGD(params, lr=args.lr, weight_decay=<span class="number">1e-4</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line">    scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=<span class="number">10</span>, gamma=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    criteon = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练start</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(args.epochs):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch <span class="subst">&#123;epoch&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;length of dataloader_train is <span class="subst">&#123;<span class="built_in">len</span>(train_loader)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        acc = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Evaluating...&quot;</span>)</span><br><span class="line"></span><br><span class="line">            model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                <span class="keyword">for</span> x, y <span class="keyword">in</span> val_loader:</span><br><span class="line">                    x, y = x.to(device), y.to(device)</span><br><span class="line">                    logits = model(x)</span><br><span class="line">                    pred = logits.argmax(dim=<span class="number">1</span>)</span><br><span class="line">                    <span class="comment"># 找出最大值作为答案</span></span><br><span class="line">                    acc += torch.eq(pred, y.to(device)).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">            val_acc = acc / <span class="built_in">len</span>(val_loader)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;[epoch %d]  val_accuracy: %.3f&#x27;</span> %</span><br><span class="line">                  (epoch + <span class="number">1</span>,  val_acc))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> val_acc &gt; best_acc:</span><br><span class="line">                best_acc = val_acc</span><br><span class="line">                torch.save(model.state_dict(), <span class="string">&#x27;accuracy_loss_change_train_50.mdl&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        model.train()</span><br><span class="line">        <span class="keyword">for</span> step,(x,y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">            x, y = x.to(device), y.to(device)</span><br><span class="line">            logits = model(x)</span><br><span class="line">            loss = criteon(logits,y)</span><br><span class="line"></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">        scheduler.step()</span><br><span class="line">        <span class="comment"># 更新 lr</span></span><br></pre></td></tr></table></figure><h1 id="3-进行预测test还有读取pth继续进行训练"><a href="#3-进行预测test还有读取pth继续进行训练" class="headerlink" title="3.进行预测test还有读取pth继续进行训练"></a>3.进行预测test还有读取pth继续进行训练</h1><p>预测函数predict，我们新建一个文件，然后还是要把预测的图片路径传入进来，然后就是进行加载模型，载入权重，之后使用nograd来进行计算，最后还需要id到属性的字典来进行映射</p><ol><li>使用dataset读取图片传入到dataloader</li><li>设置enviroment来进行多卡推理</li><li>设置模型，进行加载权重，使用模型的load’函数进行加载</li><li>最后就是with nograd’，进行推理，推理的时候，数据也要传到cuda上面</li><li>然后找到最大的索引，之后通过反向查询，得到他的名称</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">os.environ[<span class="string">&#x27;CUDA_VISIBLE_DEVICES&#x27;</span>] = <span class="string">&#x27;0,1&#x27;</span></span><br><span class="line"></span><br><span class="line">   device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">   test_datasets = build_datasets(<span class="string">&quot;test&quot;</span>, get_args_parser().parse_args())</span><br><span class="line"></span><br><span class="line">   test_loader = torch.utils.data.DataLoader(</span><br><span class="line">       test_datasets, batch_size=args.batch_size, shuffle=<span class="literal">False</span>,</span><br><span class="line">       num_workers=args.num_workers)</span><br><span class="line"></span><br><span class="line">   class_idx = test_datasets.class_dir</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 加载模型</span></span><br><span class="line">   pth_path = <span class="string">&#x27;accuracy_loss_change_train_50.mdl&#x27;</span></span><br><span class="line">   model = resnet18()</span><br><span class="line">   model = nn.Sequential(*<span class="built_in">list</span>(model.children())[:-<span class="number">1</span>],</span><br><span class="line">                         Flatten(),</span><br><span class="line">                         nn.Linear(<span class="number">512</span>, <span class="number">6</span>)</span><br><span class="line">                         ).to(device)</span><br><span class="line">   model.load_state_dict(torch.load(pth_path))</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;loaded from ckpt!&#x27;</span>)</span><br><span class="line">   model = nn.DataParallel(model)</span><br><span class="line">   model = model.cuda()</span><br><span class="line">   model.<span class="built_in">eval</span>()</span><br><span class="line">   acc = <span class="number">0</span></span><br><span class="line">   ans = []</span><br><span class="line">   <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">       <span class="keyword">for</span> x, y <span class="keyword">in</span> test_loader:</span><br><span class="line">           x, y = x.cuda(), y.cuda()</span><br><span class="line">           logits = model(x)</span><br><span class="line">           pred = logits.argmax(dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> x1 <span class="keyword">in</span> pred:</span><br><span class="line">               ans.append(find(class_idx, <span class="built_in">int</span>(x1)))</span><br><span class="line">           <span class="comment"># 找出最大值作为答案</span></span><br><span class="line">           acc += torch.eq(pred, y.to(device)).<span class="built_in">sum</span>().<span class="built_in">float</span>().item()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续训练和之前的predict一样，看args的startt是不是0，不是0，就进行加载权重</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if args.start_epoch !=0:</span><br><span class="line">      model.load_state_dict = torch.load(&#x27;accuracy_loss_change_train_1003.mdl&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-pytorch多卡运行，读取还有保存权重"><a href="#4-pytorch多卡运行，读取还有保存权重" class="headerlink" title="4.pytorch多卡运行，读取还有保存权重"></a>4.pytorch多卡运行，读取还有保存权重</h1><p>多卡运行，上面已经有操作了</p><ol><li>首先设置os的黄精为0,1</li><li>然后加载到dataparallel上面</li><li>之后模型移动到cuda</li><li>然后在训练和预测的时候数据移动到cuda</li></ol><p>和上面没有什么差别，支部够要移动一下，普通是移动到device</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">criteon = nn.CrossEntropyLoss()</span><br><span class="line">   <span class="comment"># if args.start_epoch !=0:</span></span><br><span class="line">   <span class="comment">#     model.load_state_dict = torch.load(&#x27;accuracy_loss_change_train_1003.mdl&#x27;)</span></span><br><span class="line">   <span class="comment">#     # model.load_state_dict(torch.load(&#x27;accuracy_loss_change_train_3.mdl&#x27;))</span></span><br><span class="line"></span><br><span class="line">   model = nn.DataParallel(model)</span><br><span class="line">   model = model.cuda()</span><br><span class="line">   <span class="comment"># 训练start</span></span><br><span class="line">   <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,args.epochs):</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">f&#x27;Epoch <span class="subst">&#123;epoch&#125;</span>&#x27;</span>)</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">f&#x27;length of dataloader_train is <span class="subst">&#123;<span class="built_in">len</span>(train_loader.dataset)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">       acc = <span class="number">0.0</span></span><br><span class="line">       <span class="keyword">if</span> epoch % <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&quot;Evaluating...&quot;</span>)</span><br><span class="line"></span><br><span class="line">           model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">           <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">               <span class="keyword">for</span> x, y <span class="keyword">in</span> val_loader:</span><br><span class="line">                   x, y = x.cuda(), y.cuda()</span><br><span class="line">                   logits = model(x)</span><br><span class="line">                   pred = logits.argmax(dim=<span class="number">1</span>)</span><br><span class="line">                   <span class="comment"># 找出最大值作为答案</span></span><br><span class="line">                   acc += torch.eq(pred, y.cuda()).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">           val_acc = acc / <span class="built_in">len</span>(val_loader.dataset)</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&#x27;[epoch %d]  val_accuracy: %.3f&#x27;</span> %</span><br><span class="line">                 (epoch + <span class="number">1</span>,  val_acc))</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> val_acc &gt; best_acc:</span><br><span class="line">               best_acc = val_acc</span><br><span class="line">               file_name = <span class="string">&#x27;/home/tonnn/.nas/weijia/work/fer/baseline/resnet_base/checkpoint/accuracy_loss_change_train_&#x27;</span>+<span class="built_in">str</span>(epoch)+<span class="string">&#x27;.pth&#x27;</span></span><br><span class="line">               torch.save(model.state_dict(), file_name)</span><br><span class="line"></span><br><span class="line">       model.train()</span><br><span class="line">       <span class="keyword">for</span> step,(x,y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">           x, y = x.cuda(), y.cuda()</span><br><span class="line">           logits = model(x)</span><br><span class="line">           loss = criteon(logits,y)</span><br><span class="line"></span><br><span class="line">           optimizer.zero_grad()</span><br><span class="line">           loss.backward()</span><br><span class="line">           optimizer.step()</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">r&quot;train epoch[&#123;&#125;/&#123;&#125;] loss:&#123;:.3f&#125;&quot;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>,</span><br><span class="line">                                                                    args.epochs,</span><br><span class="line">                                                                    loss.item()))</span><br><span class="line"></span><br><span class="line">       scheduler.step()</span><br><span class="line">       <span class="comment"># 更新 lr</span></span><br></pre></td></tr></table></figure><h1 id="附录：mtcnn进行裁剪"><a href="#附录：mtcnn进行裁剪" class="headerlink" title="附录：mtcnn进行裁剪"></a>附录：mtcnn进行裁剪</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-数据集搭建&quot;&gt;&lt;a href=&quot;#1-数据集搭建&quot; class=&quot;headerlink&quot; title=&quot;1.数据集搭建&quot;&gt;&lt;/a&gt;1.数据集搭建&lt;/h1&gt;&lt;p&gt;使用经典的csv读取数据，然后再进行构建自己的dataset的时候，通过csv ，直接获得图片地址，</summary>
      
    
    
    
    
    <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>面试课程</title>
    <link href="http://yoursite.com/2023/02/08/%E9%9D%A2%E8%AF%95%E8%AF%BE%E7%A8%8B/"/>
    <id>http://yoursite.com/2023/02/08/%E9%9D%A2%E8%AF%95%E8%AF%BE%E7%A8%8B/</id>
    <published>2023-02-08T07:24:32.000Z</published>
    <updated>2023-02-09T07:13:46.431Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="9dcb89ccee295b69f4c252edda7c05460bcd8d47ae7c55bd1906fcf343debf75">0e35b6246a8c35a575b2c91dc60e01c14936a1b25ba8b7fdecb9775ac57febeb7ab6fa87a67189256a663b22fd6a5cb9008c5704e28f35a942d681419b692cf6017da28a2c55f7473bd26acfc0e9b21205ddd1b6a10df005059b1ada6efc6b85a9942a0a858e13c21dcde45164fa84115e152015d916b2c6b43206016fb434ecfda9bc766a7e017d70730fbdc570f2656d358898ddb2e4a42eb02a7803419e6b5dc83a58eaef0f6f7b6a461ed20a7195f14458b40f2111bc8ef118b52bdfc2f71ad4605dbcb08ceccac013abebcee863a1feb5e45774ace4520f70fe06792d0373ec1edffc776057b001406336f00e3b2269ab61735be1bd2dbda90be22eec8358c6eafdcdddfc3f7d8360035e3a717ee36d47884784f43c229651b37c45dd51a4cbab18397d625eaa7df623f6c9b832c434b43bf4ba20146bfadd7f69ab281082db8e9dd8f1ad426ace8beaf67ca504d7ead710b509e3cb826d27b5747234ab0055d223ac762f644a06ea44921a36ab77af87c814158cbeb6d591d317b1e80c2c85b64b9ee3c91d7d3e5e89d82ebd322eb3a545d59750169a95bbdbcddddf0a60da03b4dc59f439250d7025e8638b7b930f4a0da5d532976fc98a44c63193f216746b48ffcbbc162cc99886a884f61fc1dde19982d835b729d20854fd7bc17db72bb0ca3421414d0b5a1aef9cc96b5764ab04900f02583a4eb5cfdaa2e06998d50db7e71335d1ab39f1eb1284c4cace9574bfcadc3fa068e1b8ce9bbf419331784675368eb5fe5d41b438f5b0139b0c8763444fc1fac7227f5b067d8a46d26f975e2ece4ee74fdc3f54256ba0d2e20ffdf8792b3a2127c55016231bc2d0f7bbfe5d1ee0525b4e5aa83ad06c587d32a0b39bb90eedf321bdf82b8d467ec3848463b8ba831a4ee5a5a6bd540c6ca06a62f0f11e8ac29ec4a30f7aa0fba053500f4e83099a97ab6c2010029c8fb8ccfb81f226eea15f9d6576fa6f875819bb94cd442c31def19f94076498271b6472d10eb1a0848476ef4b4b59b995ca3dd1a2bff01b1572ac245d3ef843af344c39d129108fa0e7357d0d25fcf5ebb2585affc48b2dabef10a0875fe9e82da7ed7270eb8ae51744fd467a4624183aa645477a9240efe972c9fc210184965ee22ea14c888f610c09a85459488265676186d06dea966545e0dc8b53b99bab0a146a7fb69e6327c6d85fffeba4e77b306839616ffd5e7e04e31f9871a191b7ed8c5133fdaf9865c3d63ca8f6e57f7b6e290ebbabbe5a48b2cf42b0373d4d9cee72e92c2f697b932f5b323b7bdfe073f242b0601c28da7f39636502c7adb0d092269f3f9f7ab9e89b9fe82cd596cfffba0d4308f152a17e3e0235ad220efbb648f7f94a438d203112b11163487ef3a4da97b2a46e5a6a5b96a7f246d1ccbe0b55f2a784f56664dad55fcacc7f3d64a7226e17b45e10d008d07fbf3a4e3e03c7208aa3560e2b62c33c7e861429ec7485a46086e277f4c37afd92ce435c79e837f7385b248263fab95b5f92f5012623b60e6a8a20b35741113a874ef63d0e334a53765ff3d0d41eb26a7206b1b7f86286e6bb9025ba4d4bf051e5e609e2ead89a01fb552de6f9bb1728e11c8eef15a31b9bd82477783feb9f9e7fe068e6e18ffa2fac6fc19e70e7779f7ba3ec678bdad2ca6766097d01100ba50c1375158cee3df71cc144e5a22bc76b73f7d4f606fac4b93766248007d26c30262e23d972d8d9c2e3aea17bad0299e794be92f03ead5b94d2bf1e1304dc5b31f3b2cfdf93cb32993635e6e418e6f785371a2659af9d116447f00c540622e6f9a416c09c15712d8cdd72567db5657f750684fb7d820952742ed291c00a119ccb75f093b3ba6a94c9b586666a58dfadcc510beff59539fde68ece7a7fc68005a58626d3c8e557fe51be5988ea4dc153caec61ed5ef6586887707a7100fb5630dec2e7ee209c7ccac268ea09192ec8d05add06ca255b971cc821c68bf4d6136ffaea2b92c2891dbad6b426e77e4c3029088a08834f1b7772a98e98af006023f5f5e0b5a6ec2bb335c9090d891415af01cbd2121a76bce74e94959918044c248da4d89592df033e50d63ccf520fbd8aa637773db74ea316f4f2f3bbe659a9dc6f8a842af641f878fd308a7c234a5a8be7c3adfc93f8948932e6ebe58e054101723aa84b3bcd630d8218b807550670d7ae792f16f3835928bfcce35ae26579006eeb3a92521f21dda48b4d81f281cbe1a014acf39f332d529b2c3767502613da538c5a50d0b7ef55ff084705aed78fdf921d3b37acb47eabcf518c999fb42c7911c6d7b6b57cb2d440345b14f000756dca60a453abdb2e17d8b22a690acbbc8ff651fb71d19cadd476da9bf8868237d6bfc8744fbb63fe7634d1bdf13ea2de6526f88ddbacdcff3e5e0ff7e06158e17401514f7d1ec9b620d5c541851323473b7a5e42a5bfecb06f3ec22b0c7d77e75dd79a7d6a5c9e357db90b0c0260cac53d43cbba55444f2b2225fff4fd97133e94f9840b3d76962bf8ce6df8da8183b7d1023778cd45ed7b64495d89de86bdc9e6a07b910fe465b17d534dbbcd1e355648e6ce6cf053ebf7846cd86427844c0658c8165a5cfa827a077ee5b8d7493bb0788b010446e8c6faeae053b6b0684954a1fe8d8c82e13c3487236d21973d33a26a3f3251f65619b5f6d41cc68052a7e40abbc70db83d0c1fdf9f139546f45e6fb2b8152ae1e9d9a621bd6aefeb480070854a45974cdae7217f9e757398ff438c0d5ea41e3b75d70413339aa42c3e0ad0d7e09b9439b5652857b8165c8b3e5ca6da1586b5ea35f8078148017e937229abe9b00f7f4c21f65161f052e87720f04a8c78259882cbb1f1bf887f6a2904abe94792b4c26ff4dbe7c050b5d4f7abe7ec56de275e428156fa0e9d7dfcc1b01ab2c96682be288209e47f28a1a1ce061cc500f456aedabdb754d65cf090c86cee7b379602d69bd9ace5d784f75786f17acfe3f95c4dc88edd3ac6f025af28ad33b5f3f524b8655b28cb3343ce313c55fb9fb7d254193972ddd1b6ac7f8db2334b6e83a79ab3727c91b390f632f7c3093fad2fa3ba381a81ec8a442137d935cfaa4559d739e0b09706e7f8030c82ee8ffb63b02bc3a8fef3052d89a302e745713e70335437bfe87e2bbc19a873e6ab8899e77a5fe9e5ffc0dd5de75fd95357afc4e5718ab142637c6142adb56ffc780e831561a01363b81b9a23de8ab49d2fa9796aa2076ea48ad9f06470ca4f63ef3ae2032ce22ca3636899c9ca781f381ee4782e2fcd669d5883d1846b1409c99da9dd2b03cc6b05d6d22ab69ccf6291890e95a7667cfdef7322be31217475f99d64e496319a81d84d0acd9ab8b34c6895db5a938ccc6d05a1224b611e0a8de60f41754c4fb299f41229b8e7a6c2c8ffcfa8d03c2b3c159402a9ca056e85fdf700229be36b956767277deba4595427ccd6e20f58da082ac5d9d682fe71d5a587166a44993a41e56f122ec5f4f4ad41f534a6d00cda9b9d742d766d1008f97dd0f93f00d694ec36b646a7be7d395e80fb2dfedcb144d3a6c47093cf8b8a6ef9cb3eb37ecf7850e9eb3e2aab1ff66bed192e4e90aeda692815eecb53b1cb0aa82e380286495dcb5bdeafd8ca4ef8a821c0b426b9afd1bf39070def09cd376906592ddf7cc53edd75881da79d3b90f2df735ff5706b09081074086fac52870fb5e191d006c884c576f9646dc26ee5c0fcebd04481621ecab73bd2753b0b5869e9034fa6bdee9cc571ecbf7743495570dda255c551618525938ef274b5287f82e8976dfc9c2b876b7e9a63a8841f167d70f9249df4e708eb909a4fa094eb4d51e7faa0803f1265ac20ef01caaadd80cc331db2c118c7375600f3bfff20b3a9de066af57ca6761083c2deb130a7849ae4125adbf5209552ee4b46fa12b359c19335dffef6571c8de17eb519b8fe9f3589d865b9ff761b7d5c88ed24044ba8e2cbfe203b5a87a93d9c4c3440cf22acd928bb2076870fab46e5ab62eb954f843c97d3fcec6a2b9f9d70c9d01bc16117bae7afdf8b4561dcad5c4ebd46b736dceac90ad1c34f914e3e5979b7a5ff4a5af2602608573ec9b1316fcb7f80af323a8e4130864adf55be8f5ad23737df9fb082ac5c2b53269c4847537fa8be6367113e43b13d0818c55385aa9d1c6d9e472ffa80c27b1e74c9751ba45226fb6830a7124be292e4fb3f9504a447e1c6380c5154bf4971fe3a5dd4e530e4d9b2380a30e9bb138c2f3224d60671b327205153eb4be972ca3e5991c145a73e3bbdf60cbccabc3c90837f1903859be0c77020707d5d3e9d52e7337fc94499e7699481889aef16ec709830eb62f991117ace3cd46b81638366aa2a442e967be9e4001214fd069cd376445a7e551466263242a9f37a9e3856aae0fb27b1b61449843c37cb95465f94457242db4adf1ee6c8fee76914df7dcfce68731ac434828a909d33f27aa7c2757f8dd5533d44de2868a360e294ae97e311241d76f7dde321d37b3e10d48983f1dcdc00119d02dab7cb5101ba00431e5dd022285bf9436787fc53ae5fc62e2579e4dc6089844d87184b618770ed47ae886a6b474345b6dad796f02d24a497972bb05fec51747a63a7be991d73c2e41b4ad4620a6f94c2eef46c22f9cbb177dcc94ff8300130b68703a248d40b4e8c7d42693a0179c8db870d1bfd284d36850475919846377db6e1340987cd714b2f9ee0ca1d01d1c3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    
    <category term="面试经验" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="网课" scheme="http://yoursite.com/tags/%E7%BD%91%E8%AF%BE/"/>
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>alist网盘聚合</title>
    <link href="http://yoursite.com/2023/02/04/alist%E7%BD%91%E7%9B%98%E8%81%9A%E5%90%88/"/>
    <id>http://yoursite.com/2023/02/04/alist%E7%BD%91%E7%9B%98%E8%81%9A%E5%90%88/</id>
    <published>2023-02-04T10:59:27.000Z</published>
    <updated>2023-02-05T08:55:19.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="alist简介"><a href="#alist简介" class="headerlink" title="alist简介"></a>alist简介</h1><p><strong>AList</strong> 是一个支持在本地加载 18 款常见网盘文件列表的工具，它可以让用户直接在浏览器中预览文件、上传文件、下载文件、播放视频、浏览照片，也可以直接在播放器中打开视频文件，还可以配合 aria2 实现文件下载功能。跨平台简单易用。@<a href="https://www.appinn.com/alist-file-list-program/">Appinn</a></p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Appinn-2022-09-16T150310.322.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频"></p><p>感谢 @<strong>imsoff</strong> 推荐。</p><h2 id="AList-–-文件列表程序"><a href="#AList-–-文件列表程序" class="headerlink" title="AList – 文件列表程序"></a>AList – 文件列表程序</h2><p>AList 自己的定位是一个支持多存储的文件列表程序，使用 Gin 和 Solidjs。它可以将以下网盘聚合在一起：</p><ul><li>本地存储</li><li>阿里云盘</li><li>OneDrive &#x2F; Sharepoint（国际版, 世纪互联,de,us）</li><li>天翼云盘 (个人云, 家庭云)</li><li>GoogleDrive</li><li>123云盘</li><li>FTP &#x2F; SFTP</li><li>PikPak</li><li>S3</li><li>又拍云对象存储</li><li>WebDav(支持无API的OneDrive&#x2F;SharePoint)</li><li>Teambition（中国，国际）</li><li>分秒帧</li><li>和彩云 (个人云,家庭云)</li><li>Yandex.Disk</li><li>百度网盘</li><li>夸克网盘</li><li>迅雷网盘</li></ul><p>然后只需要在浏览器中打开，即可预览文件、上传文件、下载文件、直接播放视频、音频。</p><h2 id="在线播放视频效果"><a href="#在线播放视频效果" class="headerlink" title="在线播放视频效果"></a>在线播放视频效果</h2><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-15.59.14.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 1"></p><p>并且提供了几个播放器按钮，直接点击就能跳转。</p><p>不过青小蛙在测试的时候没搞定云字幕，似乎需要下载字幕之后才能加载。</p><h2 id="安装-amp-配置"><a href="#安装-amp-配置" class="headerlink" title="安装 &amp; 配置"></a>安装 &amp; 配置</h2><p>AList 的安装比较简单，对于 Windows 用户，直接下载 .exe 文件之后，使用命令提示符运行，就行了。对于其他平台用户，也差不多，另外也支持 docker 部署，即开机用非常简单。</p><p>也算是0配置，只需要输入命令 alist.exe admin 获取管理员密码，打开浏览器 127.0.0.1:5244 就行了。</p><h2 id="添加存储"><a href="#添加存储" class="headerlink" title="添加存储"></a>添加存储</h2><p>在管理界面，可以添加很多的网盘：</p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-16.30.03.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 2"></p><p>这里就需要<a href="https://alist.nn.ci/zh/guide/drivers/common.html">阅读文档</a>了，但也很简单，最重要的是获取 Token，也提供了自动化获取按钮。不放心的同学可以根据文档说明手动获取。</p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-16.31.09.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 3"></p><h2 id="公网访问"><a href="#公网访问" class="headerlink" title="公网访问"></a>公网访问</h2><p>虽然青小蛙主要用来自己在家用，但的确看到了不少人拿来在公网使用。AList 可以设置公告、用户权限、</p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-16.39.19.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 4"></p><p>嗯，比如<a href="https://kutt.appinn.net/ftlxSu">这种</a>。</p><h2 id="WebDAV"><a href="#WebDAV" class="headerlink" title="WebDAV"></a>WebDAV</h2><p>除了直接将 WebDAV 资源添加进 AList，还支持反向使用，即使用 WebDAV 客户端连接 Alist，然后浏览绑定的内容，这样就极大的扩展了客户端，包括 iPhone、Android 都可以轻松访问你的网盘资源了：</p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-16.47.23.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 5"></p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-16.47.28.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 6"></p><p>怎么说呢，反正省了台 <a href="https://www.appinn.com/tag/nas/">NAS</a> 的感觉。</p><h1 id="2-为什么搭建"><a href="#2-为什么搭建" class="headerlink" title="2.为什么搭建"></a>2.为什么搭建</h1><p>笔者手里有多个网盘，百度云（网课视频），阿里云（电视视频），pikpak（下torrent），还有谷歌云（自用，备份手机的）。</p><p>主要是笔者中午使用pikpak在线客户端很卡，播放视频非常卡顿，不流畅，所以笔者花了一点时间来进行搭建。搭建完成之后的效果就是可以只要输入一个网站，就可以访问多个网盘，而且播放效果，比官网好多 了。</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16755087318811675508731713.png"></p><p>搭建效果如图</p><h1 id="3-搭建教程"><a href="#3-搭建教程" class="headerlink" title="3.搭建教程"></a>3.搭建教程</h1><p>主要参考下面官网文档，本来想使用docker的，但是垃圾服务器，内存根本跑不了docker，所以直接使用的一件脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL &quot;https://alist.nn.ci/v3.sh&quot; | bash -s install</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://alist.nn.ci/zh/guide/install/script.html">https://alist.nn.ci/zh/guide/install/script.html</a> 官网教程</p><p>搭建完成之后，会出现账号密码，这个自己记住。</p><p>之后就是使用如何进行安装网盘。最简单的是pikpak，这个只要输入账号密码就行。具体安装步骤在官网上面。</p><p>百度网盘安装教程：</p><ol><li><a href="https://openapi.baidu.com/oauth/2.0/authorize?response_type=code&amp;client_id=iYCeC9g08h5vuP9UqvPHKKSVrKFXGa1v&amp;redirect_uri=https://tool.nn.ci/baidu/callback&amp;scope=basic,netdisk&amp;qrcode=1">https://openapi.baidu.com/oauth/2.0/authorize?response_type=code&amp;client_id=iYCeC9g08h5vuP9UqvPHKKSVrKFXGa1v&amp;redirect_uri=https://tool.nn.ci/baidu/callback&amp;scope=basic,netdisk&amp;qrcode=1</a></li><li>使用上面网站获取令牌还有secret还有id</li><li>下面看图，不然没有办法正常播放视频</li><li>下载选择非官方就行</li></ol><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16755090388811675509038218.png"></p><p>谷歌网盘：</p><p>这是最复杂的，需要自己申请api接口，然后再把这个接口开放给自己一个人使用，得到接口之后才能进行生成id还有token，具体参考下面这个YouTube博主视频</p><p><a href="https://youtu.be/Hktdyg7L0Bg">https://youtu.be/Hktdyg7L0Bg</a></p><ol><li>创建项目</li><li>然后启用api还有服务，主要使用云盘服务，找到云盘</li><li>之后就是创建姘居，创建OA客户端id，填写外部，然后只要输入自己的电子邮件</li><li>之后就是添加用户，吧自己添加进去</li><li>之后再次回到品聚，创建oa的id，选择应用是桌面客户端之后秘钥还有id就出来了</li><li>之后输入到那个网站，点击code，弹出网页，一直继续</li><li>就会有token出现</li><li>之后就按照放入到alist的后台</li></ol><h1 id="4-反向代理"><a href="#4-反向代理" class="headerlink" title="4.反向代理"></a>4.反向代理</h1><p>下午使用github学生包，白嫖了一个域名，然后，为了懒得记住ip，直接用域名来使用。</p><p>问题是alist使用的5244端口，但是直接输入域名+端口非常不好看，所以使用反向代理，这里使用的是nginx，</p><p>直接下载nginx安装，笔者之前忘了开80端口，一直打不开，以为是自己配置问题。换了apache也是一样的。于是再换回nginx，才发现80没有打开，大坑。打开之后，一直是配置502，一直以为是自己的配置有问题（实际上没有，只是linux内核问题），谷歌发现要设置一个内核关闭，代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsebool -P httpd_can_network_connect 1   </span><br></pre></td></tr></table></figure><p>之后就可以正常访问了，主要的是配置，参考官网，直接在http模块里面添加一个新的server模块，就可以，配置文档etc、nginx、nginxconf里面，修改如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">  proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">  proxy_set_header Host $http_host;</span><br><span class="line">  proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">  proxy_set_header Range $http_range;</span><br><span class="line">proxy_set_header If-Range $http_if_range;</span><br><span class="line">  proxy_redirect off;</span><br><span class="line">  proxy_pass http:<span class="comment">//127.0.0.1:5244;</span></span><br><span class="line">  <span class="meta"># the max size of file to upload</span></span><br><span class="line">  client_max_body_size <span class="number">20000</span>m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;alist简介&quot;&gt;&lt;a href=&quot;#alist简介&quot; class=&quot;headerlink&quot; title=&quot;alist简介&quot;&gt;&lt;/a&gt;alist简介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;AList&lt;/strong&gt; 是一个支持在本地加载 18 款常见网盘文件列表的工具，</summary>
      
    
    
    
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
    <category term="网盘" scheme="http://yoursite.com/tags/%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>一文详解欧易wise和depay</title>
    <link href="http://yoursite.com/2023/02/04/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E6%AC%A7%E6%98%93wise%E5%92%8Cdepay/"/>
    <id>http://yoursite.com/2023/02/04/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E6%AC%A7%E6%98%93wise%E5%92%8Cdepay/</id>
    <published>2023-02-04T09:56:13.000Z</published>
    <updated>2023-02-04T10:52:36.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简要介绍"><a href="#1-简要介绍" class="headerlink" title="1.简要介绍"></a>1.简要介绍</h1><p>之所以写这个的原因是，笔者正在白嫖土耳其的低价优惠。因为埃尔多安经济学，导致人民币兑土耳其不断升高，而且定价在土区也是低价区。所以如何充分利用土区白嫖优惠，就是个问题。</p><p>门前主流的国外网站netflix，Spotify，apple，google，Disney等价格都远远低于国区。但是购买方式只能使用国外的信用卡组织visa或者MasterCard。笔者作为学生党，当然是办不了的。但是oldubil这个软件，提供一个虚拟土耳其mastercard，可以对上述网站进行购买。所以我们的问题就变成如何给oldubil入金了。</p><p>目前有两种方式，笔者尝试的第一种损耗很大，而且还需要进行kyc身份验证，需要使用你的护照信息。第二种是直接通过欧易交易所，交易usdt给土耳其人（因为中国大陆区无法直接交易土耳其，所以还需要注册一个台湾区来进行交易）。</p><p>下面先介绍第一种思路：</p><ol><li>支付宝购买usdt在欧易里面（微信，银行卡也可以）</li><li>在depay里面进行充币操作</li><li>利用depay的虚拟卡给wise汇款</li><li>利用wise进行转换，把美元兑换成土耳其</li><li>最后利用wise发送到oldubil支持的iban银行</li></ol><p>以上每一步都有损耗，交易费，手续费，还有转账费用，笔者一共付出23.8在欧易，到wise里面就只有20了。损耗率有16个点。而且还需要kyc身份认证在wise，总体比较繁琐</p><p>第二种就是直接欧易买卖币，兑换成土耳其</p><ol><li>大陆欧易账号买币</li><li>发送到台湾欧易账号（站内转账）</li><li>最后用台湾的账号卖出为土耳其，填入iban相关的</li></ol><p>下面先介绍一下第一种方法</p><h2 id="1-1-欧易操作"><a href="#1-1-欧易操作" class="headerlink" title="1.1 欧易操作"></a>1.1 欧易操作</h2><blockquote><p><strong>欧易</strong>（英语：OKX；原名<strong>OKEx</strong>）是一间<a href="https://zh.wikipedia.org/wiki/%E7%B8%BD%E9%83%A8">总部</a>位于<a href="https://zh.wikipedia.org/wiki/%E5%A1%9E%E8%88%8C%E5%B0%94">塞舌尔</a>的<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E4%BA%A4%E6%98%93%E6%89%80">加密货币交易所</a>[<a href="https://zh.wikipedia.org/zh-cn/%E6%AC%A7%E6%98%93#cite_note-2">2]</a>，由徐明星于2017年创办[<a href="https://zh.wikipedia.org/zh-cn/%E6%AC%A7%E6%98%93#cite_note-Birnbaum_2022-3">3]</a>。该机构的主营业务是为<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7">用户</a>提供多种加密资产交易服务。2021年2月2日，该交易所正式启用中文名“欧易”[<a href="https://zh.wikipedia.org/zh-cn/%E6%AC%A7%E6%98%93#cite_note-4">4]</a>。2022年1月，OKEx更名为OKX[<a href="https://zh.wikipedia.org/zh-cn/%E6%AC%A7%E6%98%93#cite_note-5">5]</a>。</p></blockquote><p>简单来说就是一个交易所，进行买卖比特币的地方，我们如果要进行买币就要首先认证身份，l1认证就行，使用身份证可以通过。</p><p><strong>第二步就是进行c2c买币</strong>，顾名思义，就是顾客对顾客买币，量大他的折扣才打。目前汇率是1:6.78，但是个人卖家，你卖的少可能会出现1:7的价格。这也是一部分损耗。选择接受的方式进行筛选，微信，支付宝</p><h2 id="1-2depay操作"><a href="#1-2depay操作" class="headerlink" title="1.2depay操作"></a>1.2depay操作</h2><p><a href="https://zhuanlan.zhihu.com/p/596899194">https://zhuanlan.zhihu.com/p/596899194</a></p><blockquote><blockquote><p><em>一、Depay的使用场景有那些？</em></p></blockquote><p>1、Depay Master Visa卡支持绑定支付宝、微信支付、美团外卖、拼多多、Paypal、天猫国际版等等。</p><p>2、支持Stripe商户、google play商店、youtube premium、paypal商户、美区苹果商店、和支持非3DS卡的电商网站</p><p>3、支持国内苹果官网直接绑卡购买iphone和mac，可能会打电话问询，直接说即可。</p><p>4、暂不支持苹果支付APPLE PAY和谷歌PAY</p><p>5、所有等级的卡（Lite、标准、高级、白金、黑金）都满足以上场景</p></blockquote><p>简而言之就是提供了一个虚拟mastercard，但是入金的方式只能通过比特币来入金，所以我们需要第一步的欧易来操作。（注意，手续费比较多）</p><ol><li>首先把欧易里面的usdt发送给depay</li><li>我们需要在depay里面找到usdt，还有他的合约链，复制合约链还有id来到欧易</li><li><strong>在欧易里面选择提币，然后选择连上转账，输入地址还有链，这个时候因为是外链会有0.8的手续费</strong></li><li>之后等过5分钟到达depay</li><li>我们在等待时间，先开一张虚拟卡，使用身份证可以验证，然后就是最便宜的没有开卡费用，但是月费是1刀，还有交易费</li><li>开卡完成，我们回到usdt，还需要进行转换为usd才能放入depay一般是97折进行转换</li><li>转换放入需要扣除0.3的手续，到此23.8就只有21.76左右了</li></ol><h2 id="1-3wise操作"><a href="#1-3wise操作" class="headerlink" title="1.3wise操作"></a>1.3wise操作</h2><blockquote><h2 id="什麼是-Wise？"><a href="#什麼是-Wise？" class="headerlink" title="什麼是 Wise？"></a><strong>什麼是 Wise？</strong></h2><p>Wise（舊稱Transferwise），是一家提供國際匯款轉賬服務的 P2P 國際匯款平台。Wise 也是世界上成長速度最快的線上匯款、電子貨幣服務之一。</p><p>Wise 因匯率和定價透明，加上直接將資金匯到海外，省去高昂的銀行手續費，吸引超過1,000萬的用戶。目前 Wise 可支持40多個國家的貨幣轉賬，非常適合在海外工作，或是擁有海外收入的用戶。</p></blockquote><p>简单来说wise就是跨境汇款工具，因为普通银行汇款会有巨额的手续费没所以才有了wise，就是减少手续费 的。</p><p>但是wise这个软件是需要进行进行身份验证，前面两个使用身份证就行，这个必须使用护照（还好现在办护照容易，笔者是上个月办的，听到可以恢复办理护照，就赶快办了一个）。说回正题，现在你还需要入金20刀还有护照才能激活wise，才可以开通跨境转账成为土耳其货币，具体步骤如下。</p><ol><li>使用depay进行付款20美金，注意，<strong>又有手续费，0.8必须扣得</strong></li><li>之后就是身份验证，需要护照还有自拍</li><li>最后一步就是转账，具体流程如下图</li><li>转账之前还需要把美元兑换成土耳其，也有损耗</li><li>发送固定是24土耳其，合计1美金左右的手续费</li></ol><p>简单来说就是去oldubil里面 选择iban转账，然后去oldubil找到银行，复制iban和名称回到wise，最后一步就是附言要写上自己的虚拟卡（这个是oldubil提供的土耳其虚拟卡），如下图所示</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16755067588821675506758131.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16755067768841675506776221.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16755067878851675506787752.png"></p><h2 id="1-4oldubil操作"><a href="#1-4oldubil操作" class="headerlink" title="1.4oldubil操作"></a>1.4oldubil操作</h2><p>这个是土耳其的虚拟卡软件，但是注册的话，国内手机号没有办法使用。我是用的是土乌克兰lifecell的esim，使用国内的万事达借记卡，可以购买手机号。优点不需要实名认证，价格是5块钱一个月。使用的是美版se2，进行使用esim的</p><p>esim连接：<a href="https://www.lifecell.ua/en/sim-and-number/eSIM/">https://www.lifecell.ua/en/sim-and-number/eSIM/</a></p><blockquote><p>万事达借记卡：使用的是中国银行的莫奈，有3ds，可以在某些网站进行验证，有网申连接，主要参考这个网站</p><p><a href="https://poplite.xyz/post/2018/03/05/boc-debit-card-guide-for-online-payment.html">https://poplite.xyz/post/2018/03/05/boc-debit-card-guide-for-online-payment.html</a>   还有dotofcards这个群组。唯一缺点就是需要自己手动结汇购汇，这个是会占用自己的5w外汇额度的。美国运通的借记卡就不需要，但是没有3ds，有些网站买不了东西。</p></blockquote><p>最后就是转账到oldubil里面，然后使用这个提供的银行卡去买spotify，netflix</p><h1 id="2-方法总结"><a href="#2-方法总结" class="headerlink" title="2.方法总结"></a>2.方法总结</h1><p>上述方法，一共损耗0.8（欧易费用）+0.3（depay汇入费用）+（0.86wise汇入费用）+（1.2wise会出费用），这还没有计算，usdt打折，还有还有usdt转入usd的损耗，还有美元转土耳其的损耗。目前就损耗了3美元，流程繁琐，而且损耗严重。</p><p>第二种方法就是直接买usdt，通过欧易发送到台湾账户，这个站内转账没有损害，而且我们只需要在卖比特币给土耳其人就行，时间很快。主要有下面的教程</p><p><a href="https://yummy.best/how-to-top-up-oldubil/">https://yummy.best/how-to-top-up-oldubil/</a>  参考下面的教程</p><blockquote><h2 id="入金步骤（来自-沐攸-投稿）"><a href="#入金步骤（来自-沐攸-投稿）" class="headerlink" title="入金步骤（来自 沐攸 投稿）"></a>入金步骤（来自 <a href="https://t.me/Mylovetbole">沐攸</a> 投稿）</h2><p><strong>第一步</strong>：注册两个欧易账户，一个欧易账号身份认证选择  <code>**大陆+大陆身份证验证**</code> ，另一欧易账户身份认证选择 <code>**台湾+大陆身份证认证**</code> 。</p><blockquote><p>说明：选择台湾账户的账户只需要简单认证  <code>**L1**</code> 即可，不要验证到  <code>**L2**</code> 否则默认成为大陆欧易无法绕过 CNY 进行交易；另一个账户随便。</p></blockquote><p><strong>第二步</strong>：用 <code>**大陆**</code> 的欧易账户购买 USDT 入金欧易（支持微信+支付宝），然后将购买到的 USDT 发送到 <code>**台湾**</code> 欧易账户（<strong>选择站内转账，否则需要支付 0.8 usdt 手续费</strong>）</p><p><strong>第三步</strong>：使用 <code>**台湾**</code> 欧易账户 C2C 交易 → 选择货币为 TRY → 交易方式为银行转账 → 选择 oldubil 支持的银行并填入信息，然后按照如下格式填入发送到聊天框‌‌</p><p><strong>IBAN:‌‌</strong></p><p><strong>Name:</strong></p><p><strong>‌‌Card Number:</strong></p></blockquote><p>第三种就是直接淘宝进行购买，主要使用的是礼品卡，淘宝也有卖的，而且。还有一些专门卖礼品卡的网站。</p><p><a href="https://hezu.wiki/zh/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%BA/%E5%9C%9F%E8%80%B3%E5%85%B6%E7%A4%BC%E5%93%81%E5%8D%A1%E8%B4%AD%E4%B9%B0">https://hezu.wiki/zh/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%BA/%E5%9C%9F%E8%80%B3%E5%85%B6%E7%A4%BC%E5%93%81%E5%8D%A1%E8%B4%AD%E4%B9%B0</a></p><p><a href="https://www.oyunfor.com/tv/netflix-hediye-kodu-karti">https://www.oyunfor.com/tv/netflix-hediye-kodu-karti</a>  主要使用这个，这个基本都有买的。</p><p>总而言之，使用第一种方法是费力不讨好的，但是折腾了很久，也学到了btc一些知识。充值还是推荐后面两种。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简要介绍&quot;&gt;&lt;a href=&quot;#1-简要介绍&quot; class=&quot;headerlink&quot; title=&quot;1.简要介绍&quot;&gt;&lt;/a&gt;1.简要介绍&lt;/h1&gt;&lt;p&gt;之所以写这个的原因是，笔者正在白嫖土耳其的低价优惠。因为埃尔多安经济学，导致人民币兑土耳其不断升高，而且定价</summary>
      
    
    
    
    
    <category term="usdt" scheme="http://yoursite.com/tags/usdt/"/>
    
    <category term="btc" scheme="http://yoursite.com/tags/btc/"/>
    
    <category term="外汇" scheme="http://yoursite.com/tags/%E5%A4%96%E6%B1%87/"/>
    
    <category term="入金" scheme="http://yoursite.com/tags/%E5%85%A5%E9%87%91/"/>
    
    <category term="土耳其" scheme="http://yoursite.com/tags/%E5%9C%9F%E8%80%B3%E5%85%B6/"/>
    
    <category term="mastercard" scheme="http://yoursite.com/tags/mastercard/"/>
    
  </entry>
  
  <entry>
    <title>搜索专题</title>
    <link href="http://yoursite.com/2023/02/03/%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98/"/>
    <id>http://yoursite.com/2023/02/03/%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98/</id>
    <published>2023-02-03T08:54:33.000Z</published>
    <updated>2023-02-03T11:14:51.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-BFS"><a href="#1-BFS" class="headerlink" title="1.BFS"></a>1.BFS</h1><p>bfs主要包括一下应用，flood fill（洪水灌溉）把所有的值进行填充man，最小步数模型，就是最先到达的形态，使用的最小方法。然后就是多源bfs，这个思路就是吧所有的起点全部放入到queue里面。之后就是双向bfs，这个是节约搜索时间（使用两个queue来进行）</p><h2 id="397-整数替换"><a href="#397-整数替换" class="headerlink" title="397. 整数替换"></a><a href="https://leetcode.cn/problems/integer-replacement/">397. 整数替换</a></h2><p>返回最小的次数，可以用递归，或者最小步数</p><p>思路也是没有发现了这个值，就放入st和queue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerReplacement</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        if (n==1)return 0;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        if(n%2)&#123;</span></span><br><span class="line"><span class="comment">//            return min(integerReplacement(n-1), integerReplacement(n+1))+1;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return 1+ integerReplacement(n/2);</span></span><br><span class="line">        queue&lt;<span class="type">long</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(n);</span><br><span class="line">        <span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">        set&lt;<span class="type">long</span>&gt; st;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> n=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> n1=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(n1==<span class="number">1</span>)<span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">if</span>(n1%<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">count</span>(n1<span class="number">-1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                        st.<span class="built_in">insert</span>(n1<span class="number">-1</span>);</span><br><span class="line">                        q.<span class="built_in">push</span>(n1<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (st.<span class="built_in">count</span>(n1+<span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(n1+<span class="number">1</span>);</span><br><span class="line">                        st.<span class="built_in">insert</span>(n1+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">count</span>(n1/<span class="number">2</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(n1/<span class="number">2</span>);</span><br><span class="line">                        st.<span class="built_in">insert</span>(n1/<span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403. 青蛙过河"></a><a href="https://leetcode.cn/problems/frog-jump/">403. 青蛙过河</a></h2><p>f[i][j】表示表示到达i这个点，下一步是j步数。</p><p>计算方法就是当前i可能是由j，j-1，j+1构成的，f【rec[num[i]-j]][j]可以由他来构成，所以我们要查看当前值有没有。最后一个我们只要看f【n-1】【0.。。n-1】有没有一个成功的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//直接使用dp，f【i】【j】是bool，表示到达i，下一步是j，是不是可能的</span></span><br><span class="line"><span class="comment">//    地推方程f[?][j-1],f[?][j],f[?][j+1]来构成</span></span><br><span class="line"><span class="comment">//一共到达n，有f[n][1],f[n][2],f[n][n]中方法，一个是true，就返回</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n=stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            rec[stones[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> end=stones[stones.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">f</span>(n,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//开门表示，0开始一步跳是可以的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> x=stones[i];</span><br><span class="line">                <span class="keyword">if</span>(rec.<span class="built_in">count</span>(x-j))&#123;</span><br><span class="line">                    f[i][j]=f[i][j]||f[rec[x-j]][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(rec.<span class="built_in">count</span>(x-j<span class="number">-1</span>)&amp;&amp;j+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">                    f[i][j]=f[i][j]||f[rec[x-j<span class="number">-1</span>]][j+<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">if</span>(rec.<span class="built_in">count</span>(x-j+<span class="number">1</span>)&amp;&amp;j<span class="number">-1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    f[i][j]=f[i][j]||f[rec[x-j+<span class="number">1</span>]][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[n<span class="number">-1</span>][i])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">         <span class="type">int</span> len = stones.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp[i][j] 表示 第 i 个石头是否可以跳 j 步</span></span><br><span class="line">        <span class="comment">// boolean[][] dp = new boolean[len][len + 1];</span></span><br><span class="line">                vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(len,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(len+<span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始条件：第 0 个石头可以跳 1 步</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//因为 石头 i 最大只能跳 i + 1 步，因此 前面的石头 j 到达 石头 i 的距离必须 &lt;= i</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="type">int</span> diff = stones[i] - stones[j];</span><br><span class="line">                <span class="keyword">if</span>(diff &gt; i)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//对于 石头 j ，它需要跳 diff 步</span></span><br><span class="line">                <span class="keyword">if</span>(dp[j][diff])&#123;</span><br><span class="line">                    dp[i][diff - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    dp[i][diff] = <span class="literal">true</span>;</span><br><span class="line">                    dp[i][diff + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当到达了终点 而 flag ，表示无法从前面的任意石头跳到终点，返回 false</span></span><br><span class="line">            <span class="keyword">if</span>(i == len - <span class="number">1</span> &amp;&amp; !flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></h2><p>模板题目</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (!root)<span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> n=q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cur=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                path.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cur-&gt;children.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;children[j])&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(cur-&gt;children[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h2><p>dfs，直接加入depth，然后第一次出现的就进行设置，从做开始到右边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> max=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth&gt;max)&#123;</span><br><span class="line">            max=depth;</span><br><span class="line">            ans=root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者直接每一层的用vector存着，然后放出第一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        d.<span class="built_in">addLast</span>(root);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!d.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> sz = d.<span class="built_in">size</span>();</span><br><span class="line">            ans = d.<span class="built_in">peek</span>().val;</span><br><span class="line">            <span class="keyword">while</span> (sz-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode poll = d.<span class="built_in">pollFirst</span>();</span><br><span class="line">                <span class="keyword">if</span> (poll.left != null) d.<span class="built_in">addLast</span>(poll.left);</span><br><span class="line">                <span class="keyword">if</span> (poll.right != null) d.<span class="built_in">addLast</span>(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></h2><p>标准的层序，然后当前的进行比较，放进去，或者是使用dfs来对每一个进行大小比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line">    <span class="type">int</span> max1;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">0</span>);</span><br><span class="line">        rec[<span class="number">0</span>]=root-&gt;val;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=max1; ++i) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(rec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth&gt;max1)&#123;</span><br><span class="line">            max1=depth;</span><br><span class="line">            rec[depth]=root-&gt;val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            rec[depth]=<span class="built_in">max</span>(rec[depth],root-&gt;val);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h2><p>简单模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line">    <span class="type">int</span> maxdepth=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        rec[0]=1;</span></span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=maxdepth ; ++i) &#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(rec[i],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxdepth+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Node* root,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth&gt; maxdepth)&#123;</span><br><span class="line">            maxdepth=depth;</span><br><span class="line">            rec[maxdepth]=<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            rec[depth]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;children[i],depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="623-在二叉树中增加一行"><a href="#623-在二叉树中增加一行" class="headerlink" title="623. 在二叉树中增加一行"></a><a href="https://leetcode.cn/problems/add-one-row-to-tree/">623. 在二叉树中增加一行</a></h2><p>最开始就是在0层直接加，其它层就是找到深度-1的时候加入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">addOneRow</span><span class="params">(TreeNode* root, <span class="type">int</span> val, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth == <span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val,root, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(root,val,depth,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> val, <span class="type">int</span> depth,<span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height == depth - <span class="number">1</span>)&#123;</span><br><span class="line">            root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val,root-&gt;left, <span class="literal">nullptr</span>);</span><br><span class="line">            root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val,<span class="literal">nullptr</span>,root-&gt;right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,val,depth,height+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,val,depth,height+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h2><p>好题目，主要是想多了，如果当前值小，就返回右边的值（因为是bst，右边一定大），如果大，就返回左边的，如果符合返回root</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;low)&#123;</span><br><span class="line">            <span class="comment">//当前的国小,返回右边的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&gt;high)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left=<span class="built_in">trimBST</span>(root-&gt;left,low,high);</span><br><span class="line">        root-&gt;right=<span class="built_in">trimBST</span>(root-&gt;right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a><a href="https://leetcode.cn/problems/word-ladder/">127. 单词接龙</a></h2><p>这个是求最短的变换方式，就是最小步数模型。我们通过检索每一个位置，然后进行a-z的变形，而且在指点里面就进行加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;string&gt; S;</span><br><span class="line">      unordered_map&lt;string, int&gt; dist;</span><br><span class="line">      queue&lt;string&gt; q;</span><br><span class="line">      dist[beginWord] = 1;</span><br><span class="line">      q.push(beginWord);</span><br><span class="line">      for (auto word: wordList) S.insert(word);</span><br><span class="line"></span><br><span class="line">      while (q.size()) &#123;</span><br><span class="line">          auto t = q.front();</span><br><span class="line">          q.pop();</span><br><span class="line">          string r = t;</span><br><span class="line">          for (int i = 0; i &lt; t.size(); i ++ ) &#123;</span><br><span class="line">              t = r;</span><br><span class="line">              for (char j = &#x27;a&#x27;; j &lt;= &#x27;z&#x27;; j ++ )</span><br><span class="line">                  if (r[i] != j) &#123;</span><br><span class="line">                      t[i] = j;</span><br><span class="line">                      if (S.count(t) &amp;&amp; dist.count(t) == 0) &#123;</span><br><span class="line">                          dist[t] = dist[r] + 1;</span><br><span class="line">                          if (t == endWord) return dist[t];</span><br><span class="line">                          q.push(t);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return 0;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="417-太平洋大西洋水流问题"><a href="#417-太平洋大西洋水流问题" class="headerlink" title="417. 太平洋大西洋水流问题"></a><a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></h2><p>都可以流的，那我们只需要2次遍历，一次太平洋，一次大西洋，然后都可以的，两次遍历，取公共</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; heights;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; &amp; ocean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ocean[row][col]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        ocean[row][col] = <span class="literal">true</span>;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; qu;</span><br><span class="line">        qu.<span class="built_in">emplace</span>(row, col);</span><br><span class="line">        <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [row, col] = qu.<span class="built_in">front</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> newRow = row + dirs[i][<span class="number">0</span>], newCol = col + dirs[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; m &amp;&amp; newCol &gt;= <span class="number">0</span> &amp;&amp; newCol &lt; n &amp;&amp; heights[newRow][newCol] &gt;= heights[row][col] &amp;&amp; !ocean[newRow][newCol]) &#123;</span><br><span class="line">                    ocean[newRow][newCol] = <span class="literal">true</span>;</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(newRow, newCol);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;heights = heights;</span><br><span class="line">        <span class="type">int</span> m = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">pacific</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">atlantic</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(i, <span class="number">0</span>, pacific);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(<span class="number">0</span>, j, pacific);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(i, n - <span class="number">1</span>, atlantic);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(m - <span class="number">1</span>, j, atlantic);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j]) &#123;</span><br><span class="line">                    vector&lt;<span class="type">int</span>&gt; cell;</span><br><span class="line">                    cell.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                    cell.<span class="built_in">emplace_back</span>(j);</span><br><span class="line">                    result.<span class="built_in">emplace_back</span>(cell);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="433-最小基因变化"><a href="#433-最小基因变化" class="headerlink" title="433. 最小基因变化"></a><a href="https://leetcode.cn/problems/minimum-genetic-mutation/">433. 最小基因变化</a></h2><p>简单的最小步数模型，和前两题一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMutation</span><span class="params">(string startGene, string endGene, vector&lt;string&gt;&amp; bank)</span> </span>&#123;</span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(startGene);</span><br><span class="line">        <span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">        set&lt;string&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bank.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bank[i]==endGene)&#123;</span><br><span class="line">                t=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">insert</span>(bank[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;string &gt; rec;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        rec.<span class="built_in">insert</span>(startGene);</span><br><span class="line">        <span class="type">char</span> dic[<span class="number">4</span>]=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> n=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span>  cur=q.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//                cout&lt;&lt;cur&lt;&lt;endl;</span></span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur==endGene)<span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cur.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                        string b=cur;</span><br><span class="line"></span><br><span class="line">                        b[j]=dic[k];</span><br><span class="line"><span class="comment">//                        cout&lt;&lt;cur&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(st.<span class="built_in">count</span>(b))&#123;</span><br><span class="line">                            <span class="keyword">if</span>(!rec.<span class="built_in">count</span>(b))&#123;</span><br><span class="line">                                q.<span class="built_in">push</span>(b);</span><br><span class="line">                                rec.<span class="built_in">insert</span>(b);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="752-打开转盘锁"><a href="#752-打开转盘锁" class="headerlink" title="752. 打开转盘锁"></a><a href="https://leetcode.cn/problems/open-the-lock/">752. 打开转盘锁</a></h2><p>最小步数模型，就是这样的模板，修改，如果为9，就变0或者8</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">openLock</span><span class="params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//状态转移,使用最小步数模型,使用bfs</span></span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        unordered_map&lt;string,<span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; deadends.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            rec[deadends[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec.<span class="built_in">find</span>(<span class="string">&quot;0000&quot;</span>)!=rec.<span class="built_in">end</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        rec[<span class="string">&quot;0000&quot;</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> n=q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cur=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//                cout&lt;&lt;cur&lt;&lt;&quot; &quot;;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur==target)<span class="keyword">return</span> ans;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> a= <span class="built_in">up</span>(cur,j);</span><br><span class="line">                    <span class="keyword">auto</span> b= <span class="built_in">down</span>(cur,j);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(rec.<span class="built_in">find</span>(a)==rec.<span class="built_in">end</span>())&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(a);</span><br><span class="line">                        rec[a]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(rec.<span class="built_in">find</span>(b)==rec.<span class="built_in">end</span>())&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(b);</span><br><span class="line">                        rec[b]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每一次++</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">up</span><span class="params">(string s,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            s[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s[i]=s[i]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">down</span><span class="params">(string s,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            s[i]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s[i]=s[i]<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-DFS"><a href="#2-DFS" class="headerlink" title="2.DFS"></a>2.DFS</h1><p>dfs一般就是爆搜，进行排列组合，组合数，一般就是直接sort，排列数，就是使用st数组，然后continue条件就是排列是0，组合是u</p><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h2><p>这个是组合数，u&#x3D;，直接push进去。正常的回溯教程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string strs[<span class="number">10</span>] = &#123;</span><br><span class="line">            <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">empty</span>())<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">dfs</span>(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string digits,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;digits.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> n=digits[u]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[n].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(strs[n][i]);</span><br><span class="line">            <span class="built_in">dfs</span>(digits,u+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><p>这个条件就是左括号大于右括号，左右括号的值相等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string path;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">2</span>*n)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;path&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="keyword">if</span>(rec.<span class="built_in">find</span>(<span class="string">&#x27;(&#x27;</span>)==rec.<span class="built_in">end</span>()||rec[<span class="string">&#x27;(&#x27;</span>]&lt;n)&#123;</span><br><span class="line">            path+=<span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            rec[<span class="string">&#x27;(&#x27;</span>]++;</span><br><span class="line">            <span class="built_in">dfs</span>(n,u+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            rec[<span class="string">&#x27;(&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec.<span class="built_in">find</span>(<span class="string">&#x27;)&#x27;</span>)==rec.<span class="built_in">end</span>()||rec[<span class="string">&#x27;)&#x27;</span>]&lt;rec[<span class="string">&#x27;(&#x27;</span>])&#123;</span><br><span class="line">            path+=<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            rec[<span class="string">&#x27;)&#x27;</span>]++;</span><br><span class="line">            <span class="built_in">dfs</span>(n,u+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            rec[<span class="string">&#x27;)&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独</a></h2><p>数独解法就是回溯，然后还是使用多个数组来进行，初始化每一个有的点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> row[<span class="number">9</span>][<span class="number">9</span>],col[<span class="number">9</span>][<span class="number">9</span>],block[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(row,<span class="literal">false</span>,<span class="keyword">sizeof</span> row);</span><br><span class="line">        <span class="built_in">memset</span>(col,<span class="literal">false</span>,<span class="keyword">sizeof</span> col);</span><br><span class="line">        <span class="built_in">memset</span>(block,<span class="literal">false</span>,<span class="keyword">sizeof</span> block);</span><br><span class="line">        <span class="comment">//初始化所有的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> t=board[i][j]-<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    row[i][t]=<span class="literal">true</span>;</span><br><span class="line">                    col[j][t]=<span class="literal">true</span>;</span><br><span class="line">                    block[i/<span class="number">3</span>][j/<span class="number">3</span>][t]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(board,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y==<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="comment">//进入下一轮</span></span><br><span class="line">            x++;</span><br><span class="line">            y=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断当前点是不是.可以填入</span></span><br><span class="line">        <span class="keyword">if</span> (board[x][y]!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(board,x,y+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;<span class="number">9</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[x][i]||col[y][i]||block[x/<span class="number">3</span>][y/<span class="number">3</span>][i])<span class="keyword">continue</span>;</span><br><span class="line">                row[x][i]=col[y][i]=block[x/<span class="number">3</span>][y/<span class="number">3</span>][i]=<span class="literal">true</span>;</span><br><span class="line">                board[x][y]=<span class="string">&#x27;0&#x27;</span>+i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(board,x,y+<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                board[x][y]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                row[x][i]=col[y][i]=block[x/<span class="number">3</span>][y/<span class="number">3</span>][i]=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><p>因为是组合，所以所以使用sort，还有continue，从u开始</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> u,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index==nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(u&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums,u-nums[i],i);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h2><p>这个就是药continue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> target,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;=nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;target&lt;&lt;&quot;  &quot;;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;target)<span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;u&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums,target-nums[i],i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//            rec[nums[i]]=1;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2><p>他这个前导0，需要用进行替换，用u+1代替s。szie</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        start=<span class="number">0</span>,end=<span class="number">255</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(s,<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s,<span class="type">int</span> times,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不出现011</span></span><br><span class="line">        <span class="comment">//只有3个小数点可以进行加入</span></span><br><span class="line">        <span class="keyword">if</span> (!times&amp;&amp;u==s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (times&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;=s.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> n=u+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[u]!=<span class="string">&#x27;0&#x27;</span>)n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// if(s[u]==&#x27;0&#x27;)&#123;</span></span><br><span class="line">        <span class="comment">//     path+=&quot;0.&quot;;</span></span><br><span class="line">        <span class="comment">//     dfs(s,times-1,u+1);</span></span><br><span class="line">        <span class="comment">//     return ;</span></span><br><span class="line">        <span class="comment">// &#125;else&#123;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-u+<span class="number">1</span>&gt;<span class="number">3</span>)<span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">auto</span> x=s.<span class="built_in">substr</span>(u,i-u+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> t= <span class="built_in">stoi</span>(x);</span><br><span class="line">                <span class="keyword">if</span>(t&lt;=<span class="number">255</span>)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> back=path;</span><br><span class="line">                    path+=x+<span class="string">&quot;.&quot;</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(s,times<span class="number">-1</span>,i+<span class="number">1</span>);</span><br><span class="line">                    path=back;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h2><p>找出不同的bst，我们设置根节点为0到n-1，没次遍历，然后左右两边设置为左右树，同事也对每一个左右节点来作为root的左右</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 进行建树，从1-n开始，可以改成1-l-1，l，和l+1到n</span></span><br><span class="line">        vector&lt;TreeNode*&gt; ans=<span class="built_in">dfs</span>(<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)&#123;</span><br><span class="line">             res.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; left=<span class="built_in">dfs</span>(l,i<span class="number">-1</span>);</span><br><span class="line">        vector&lt;TreeNode*&gt; right=<span class="built_in">dfs</span>(i+<span class="number">1</span>,r);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接着就是左右节点的选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;L:left)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;R:right)&#123;</span><br><span class="line">                TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                    root-&gt;left = L;</span><br><span class="line">                    root-&gt;right = R;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="310-最小高度树"><a href="#310-最小高度树" class="headerlink" title="310. 最小高度树"></a><a href="https://leetcode.cn/problems/minimum-height-trees/">310. 最小高度树</a></h2><p>建图也tle，使用树形dp，下次在写</p><h2 id="386-字典序排数"><a href="#386-字典序排数" class="headerlink" title="386. 字典序排数"></a><a href="https://leetcode.cn/problems/lexicographical-numbers/">386. 字典序排数</a></h2><p>这个的思路还是首先dfs，如果大于了，就返回，然后直接push</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lexicalOrder</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string path;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="built_in">to_string</span>(n),<span class="number">0</span>,path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s ,<span class="type">int</span> u,string path)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(u&gt;s.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;<span class="number">0</span>&amp;&amp;<span class="built_in">stoi</span>(s)&lt; <span class="built_in">stoi</span>(path))&#123;</span><br><span class="line"><span class="comment">//            ans.push_back(stoi(path));</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(u)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">0</span>)start=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;=<span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> b=path;</span><br><span class="line">            path+= <span class="built_in">to_string</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(s,u+<span class="number">1</span>,path);</span><br><span class="line">            path=b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先对u来进行判断，u&#x3D;0，只能从1开始，其他都是</p><h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h2><p>双重dfs，这个题目，首先第一次是遍历，第二次就是进行对以他为root，来查找路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//两个dfs，第一个遍历点，第二几个计算</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        x=targetSum;</span><br><span class="line">        <span class="built_in">dfs1</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(root,x-root-&gt;val);</span><br><span class="line"><span class="comment">//        cout&lt;&lt;&quot;-----------&quot;&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">dfs1</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">dfs1</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(TreeNode* root, <span class="type">long</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(targetSum==<span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//       cout&lt;&lt;targetSum&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)<span class="built_in">dfs2</span>(root-&gt;left,targetSum-root-&gt;left-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)<span class="built_in">dfs2</span>(root-&gt;right,targetSum-root-&gt;right-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="473-火柴拼正方形"><a href="#473-火柴拼正方形" class="headerlink" title="473. 火柴拼正方形"></a><a href="https://leetcode.cn/problems/matchsticks-to-square/">473. 火柴拼正方形</a></h2><p>这个就是和之前的分组都是一样的，可以看成k&#x3D;4，求解4个相等的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; st;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">makesquare</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; matchsticks)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum= <span class="built_in">accumulate</span>(matchsticks.<span class="built_in">begin</span>(),matchsticks.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">4</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> k=sum/<span class="number">4</span>;</span><br><span class="line">        <span class="built_in">sort</span>(matchsticks.<span class="built_in">begin</span>(),matchsticks.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(matchsticks.<span class="built_in">back</span>()&gt;k)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        st=<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(matchsticks.<span class="built_in">size</span>(),<span class="literal">false</span>);</span><br><span class="line">        x=k;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(matchsticks,x,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span>  <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> target,<span class="type">int</span> index,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">4</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;u;</span></span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dfs</span>(nums,x,<span class="number">0</span>,u+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//        if(target&lt;0)return false;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[i]&amp;&amp;target-nums[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                st[i]=<span class="literal">true</span>;</span><br><span class="line"><span class="comment">//                path.push_back(nums[i]);</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(nums,target-nums[i],i+<span class="number">1</span>,u))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                st[i]=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//                path.pop_back();</span></span><br><span class="line">                <span class="comment">//排好序了的,如果当前都没办法减少到0,后面就不可能</span></span><br><span class="line">                <span class="keyword">if</span> (target==x)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后还是使用index开始，最后的一个剪纸条件就是，无论如何这个target都不在改变，那就是失败了。我们可以把target看成某一成的值，但是他在这一层不变，说明以后的层也不变</p><h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h2><p>dfs两次操作就是+，-</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums,<span class="number">0</span>,target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> u,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==nums.<span class="built_in">size</span>()&amp;&amp;target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;=nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums,u+<span class="number">1</span>,target-nums[u]);</span><br><span class="line">        <span class="built_in">dfs</span>(nums,u+<span class="number">1</span>,target+nums[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-BFS&quot;&gt;&lt;a href=&quot;#1-BFS&quot; class=&quot;headerlink&quot; title=&quot;1.BFS&quot;&gt;&lt;/a&gt;1.BFS&lt;/h1&gt;&lt;p&gt;bfs主要包括一下应用，flood fill（洪水灌溉）把所有的值进行填充man，最小步数模型，就是最先到达的形态，</summary>
      
    
    
    
    
    <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
    <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>贪心</title>
    <link href="http://yoursite.com/2023/02/03/%E8%B4%AA%E5%BF%83/"/>
    <id>http://yoursite.com/2023/02/03/%E8%B4%AA%E5%BF%83/</id>
    <published>2023-02-03T08:33:54.000Z</published>
    <updated>2023-02-03T08:56:16.026Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="http://yoursite.com/2023/01/27/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://yoursite.com/2023/01/27/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2023-01-27T03:54:55.000Z</published>
    <updated>2023-01-27T07:47:03.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1.滑动窗口"></a>1.滑动窗口</h1><p>固定的模板talus就是,设置l,r,首先r++,当满足超过窗口大小的时候,使用while循环,来进行l++,之道跳出这个while循环,最后,还是r&lt;size</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.<span class="built_in">add</span>(s[right]);</span><br><span class="line">    right++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.<span class="built_in">remove</span>(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="76最小覆盖字串"><a href="#76最小覆盖字串" class="headerlink" title="76最小覆盖字串"></a>76最小覆盖字串</h2><p>这个的窗口大小就是t字符串不同的数量,当相等的时候,就进行比较最大值,然后进行移除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:t)&#123;</span><br><span class="line">            rec[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> total=rec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//u是总数,当前的,窗口条件,dp</span></span><br><span class="line">        string ans=s;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>,len=INT_MAX;</span><br><span class="line">       <span class="keyword">while</span>(i&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">           <span class="keyword">if</span> (rec.<span class="built_in">find</span>(s[i])!=rec.<span class="built_in">end</span>())&#123;</span><br><span class="line">               cnt[s[i]]++;</span><br><span class="line">               <span class="keyword">if</span>(cnt[s[i]]==rec[s[i]])&#123;</span><br><span class="line">                   u++;</span><br><span class="line">                   <span class="comment">//统计有多少个了</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//下面是提纯操作,进行更新什么的</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span>(u==total)&#123;</span><br><span class="line">               flag=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(i-j+<span class="number">1</span>&lt;len)&#123;</span><br><span class="line">                    start=j;</span><br><span class="line">                    len=i-j+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="keyword">if</span>(rec.<span class="built_in">find</span>(s[j])!=rec.<span class="built_in">end</span>())&#123;</span><br><span class="line">                   cnt[s[j]]--;</span><br><span class="line">                   <span class="keyword">if</span>(cnt[s[j]]&lt;rec[s[j]])&#123;</span><br><span class="line">                       u--;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">           i++;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(!flag)<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></h2><p>这个和上一题差不多,也是</p><p>这个思路,然后就是如果长度一样,那么就是直接返回true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; rec,window;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s1)rec[c]++;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;s2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c=s2[l];</span><br><span class="line">            <span class="keyword">if</span>(rec.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span> (window[c]==rec[c])u++;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">while</span>(u==rec.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(l-r==s1.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">auto</span> t=s2[r];</span><br><span class="line">                <span class="keyword">if</span>(rec.<span class="built_in">count</span>(t))&#123;</span><br><span class="line">                    window[t]--;</span><br><span class="line">                    <span class="keyword">if</span>(window[t]&lt;rec[t])&#123;</span><br><span class="line">                        u--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>求出最大的最长字串,那么这个窗口就是每一个字母出现的次数就是1,超过1,就开始进行滑动窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> c=s[r];</span><br><span class="line">            rec[c]++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//abb</span></span><br><span class="line">            <span class="keyword">while</span>(rec[s[r]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> t=s[l];</span><br><span class="line">                rec[t]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,r-l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></h2><p>这个就是滑动窗口是0出现的次数，然后如果超过k，就进行更新</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//窗口值就是k，放的是0</span></span><br><span class="line"><span class="comment">//        unordered_map&lt;int,int&gt; rec;</span></span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> c=nums[r];</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">0</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">while</span>(cnt&gt;k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]==<span class="number">0</span>)&#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时就是cnt==k</span></span><br><span class="line">            ans=<span class="built_in">max</span>(ans,r-l);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></h2><p>这个的滑动窗口就是最大值减去最小值是小于k，所以一旦超过就进行更新，使用set可以来得到最大值还有最小值，然后进行计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int l=0,r=0;</span></span><br><span class="line"><span class="comment">//        int ans=0;</span></span><br><span class="line"><span class="comment">//        multiset&lt;int&gt; s;</span></span><br><span class="line"><span class="comment">//        while(r&lt;nums.size())&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            s.insert(nums[r]);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            while(*s.rbegin()-*s.rend()&gt;limit)&#123;</span></span><br><span class="line"><span class="comment">//                s.erase(s.find(nums[l]));</span></span><br><span class="line"><span class="comment">//                l++;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            r++;</span></span><br><span class="line"><span class="comment">//            ans= max(ans,r-l);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return ans;</span></span><br><span class="line">        multiset&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            st.<span class="built_in">insert</span>(nums[right]);</span><br><span class="line">            <span class="keyword">while</span> (*st.<span class="built_in">rbegin</span>() - *st.<span class="built_in">begin</span>() &gt; limit) &#123;</span><br><span class="line">                st.<span class="built_in">erase</span>(st.<span class="built_in">find</span>(nums[left]));</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">is_ok</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">            t=<span class="built_in">max</span>(<span class="built_in">abs</span>(nums[r]-nums[i]),t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(t, <span class="built_in">is_ok</span>(nums,l,r<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1658-将-x-减到-0-的最小操作数"><a href="#1658-将-x-减到-0-的最小操作数" class="headerlink" title="1658. 将 x 减到 0 的最小操作数"></a><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/">1658. 将 x 减到 0 的最小操作数</a></h2><p>这个的思路就是计算最左+最右&#x3D;5，那我们可以计算中间的&#x3D;整体的-5，然后我们可以使用前缀和，来进行计算，如果等于了，就来计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//这题思路就是统计中间数值是acc（nums）-x的最大距离</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum= <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> target=sum-x;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag= <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            u+=nums[r];</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">while</span>(u&gt;target)&#123;</span><br><span class="line"></span><br><span class="line">                u-=nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (u==target)&#123;</span><br><span class="line">                flag= <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(r-l&gt;res)&#123;</span><br><span class="line">                    res=r-l;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>()-res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    int dfs(vector&lt;int&gt; &amp;nums,int l,int r,int &amp;x)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        if(x&lt;0||l&gt;r)return -1;</span></span><br><span class="line"><span class="comment">//        if(x==0)&#123;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        int t=x;</span></span><br><span class="line"><span class="comment">//        x-=nums[r];</span></span><br><span class="line"><span class="comment">//        auto l1= dfs(nums,l,r-1,x)+1;</span></span><br><span class="line"><span class="comment">//        t-=nums[l];</span></span><br><span class="line"><span class="comment">//        x=t;</span></span><br><span class="line"><span class="comment">//        auto r1= dfs(nums,l+1,r,x)+1;</span></span><br><span class="line"><span class="comment">//        if (l1==-1&amp;&amp;r1==-1)&#123;</span></span><br><span class="line"><span class="comment">//            return -1;</span></span><br><span class="line"><span class="comment">//        &#125;else if (l1==-1)&#123;</span></span><br><span class="line"><span class="comment">//            return r1;</span></span><br><span class="line"><span class="comment">//        &#125; else if(r1==-1)&#123;</span></span><br><span class="line"><span class="comment">//            return l1;</span></span><br><span class="line"><span class="comment">//        &#125;else&#123;</span></span><br><span class="line"><span class="comment">//            return min(l1,r1);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h2><p>这个也还是普通的滑动窗口，大小也是这个k来作为窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> ans=INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (r&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            u+=nums[r++];</span><br><span class="line">            <span class="keyword">while</span>(u&gt;=target)&#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,r-l);</span><br><span class="line">                u-=nums[l++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a><a href="https://leetcode.cn/problems/contains-duplicate-ii/">219. 存在重复元素 II</a></h2><p>检查是不是有重复的，使用双指针，来进行计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">       unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line">       <span class="keyword">while</span>(r&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">           rec[nums[r]]++;</span><br><span class="line">           <span class="keyword">while</span>(rec[nums[r]]==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//               cout&lt;&lt;&quot;ok&quot;;</span></span><br><span class="line">               <span class="keyword">if</span>(nums[l]==nums[r]&amp;&amp;r-l&lt;=k)&#123;</span><br><span class="line">                   cout&lt;&lt;r&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">               rec[nums[l]]--;</span><br><span class="line">               l++;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           r++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="220-存在重复元素-III"><a href="#220-存在重复元素-III" class="headerlink" title="220. 存在重复元素 III"></a><a href="https://leetcode.cn/problems/contains-duplicate-iii/">220. 存在重复元素 III</a></h2><p>这是上面一个题目的扩张，有两个值来进行计算，使用set来进行计算。首先找到比当前值num【i】-t大的值，如果没有就跳过，有而且还满足就是true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int indexDiff, int valueDiff) &#123;</span><br><span class="line">        int l=0,r=0;</span><br><span class="line">        set&lt;long&gt;st;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            auto lb = st.lower_bound((long)nums[i] - valueDiff);</span><br><span class="line">            if (lb != st.end() &amp;&amp; *lb &lt;= (long)nums[i] + valueDiff) return 1;</span><br><span class="line">            st.insert(nums[i]);</span><br><span class="line">            if (i &gt;= indexDiff) st.erase(nums[i - indexDiff]);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="395-至少有-K-个重复字符的最长子串"><a href="#395-至少有-K-个重复字符的最长子串" class="headerlink" title="395. 至少有 K 个重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></h2><p>选出至少有k个，这个提普通的窗口没有办法处理，使用枚举的方法，我们手动设置窗口，1-26为出现不同的异构字母，然后满足的窗口来进行滑动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;char,int&gt; PII;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">// 思路枚举出现不同的次数，作为窗口，，1-26，就是串口的大小，然后进行计算</span><br><span class="line">//int longestSubstring(string s, int k) &#123;</span><br><span class="line"></span><br><span class="line">    int k;</span><br><span class="line">    unordered_map&lt;char,int&gt;cnt;//字符的个数</span><br><span class="line">    void add(char c ,int&amp; x ,int&amp; y)&#123;</span><br><span class="line">        if(!cnt[c])x++;//如果当前字符以前没有,不同字符种数++</span><br><span class="line">        cnt[c]++;</span><br><span class="line">        if(cnt[c] == k)y++;//如果加上c之后,刚好满足条件(即字符c的个数不少于k),则满足条件的字符种数++</span><br><span class="line">    &#125;</span><br><span class="line">    void del(char c, int&amp; x , int&amp; y)&#123;</span><br><span class="line">        if(cnt[c] == k)y--;//如果当前c字符刚好满足条件,则去掉一个后,不再满足条件,则满足条件的字符种数--</span><br><span class="line">        cnt[c]--;</span><br><span class="line">        if(!cnt[c])x--;//如果刚好字符c删没了,则不同字符种数--</span><br><span class="line">    &#125;</span><br><span class="line">    int longestSubstring(string s, int _k) &#123;</span><br><span class="line">        k=_k;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        if(n &lt; k)return 0;</span><br><span class="line">        //允许字符的种数</span><br><span class="line">        for(int c = 1 ; c &lt;= 26 ; c++)&#123;//只允许一个字符,只允许两个字符,...</span><br><span class="line">            cnt.clear();</span><br><span class="line">            //i是遍历在前面的指针,j是遍历在后面的指针,x是当前窗口内不同字符的种数,y是当前窗口内满足条件的字符的种数</span><br><span class="line">            for(int i = 0 ,j = 0 , x = 0 , y = 0; i &lt; n ; i ++)&#123;//遍历字符串s</span><br><span class="line">                add(s[i],x,y);//每次先选先把字符加进来,并更新x和y</span><br><span class="line">                while(x&gt;c)del(s[j++],x,y);//当窗口内遍历到的字符种数超过了当前允许的字符的种数,就删除窗口的末端</span><br><span class="line">                if(x == y)res = max(res ,i-j+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424.替换后的最长重复字符"></a>424.<a href="https://leetcode.cn/problems/longest-repeating-character-replacement/">替换后的最长重复字符</a></h2><p>这个的思路就是r-l-1-max（字符串)&lt;&#x3D;k,所以我们的思路就是进行查找最大值字母</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">characterReplacement</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">// 两个指针</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> Max = <span class="number">-1</span>; <span class="comment">// 当前区间出现最多的字符数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span> &gt; <span class="title">nums</span><span class="params">(<span class="number">26</span>)</span></span>;  <span class="comment">// 用来统计字符出现的个数</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(right &lt; n)&#123;</span><br><span class="line">            <span class="comment">// 每次去更新字符出现的最大数</span></span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            nums[c - <span class="string">&#x27;A&#x27;</span>] ++ ;</span><br><span class="line">            Max = <span class="built_in">max</span>(Max, nums[c - <span class="string">&#x27;A&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断区间是否满足条件 注意这里当left++的时候，要提前更新Max，在left++</span></span><br><span class="line">            <span class="keyword">while</span>(right - left + <span class="number">1</span> - Max &gt; k)&#123;</span><br><span class="line">                nums[s[left] - <span class="string">&#x27;A&#x27;</span>] --;</span><br><span class="line">                Max = <span class="built_in">max</span>(Max, nums[s[left] - <span class="string">&#x27;A&#x27;</span>]);</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时的 [left, right]的区间一定是满足条件的，更新答案即可。</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="713-乘积小于-K-的子数组"><a href="#713-乘积小于-K-的子数组" class="headerlink" title="713. 乘积小于 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a></h2><p>这个题目的思路还是比较简单，主要的是如何进行求和。当l到r满足小于的，l+1，l+2的一定也满足，那么ans+&#x3D;r-l+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> u=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            u*=nums[r];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(u&gt;=k)&#123;</span><br><span class="line">                u/=nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=r-l+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//因为l到r满足小于k，l+1到r也是，l+2到r也是</span></span><br><span class="line"><span class="comment">//            那么就是计算l到r的距离</span></span><br><span class="line">            r++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-滑动窗口&quot;&gt;&lt;a href=&quot;#1-滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;1.滑动窗口&quot;&gt;&lt;/a&gt;1.滑动窗口&lt;/h1&gt;&lt;p&gt;固定的模板talus就是,设置l,r,首先r++,当满足超过窗口大小的时候,使用while循环,来进行l++</summary>
      
    
    
    
    
    <category term="滑动窗口" scheme="http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>回溯总结</title>
    <link href="http://yoursite.com/2023/01/26/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2023/01/26/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93/</id>
    <published>2023-01-26T03:03:40.000Z</published>
    <updated>2023-01-27T04:01:08.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-回溯总结"><a href="#1-回溯总结" class="headerlink" title="1.回溯总结"></a>1.回溯总结</h1><p>主要参考下面的题目，<a href="https://www.programmercarl.com/">代码随想</a>，还有<a href="https://labuladong.github.io/algo/di-san-zha-24031/">labuladong</a>，这个类型的主要思路就是，找</p><p>到结束条件，然后就是进行选择，放入之后，就再次进行放出</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>包含下面几个题目</p><h2 id="46全排列"><a href="#46全排列" class="headerlink" title="46全排列"></a>46全排列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; st;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        st=<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; (nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[i])&#123;</span><br><span class="line">                st[i]=<span class="literal">true</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(nums,u+<span class="number">1</span>);</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                st[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先还是使用ans进行保存，使用st进行验证，u代表成功的个数，当为n，就是可以进行添加，从0开始进行访问所有的值</p><h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51.N皇后"></a>51.N皇后</h2><p>这个题目就是进行求解，他的check条件就是列上没有，，斜线上没有，斜线就是当前的点（x-1，y-1），（x-1，y+1），检查这些值有没有，没有就放，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        res=<span class="built_in">vector</span>&lt;string&gt;(n,<span class="built_in">string</span>(n,<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">        <span class="built_in">dfs</span>(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==u)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isok</span>(u,i))&#123;</span><br><span class="line">                res[u][i]=<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(n,u+<span class="number">1</span>);</span><br><span class="line">                res[u][i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isok</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">//统计每一个竖起来的</span></span><br><span class="line">        <span class="comment">//统计左上还有右下</span></span><br><span class="line">        <span class="type">int</span> n=res.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;=u; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(res[j][i]==<span class="string">&#x27;Q&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//45°检查</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = u<span class="number">-1</span>,k=i<span class="number">-1</span>; j&gt;=<span class="number">0</span>&amp;&amp;k&gt;=<span class="number">0</span> ; j--,k--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(res[j][k]==<span class="string">&#x27;Q&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = u<span class="number">-1</span>,k=i+<span class="number">1</span>; j&gt;=<span class="number">0</span>&amp;&amp;k&lt;n ; j--,k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(res[j][k]==<span class="string">&#x27;Q&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="112路径总和"><a href="#112路径总和" class="headerlink" title="112路径总和"></a>112路径总和</h2><p>从根节点开始寻找，两种dfs方式，一种就是在for循环里面进行回溯，还有一种在最开始进行回溯。</p><p>这个就是在里面进行回溯，因为是直接开始减的，所以，不需要把target还原</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root,targetSum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target==<span class="number">0</span>&amp;&amp;!root-&gt;left&amp;&amp;!root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        if (target&lt;0)return false;</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="type">bool</span> left= <span class="built_in">dfs</span>(root-&gt;left,target-root-&gt;left-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (left)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(root-&gt;right,target-root-&gt;right-&gt;val))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="140-单词拆分"><a href="#140-单词拆分" class="headerlink" title="140.单词拆分"></a>140.单词拆分</h2><p>这个题目还是回溯，本质就是对i从u开始，进行截取，然后，看是不是在指点里面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; rec;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:wordDict)&#123;</span><br><span class="line">            rec[word]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="comment">//排除末尾</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            path+=<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt;s.<span class="built_in">size</span>() ; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t=s.<span class="built_in">substr</span>(u,i-u+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(rec.<span class="built_in">find</span>(t)!=rec.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">auto</span> x=path;</span><br><span class="line">                path+=t+<span class="string">&quot; &quot;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(s,i+<span class="number">1</span>);</span><br><span class="line">                path=x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="17-电话组合"><a href="#17-电话组合" class="headerlink" title="17.电话组合"></a>17.电话组合</h2><p>还不是组合一样，放入字符串里面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string strs[<span class="number">10</span>] = &#123;</span><br><span class="line">            <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">empty</span>())<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">dfs</span>(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string digits,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;digits.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> n=digits[u]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[n].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(strs[n][i]);</span><br><span class="line">            <span class="built_in">dfs</span>(digits,u+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string path;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">2</span>*n)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;path&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="keyword">if</span>(rec.<span class="built_in">find</span>(<span class="string">&#x27;(&#x27;</span>)==rec.<span class="built_in">end</span>()||rec[<span class="string">&#x27;(&#x27;</span>]&lt;n)&#123;</span><br><span class="line">            path+=<span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            rec[<span class="string">&#x27;(&#x27;</span>]++;</span><br><span class="line">            <span class="built_in">dfs</span>(n,u+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            rec[<span class="string">&#x27;(&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec.<span class="built_in">find</span>(<span class="string">&#x27;)&#x27;</span>)==rec.<span class="built_in">end</span>()||rec[<span class="string">&#x27;)&#x27;</span>]&lt;rec[<span class="string">&#x27;(&#x27;</span>])&#123;</span><br><span class="line">            path+=<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            rec[<span class="string">&#x27;)&#x27;</span>]++;</span><br><span class="line">            <span class="built_in">dfs</span>(n,u+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            rec[<span class="string">&#x27;)&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>两个剪纸，一个是长度都是n，括号，还有一个就是右括号小于左的</p><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h2><p>这个就是组合数，使用i到u进行遍历，然后还有一个就是，直接从i开始，不是i+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> u,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index==nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(u&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums,u-nums[i],i);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这个就是从i即系开始，可以重复使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; c, int target) &#123;</span><br><span class="line">            dfs(c,0,target);</span><br><span class="line">            return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; c,int u,int target )&#123;</span><br><span class="line">        // u代表当前循环到哪一个了数字呢</span><br><span class="line">        // 考虑边界</span><br><span class="line">        if(target==0)&#123;</span><br><span class="line">            ans.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(u==c.size())&#123;</span><br><span class="line">            return;</span><br><span class="line">            // 直接返回</span><br><span class="line">        &#125;</span><br><span class="line">        // 接下来就是放入放出</span><br><span class="line">        for(int i=0;i*c[u]&lt;=target;i++)&#123;</span><br><span class="line"></span><br><span class="line">            dfs(c,u+1,target-i*c[u]);</span><br><span class="line">            path.push_back(c[u]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 这是选择加入一个后，再对后面的进行加入</span><br><span class="line">            // target-i*c[u]是加入当前的次数，u+1是下一个值</span><br><span class="line">             // 回复现场</span><br><span class="line">             </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i*c[u]&lt;=target;i++)&#123;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>这个代码很不错，因为是先dfs然后再push，为什么了，因为先dfs，代表选0个当前的，之后放入一个，就是选了一个dfs，而且是在dfs之后选择下一个值，而且，target因为是没有变，所以直接减去i*cu</strong></p><h2 id="698-划分k个相等的子集"><a href="#698-划分k个相等的子集" class="headerlink" title="698.划分k个相等的子集"></a>698.划分k个相等的子集</h2><p>首先的先决条件就是sum数组的和可以整除k，而且最后一个数，一定小于平均数。之后就是进行回溯，代码思路，使用dfs(nums,avg,k,u)</p><p>含义就是当avg为0的时候，可以进行k-1（表示又有一组满足了，然后u从开始进行寻找，avg再次恢复到初始值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt;path;</span><br><span class="line">    vector&lt;bool&gt; st;</span><br><span class="line">    int t;</span><br><span class="line">    int avg;</span><br><span class="line">    bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">         auto sum=accumulate(nums.begin(),nums.end(),0);</span><br><span class="line">        if(sum%k!=0)return false;</span><br><span class="line">        st=vector&lt;bool&gt;(nums.size(),false);</span><br><span class="line">        int target=sum/k;</span><br><span class="line">        if (nums.back()&gt;target)return false;</span><br><span class="line">//</span><br><span class="line">        t=k;</span><br><span class="line">        avg=target;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        return dfs(nums,target,0,0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    bool  dfs(vector&lt;int&gt; &amp;nums,int target,int index,int u)&#123;</span><br><span class="line">        if(u==t)return true;</span><br><span class="line">//        cout&lt;&lt;u;</span><br><span class="line">        if(target==0)return dfs(nums,avg,0,u+1);</span><br><span class="line">//        if(target&lt;0)return false;</span><br><span class="line">        for (int i = index; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            if(!st[i]&amp;&amp;target-nums[i]&gt;=0)&#123;</span><br><span class="line">                st[i]=true;</span><br><span class="line">//                path.push_back(nums[i]);</span><br><span class="line">                if(dfs(nums,target-nums[i],i+1,u))&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                st[i]=false;</span><br><span class="line">//                path.pop_back();</span><br><span class="line">                    //排好序了的,如果当前都没办法减少到0,后面就不可能</span><br><span class="line">                if (target==avg)return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>if (target&#x3D;&#x3D;avg)return false;重要剪纸，当表示值不变还是avg，就表示后面更不可能进行减少值，因为后面的都比当前值大，target会一直不变，所以不能选择，直接失败</strong></p><h2 id="77-组合数"><a href="#77-组合数" class="headerlink" title="77.组合数"></a>77.组合数</h2><p>组合数，就是进行选择，首先进行排序，i到u开始，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rec;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt;st;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        st=<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; (n+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!k)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(rec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; n+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">            rec.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(n,k<span class="number">-1</span>,i+<span class="number">1</span>);</span><br><span class="line">            rec.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="78-幂集"><a href="#78-幂集" class="headerlink" title="78,幂集"></a>78,幂集</h2><p>就是返回所有的选择,直接在上面的进行手动设置k</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rec;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(nums,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> k,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!k)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(rec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            rec.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums,k<span class="number">-1</span>,i+<span class="number">1</span>);</span><br><span class="line">            rec.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="40-组合综合"><a href="#40-组合综合" class="headerlink" title="40.组合综合"></a>40.组合综合</h2><p>进行筛选,而且不能含有重复的,首先进行选择就是i到u,去重就是要使用那个continue,与前面相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> target,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;=nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;target&lt;&lt;&quot;  &quot;;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;target)<span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;u&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums,target-nums[i],i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//            rec[nums[i]]=1;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>if (i&gt;u&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1])continue;去重代码,不需要使用st,来表示,因为后面都是没有访问的</p><h2 id="216-组合综合"><a href="#216-组合综合" class="headerlink" title="216.组合综合"></a>216.组合综合</h2><p>还是之前一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,k,n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> k,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!n)ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k)&#123;</span><br><span class="line">            <span class="comment">// 说明还有字数需要</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n&gt;=i)&#123;</span><br><span class="line">                    path.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    <span class="built_in">dfs</span>(i+<span class="number">1</span>,k<span class="number">-1</span>,n-i);</span><br><span class="line">                    path.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h2><p>还是之前一样,check条件就是是不是会问,如果是true,直接返回</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> x=s.<span class="built_in">substr</span>(u,i-u+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">is_ok</span>(x))&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(x);</span><br><span class="line">                <span class="built_in">dfs</span>(s,i+<span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_ok</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x=s;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> x==s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="93复原ip地址"><a href="#93复原ip地址" class="headerlink" title="93复原ip地址"></a>93复原ip地址</h2><p>这个首先是对于0,直接继续,而且,一共只有4个小数点,最后一个在加入的时候去除,之后就是普通的回溯</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        start=<span class="number">0</span>,end=<span class="number">255</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(s,<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s,<span class="type">int</span> times,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不出现011</span></span><br><span class="line">        <span class="comment">//只有3个小数点可以进行加入</span></span><br><span class="line">        <span class="keyword">if</span> (!times&amp;&amp;u==s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (times&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;=s.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[u]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            path+=<span class="string">&quot;0.&quot;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(s,times<span class="number">-1</span>,u+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-u+<span class="number">1</span>&gt;<span class="number">3</span>)<span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">auto</span> x=s.<span class="built_in">substr</span>(u,i-u+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> t= <span class="built_in">stoi</span>(x);</span><br><span class="line">                <span class="keyword">if</span>(t&lt;=<span class="number">255</span>)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> back=path;</span><br><span class="line">                    path+=x+<span class="string">&quot;.&quot;</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(s,times<span class="number">-1</span>,i+<span class="number">1</span>);</span><br><span class="line">                    path=back;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>对于签到0的优化方法就是把循环的下一位变成u+1,不是s.size</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n=u+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[u]!=<span class="string">&#x27;0&#x27;</span>)n=s.<span class="built_in">size</span>();</span><br><span class="line">       </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; n; ++i) &#123;</span><br></pre></td></tr></table></figure><h2 id="90子集"><a href="#90子集" class="headerlink" title="90子集"></a>90子集</h2><p>这个就是进行去重,直接看是不是相等,然后continue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(nums,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> n,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;=nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i =u; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;u&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums,n<span class="number">-1</span>,i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为都是排序了的,后面一定没有访问,所以不用st</p><h2 id="47全排列"><a href="#47全排列" class="headerlink" title="47全排列"></a>47全排列</h2><p>进行去重,这个就是需要st数组,因为从是排列,而且需要进行去重,所以是从0开始的,需要st</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 这题的意思就是要融合，消去2个112</span></span><br><span class="line"><span class="comment">// 去重使用三个数之和的方法，是不是前面一个相同，相同就跳过了</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; st;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        path= <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">size</span>());</span><br><span class="line">        st= <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> u )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;&amp;nums[i<span class="number">-1</span>]==nums[i]&amp;&amp;!st[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 前面一个还没有使用，那就用前面那个1</span></span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                path[u] = nums[i];</span><br><span class="line">                <span class="built_in">dfs</span>(nums, u + <span class="number">1</span>);</span><br><span class="line">                st[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="491递增子序列"><a href="#491递增子序列" class="headerlink" title="491递增子序列"></a>491递增子序列</h2><p>因为没有排序,不能排序,所以只能使用set来进行作为</p><p>本人思路,就是对所有n的n从2到size进行遍历,然后加进去,使用set去除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    set&lt;vector&lt;<span class="type">int</span>&gt;&gt; s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;=nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(nums,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> n,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(path)==s.<span class="built_in">end</span>())&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">                s.<span class="built_in">insert</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt;nums.<span class="built_in">size</span>() ; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(path.<span class="built_in">empty</span>()||nums[i]&gt;=path.<span class="built_in">back</span>())&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(nums,n<span class="number">-1</span>,i+<span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-小结"><a href="#2-小结" class="headerlink" title="2.小结"></a>2.小结</h1><p>上面的几个经典题目,一个去重,前面相等直接跳过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(i&gt;u&amp;&amp;num[i]==num[i-1])continue</span><br></pre></td></tr></table></figure><p>第二个就是前导0的问题,一般是只能用做单独的0,那么距离就是u+1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n=s.size();</span><br><span class="line">if(s[i]==&#x27;0&#x27;)n=u+1:</span><br><span class="line">for(int i=u;i&lt;n;i++)</span><br></pre></td></tr></table></figure><p>第三个就是排列组合,排列的话就是从0开始,设置st数组.</p><p>组合的就是从u开始,去重和上面是一样的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-回溯总结&quot;&gt;&lt;a href=&quot;#1-回溯总结&quot; class=&quot;headerlink&quot; title=&quot;1.回溯总结&quot;&gt;&lt;/a&gt;1.回溯总结&lt;/h1&gt;&lt;p&gt;主要参考下面的题目，&lt;a href=&quot;https://www.programmercarl.com/&quot;&gt;代码</summary>
      
    
    
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2023/01/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2023/01/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-01-17T08:45:25.000Z</published>
    <updated>2023-01-18T04:14:12.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="1-设计模式"><a href="#1-设计模式" class="headerlink" title="1.设计模式"></a>1.设计模式</h1><p>设计模式主要包括一下三种创建者模式,结构模式还有行为模式</p><h1 id="2创建者模式"><a href="#2创建者模式" class="headerlink" title="2创建者模式"></a>2创建者模式</h1><p>主要包括以下工厂模式,单例模式,原型模式还有抽象工厂模式,最后是建造者模式</p><h2 id="2-1工厂模式"><a href="#2-1工厂模式" class="headerlink" title="2.1工厂模式"></a>2.1工厂模式</h2><p>简单点说:两个接口,一个食物类接口,一个工厂类接口,工厂接口来进行创建食物,使用工厂进行创建对象</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/loger.jpg"></p><h2 id="2-2抽象工厂模式"><a href="#2-2抽象工厂模式" class="headerlink" title="2.2抽象工厂模式"></a>2.2抽象工厂模式</h2><p>例子就是一个店子可以做咖啡还有甜品,所以继承工厂类,做两个视频,一个咖啡,一个蛋糕</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg"></p><p>可以看出,每一个工厂类都有做产品a还有做产品b的方法</p><h2 id="2-3单例模式"><a href="#2-3单例模式" class="headerlink" title="2.3单例模式"></a>2.3单例模式</h2><p>顾名思义就是无论如何,指挥产生一个对象instance,最简单的方法就是私有构造函数,然后使用静态变量生成instance,这届得到</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Singleton.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Singleton * Singleton::instance = <span class="literal">NULL</span>;</span><br><span class="line">Singleton::<span class="built_in">Singleton</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton::~<span class="built_in">Singleton</span>()&#123;</span><br><span class="line"><span class="keyword">delete</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Singleton::singletonOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;singletonOperation&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4建造者模式"><a href="#2-4建造者模式" class="headerlink" title="2.4建造者模式"></a>2.4建造者模式</h2><p>这个例子就是工厂工人做每一步,然后最后进行组装</p><p>todo:还没写完</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Builder.jpg"></p><h1 id="3-行为模式"><a href="#3-行为模式" class="headerlink" title="3.行为模式"></a>3.行为模式</h1><h2 id="3-1适配器模式"><a href="#3-1适配器模式" class="headerlink" title="3.1适配器模式"></a>3.1适配器模式</h2><p>例子:就是电源适配器(欧洲电源需要转接口才能使用),适配器就是转换头</p><p>所以我们需要实现欧洲的接口,但是继承国内的充电头,一个impl一个extend</p><p>然后在impl里面调用extend函数</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Adapter_classModel.jpg"></p><h2 id="3-2桥接模式"><a href="#3-2桥接模式" class="headerlink" title="3.2桥接模式"></a>3.2桥接模式</h2><p>主要是减少使用继承类,例如四边形,子类是长方形还有正方形,但是子类还有红色和蓝色的长方形</p><p>我们使用颜色类聚类到四边形里面,这样就可以减少子类,所以我们,我们在color里面实现,蓝色还有绿色,</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Bridge.jpg"></p><h2 id="3-3桥接模式"><a href="#3-3桥接模式" class="headerlink" title="3.3桥接模式"></a>3.3桥接模式</h2><p>就是代购火车票,方法都一样的,售票处售票,代购店也要售票,代购店售票的方法就是使用售票处的方法</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Proxy.jpg"></p><p>都要实现接口,同时调用真实接口</p><h2 id="3-4享元模式"><a href="#3-4享元模式" class="headerlink" title="3.4享元模式"></a>3.4享元模式</h2><p>贡献模式,每次调用都是相同的的值,但是修改一些属性而已</p><p>主要使用map,来得到相同的元素,map[i]</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Flyweight.jpg"></p><h2 id="3-5外观模式"><a href="#3-5外观模式" class="headerlink" title="3.5外观模式"></a>3.5外观模式</h2><p>基金经理帮我们来买股票,这样我们就不需自己进行选择股票</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Facade.jpg"></p><h2 id="3-6装饰模式"><a href="#3-6装饰模式" class="headerlink" title="3.6装饰模式"></a>3.6装饰模式</h2><p>就是炒饭+鸡蛋+肉+其他的,因此,炒房还有配料都要继承食物类别</p><p>同时配料类还要聚合食物类,这样就可以进行添加配料</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Decorator.jpg"></p><p>decorate是配料类,聚合食物类,设置get set方法,最后的总价价格&#x3D;this.getprice+this.getfood.getcost</p><h1 id="4-行为型模式"><a href="#4-行为型模式" class="headerlink" title="4.行为型模式"></a>4.行为型模式</h1><h2 id="4-1策略模式"><a href="#4-1策略模式" class="headerlink" title="4.1策略模式"></a>4.1策略模式</h2><p>最简单的模式,直接使用接口实现多个策略就可以,聚合策略就可以</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Strategy.jpg"></p><h2 id="4-2命令模式"><a href="#4-2命令模式" class="headerlink" title="4.2命令模式"></a>4.2命令模式</h2><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Command.jpg"></p><p>简单来说就是命令来控制厨师,让厨师做事,让服务员收拾订单</p><h2 id="4-3中介模式"><a href="#4-3中介模式" class="headerlink" title="4.3中介模式"></a>4.3中介模式</h2><p>中介这个人看碟子下菜,看对面是什么类型,然后调用不同的交互方法</p><p>使用get set方法来把中介者里面.</p><p>同时colleagues也要把中介放进去</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Mediator.jpg"></p><h2 id="4-4观察者模式"><a href="#4-4观察者模式" class="headerlink" title="4.4观察者模式"></a>4.4观察者模式</h2><p>例子就是订阅公众号,公众号添加用户,公众号推送更新,调用用户更新.使用list添加</p><p>subject是公众号,observe是微信用户,公众号的时候添加用户,使用for</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Obeserver.jpg"></p><h2 id="4-5状态模式"><a href="#4-5状态模式" class="headerlink" title="4.5状态模式"></a>4.5状态模式</h2><p>state是多个状态有电梯运行,电梯停止,电梯开门等多个状态,减少判断switch逻辑</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/State.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h1 id=&quot;1-设计模式&quot;&gt;&lt;a href=&quot;#1-设计模式&quot; class=&quot;headerlink&quot; title=&quot;1.设计模式&quot;&gt;&lt;/a&gt;1.设计模式&lt;/h1&gt;&lt;p&gt;设</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>摄影技巧</title>
    <link href="http://yoursite.com/2023/01/05/%E6%91%84%E5%BD%B1%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2023/01/05/%E6%91%84%E5%BD%B1%E6%8A%80%E5%B7%A7/</id>
    <published>2023-01-05T06:51:23.000Z</published>
    <updated>2023-01-09T04:25:19.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摄影技巧"><a href="#摄影技巧" class="headerlink" title="摄影技巧"></a>摄影技巧</h1><h2 id="1-拍摄"><a href="#1-拍摄" class="headerlink" title="1.拍摄"></a>1.拍摄</h2><h3 id="1-1基础知识"><a href="#1-1基础知识" class="headerlink" title="1.1基础知识"></a>1.1基础知识</h3><p>硬件部分：</p><ol><li>光圈（f1.4，f2.2）数值越小就越好</li><li>快门（曝光时间，如果要拍摄晚上车水马龙，需要延长快门时间</li><li>ISO（可以提高曝光率，但是变大会有噪点）</li></ol><p>手机没有办法像单反那样，可以得到不同的焦距，所以只能用多个摄像头来进行获得不同的焦段，5倍，10倍，60倍。剩下的2倍使用算法进裁剪得到，所以还是一般使用固定的焦距。</p><h3 id="1-2光的知识"><a href="#1-2光的知识" class="headerlink" title="1.2光的知识"></a>1.2光的知识</h3><p>光强：</p><ol><li>亮度（明亮成都）</li><li>距离（越远越低）</li><li>光面积（越大越强）</li><li>反光率</li></ol><p>色温：</p><p>光质：</p><ol><li>硬广</li><li>软光（通过放入纸巾，可以把赢的变软（漫反射）</li></ol><p>光比：明暗对比</p><p>光影：影子</p><h3 id="1-3色彩"><a href="#1-3色彩" class="headerlink" title="1.3色彩"></a>1.3色彩</h3><p>色相：（颜色名称，红黄蓝）</p><p>明度：颜色的亮度</p><p>饱和度：洗衣服，掉色，颜色越来越淡</p><p>色相环（一般都是互补色，家教为180）黄色还有蓝色</p><p>冷暖对比（上冷下暖）</p><p>黄图还有蓝天</p><h3 id="1-4构图"><a href="#1-4构图" class="headerlink" title="1.4构图"></a>1.4构图</h3><p>点构图：</p><ol><li>中心点</li><li>九宫格法（放到四个焦点）</li><li>引导线（忘一个点走）</li></ol><p>线构图：</p><ol><li>对称（镜面）</li><li>二分线（九宫格）</li><li>三分线</li><li>引导线</li><li>对角线</li></ol><p>面构图：</p><ol><li>框架（被框柱）</li><li>三角</li><li>重复出现</li><li>留白</li></ol><h3 id="1-5专业模式"><a href="#1-5专业模式" class="headerlink" title="1.5专业模式"></a>1.5专业模式</h3><p>主要就是让自己手动设置快门，光圈还有感光度</p><p>光圈：（光圈越大，进光越大，一般就是使用人像），越小越好f1.4</p><p>快门：（打开门的时间，时间越短，就是记录的越来越快），时间越长，进光越多</p><p>感光度：（iso越大越亮，但是会出现噪点</p><p>景深：就是手动进行对焦</p><p>晚间拍摄车水马龙：调大光圈，然后延长曝光时间，iso一般不用设置，因为出现过度</p><p>shuttle（快门） af，mf来进行对焦</p><p>白平衡：进行设置色温的冷暖（越低越暖）</p><p>打开raw可以进行设置</p><h3 id="1-6夜景"><a href="#1-6夜景" class="headerlink" title="1.6夜景"></a>1.6夜景</h3><p>iso低，延长曝光时间</p><p>苹果的就是，实况，长曝光</p><h3 id="1-7人像"><a href="#1-7人像" class="headerlink" title="1.7人像"></a>1.7人像</h3><p>人像一般需要进行虚化，虚化一般需要大光圈。虚化背景</p><p><strong>背景就远离人物，可以拍摄更久，更好的虚化</strong></p><p><strong>拍摄技巧（后退2-3步，然后2-3倍）</strong>（因为，这样可以虚化背景）</p><p>如何拍摄长腿：</p><ol><li>弯腰，然后仰角拍摄</li><li><strong>或者是脚在最下面，然后偷留下1&#x2F;3的空间</strong></li><li><strong>或者对角线拍摄</strong></li></ol><p>或者是自己进行附魔头发</p><h3 id="1-8街拍"><a href="#1-8街拍" class="headerlink" title="1.8街拍"></a>1.8街拍</h3><p>一般使用引导线，然后夜间一般就是长曝光</p><h3 id="1-9风光"><a href="#1-9风光" class="headerlink" title="1.9风光"></a>1.9风光</h3><h3 id="1-10"><a href="#1-10" class="headerlink" title="1.10"></a>1.10</h3><p>微距</p><p>长时间在3-4cm会自动进行触发</p><p>然后喷壶，使用连拍，可以拍摄出动物</p><h3 id="1-11食物"><a href="#1-11食物" class="headerlink" title="1.11食物"></a>1.11食物</h3><p>拍摄角度</p><ol><li>俯拍</li><li>平拍摄（背景</li><li>45°进行拍摄</li></ol><p>构图：</p><ol><li>三角构图（三个食物）</li><li>斜对角线</li><li>中心点</li><li>重复食物</li></ol><p>光纤：放入一张白纸，增加柔软度</p><p>放大片面</p><h3 id="1-12星空"><a href="#1-12星空" class="headerlink" title="1.12星空"></a>1.12星空</h3><p>设置长曝光，iso进行调整</p><p>最后一个就是对焦（设置为无限远，因为要对焦的是星星）</p><p>有限使用主摄，白平衡（设置偏暖）</p><h2 id="2-后期设置"><a href="#2-后期设置" class="headerlink" title="2.后期设置"></a>2.后期设置</h2><h3 id="2-1基础知识"><a href="#2-1基础知识" class="headerlink" title="2.1基础知识"></a>2.1基础知识</h3><p>曝光：调整明亮度</p><p>对比度：就是明与暗的对比</p><p>锐化：图片表面边缘</p><p>饱和度：颜色更鲜艳</p><p>白平衡：调节色温</p><p>褪色：添加颗粒（一般使用胶片的时候）</p><p>肤色：调整人的肤色</p><p>镜头模糊：虚化</p><p>清晰：凸显细节</p><p>使用的软件</p><ol><li>vsco</li><li>snap</li><li>lr泼辣修图</li></ol><h3 id="2-2影调"><a href="#2-2影调" class="headerlink" title="2.2影调"></a>2.2影调</h3><p>图像分为影调还有色影</p><p>影调就是明暗轮廓，主要是从0-255的灰度值，来计算每个地方的数量</p><p>分为以下几个：</p><ol><li>曝光（纯黑）</li><li>对比（有点黑的数量）</li><li>细节（剩下的就是细节）</li><li>阴影（有点白的）</li><li>白色（全是白色的）</li></ol><p>这个可以用曲线来看出</p><p>清晰度：边缘对比</p><h3 id="2-3色调"><a href="#2-3色调" class="headerlink" title="2.3色调"></a>2.3色调</h3><p>色温，调整这个一般都是的相邻色</p><p>主要还是使用曲线来进行设置，剩下的就是hsl来进行设置</p><p>直方图：反应图片（黑色，阴影，细节，高光，白色），这个就是数值</p><p>从左到右是0-255,255是白光</p><p>下面是色彩的直方图</p><p>只有三原色，红绿蓝</p><p>左边是红色的数量少，右边是红色多</p><p>对比度（明暗的对比）</p><p>如何做好，就是模仿别人的直方图</p><h3 id="2-4hsl"><a href="#2-4hsl" class="headerlink" title="2.4hsl"></a>2.4hsl</h3><p>色彩调整</p><p>单一的颜色调整（七原色）</p><p>色相：颜色</p><p>饱和度：鲜艳程度</p><p>明亮度：明暗</p><p>色相：只能是他的相邻色，30平分</p><p>拉动只会到他的相邻色</p><p>调色思路：一般去除杂色，饱和度为0，<strong>然后留下互补色</strong></p><p>一般思路：</p><ol><li><strong>家曝光</strong>，这个在局部调整（增加光进入）</li><li>加对比</li><li>降低高光</li></ol><h3 id="2-6曲线"><a href="#2-6曲线" class="headerlink" title="2.6曲线"></a>2.6曲线</h3><p>一般是两个曲线，明亮曲线（一般用于s行）</p><p>左上是亮度，游侠是暗度</p><p>一般使用锚点，固定每一个的格子</p><p>胶片的思路：一般就是加暗，调低亮度，然后加入颗粒感</p><p>小清新：提高亮度，一般只有2中颜色，调低对比度</p><p><strong>颜色曲线：</strong></p><ol><li>往下就是互补色（红色互补就是蓝+绿）</li><li>往上就是增加强度</li><li>一般使用（2个颜色叠加，来增加第三个颜色）</li></ol><h3 id="2-7颜色分级"><a href="#2-7颜色分级" class="headerlink" title="2.7颜色分级"></a>2.7颜色分级</h3><p>就是使用圆形轮廓，然后设置，可以进行局部设置</p><h3 id="2-10后期实战"><a href="#2-10后期实战" class="headerlink" title="2.10后期实战"></a>2.10后期实战</h3><p>基础问题分析：</p><ol><li>没有层次感（加强对比度，加强清晰感）</li><li>色彩不突出（重新上色，局部提亮，增加曝光）</li></ol><p><strong>青橙思路</strong>：</p><ol><li>适用于风光，建筑，晴天</li><li>主要是互补色</li><li>高光，阴影，细节</li><li>lsh’设置青橙</li></ol><p><strong>暗黑：</strong></p><ol><li>适用于阴雨天</li><li>降低高光，加对比度，增加黑色</li><li>lsh去除杂色，明确颜色</li></ol><p><strong>蓝调：</strong></p><ol><li>增加曝光，降低高光，提高阴影</li><li>色温设定颜色</li></ol><p><strong>小清新：</strong></p><ol><li>天气好</li><li>降低对比度</li><li>一般都是男女为主，加明亮度</li></ol><p>*<em>cyberpunk</em>***：</p><ol><li>一般适用于夜晚</li><li>降低高光，提高阴影，加对比度</li><li>hsl往品红，杨宏走</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;摄影技巧&quot;&gt;&lt;a href=&quot;#摄影技巧&quot; class=&quot;headerlink&quot; title=&quot;摄影技巧&quot;&gt;&lt;/a&gt;摄影技巧&lt;/h1&gt;&lt;h2 id=&quot;1-拍摄&quot;&gt;&lt;a href=&quot;#1-拍摄&quot; class=&quot;headerlink&quot; title=&quot;1.拍摄&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="摄影" scheme="http://yoursite.com/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
</feed>
