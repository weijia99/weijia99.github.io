<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-07-10T03:41:30.438Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>weijia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sovits训练教程</title>
    <link href="http://yoursite.com/2023/07/10/sovits%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2023/07/10/sovits%E8%AE%AD%E7%BB%83%E6%95%99%E7%A8%8B/</id>
    <published>2023-07-10T03:06:38.000Z</published>
    <updated>2023-07-10T03:41:30.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://github.com/svc-develop-team/so-vits-svc/blob/4.1-Stable/README_zh_CN.md">so-vits-svc&#x2F;README_zh_CN.md at 4.1-Stable · svc-develop-team&#x2F;so-vits-svc · GitHub</a></p><p>歌声音色转换模型，通过SoftVC内容编码器提取源音频语音特征，与F0同时输入VITS替换原本的文本输入达到歌声转换的效果。同时，更换声码器为 <a href="https://github.com/openvpi/DiffSinger/tree/refactor/modules/nsf_hifigan">NSF HiFiGAN</a>解决断音问题。</p><h1 id="训练流程"><a href="#训练流程" class="headerlink" title="训练流程"></a>训练流程</h1><h2 id="1-数据集处理"><a href="#1-数据集处理" class="headerlink" title="1.数据集处理"></a>1.数据集处理</h2><h3 id="1-1收集数据集"><a href="#1-1收集数据集" class="headerlink" title="1.1收集数据集"></a>1.1收集数据集</h3><p>以b站直播为例：</p><ol><li>打开up主的直播回放列表<a href="https://space.bilibili.com/672342685/channel/seriesdetail?sid=222754">乃琳Queen的个人空间_哔哩哔哩_bilibili</a></li><li>选择单播一个人的</li><li>使用downkyi，<a href="https://github.com/leiurayer/downkyi/releases">Releases · leiurayer&#x2F;downkyi (github.com)</a>进行视频下载</li></ol><h3 id="1-2数据集预处理"><a href="#1-2数据集预处理" class="headerlink" title="1.2数据集预处理"></a>1.2数据集预处理</h3><p>首先进行人声提取，我们主要训练的是人声</p><p><img src="https://www.freedidi.com/wp-content/uploads/2023/06/2023-06-09-163727.png" alt="img"></p><p>使用uvr5，<a href="https://github.com/Anjok07/ultimatevocalremovergui/releases/tag/v5.5.0">Release v5.5 - UVR GUI · Anjok07&#x2F;ultimatevocalremovergui (github.com)</a>，选择模型demucs（这个是facebook开元的去噪模型），进行数据集预处理</p><p>接下来是数据集进行分片，使用<a href="https://github.com/flutydeer/audio-slicer">flutydeer&#x2F;audio-slicer: A simple GUI application that slices audio with silence detection (github.com)</a>，来把谷歌得到人声进行切片，保证每一个最长不超过15s</p><h2 id="2-训练过程"><a href="#2-训练过程" class="headerlink" title="2.训练过程"></a>2.训练过程</h2><p>参照官网文件</p><p><a href="https://github.com/svc-develop-team/so-vits-svc/blob/4.1-Stable/README_zh_CN.md">so-vits-svc&#x2F;README_zh_CN.md at 4.1-Stable · svc-develop-team&#x2F;so-vits-svc · GitHub</a></p><h3 id="2-1下载预训练权重"><a href="#2-1下载预训练权重" class="headerlink" title="2.1下载预训练权重"></a>2.1下载预训练权重</h3><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16889594099901688959409276.png" alt="16889594099901688959409276.png"></p><p><a href="https://ibm.ent.box.com/s/z1wgl1stco8ffooyatzdwsqn2psd9lrr">Box</a>，获取模型权重，放入到pretrain文件夹里面。作为编码器（把声音转化为vector）</p><h3 id="2-2数据预处理"><a href="#2-2数据预处理" class="headerlink" title="2.2数据预处理"></a>2.2数据预处理</h3><p>把上面处理好的数据，放入到data_raw文件夹里面，我们首先，进行重采样到44k</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python resample.py</span><br></pre></td></tr></table></figure><p>接下来进行划分训练集还有测试集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python preprocess_flist_config.py --speech_encoder vec768l12</span><br></pre></td></tr></table></figure><p>接下来修改训练参数，现在工业化的的代码，都是写入到从config文件里面，我们修改config的batchsize还有port，其他的按需修改。</p><p>最后就是生成hubert</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python preprocess_hubert_f0.py --f0_predictor dio</span><br></pre></td></tr></table></figure><h3 id="2-3开始训练"><a href="#2-3开始训练" class="headerlink" title="2.3开始训练"></a>2.3开始训练</h3><p>和mmtools一样，也是使用config文件进行训练，，-m 代表，训练保存的名字，在logs目录下面</p><p>我们为了加快训练（可以放入g—0，还有d-0来加快训练流程）</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16889598089881688959808436.png" alt="16889598089881688959808436.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py -c configs/config.json -m 44k</span><br></pre></td></tr></table></figure><h3 id="（可选）2-4hpc训练流程"><a href="#（可选）2-4hpc训练流程" class="headerlink" title="（可选）2.4hpc训练流程"></a>（可选）2.4hpc训练流程</h3><p>使用sbatch来进行训练，主要的是用于下面这个脚本来执行gpu.slurm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>       </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --job-name=test-gpu</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --partition=gpu</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --nodes=1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --ntasks-per-node=4</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --gres=gpu:1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --error=%j.err</span>    </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --output=%j.out</span>    </span><br><span class="line"></span><br><span class="line">CURDIR=`pwd` </span><br><span class="line">rm -rf $CURDIR/nodelist.$SLURM_JOB_ID</span><br><span class="line">NODES=`scontrol show hostnames $SLURM_JOB_NODELIST`</span><br><span class="line">for i in $NODES</span><br><span class="line">do</span><br><span class="line">echo &quot;$i:$SLURM_NTASKS_PER_NODE&quot; &gt;&gt; $CURDIR/nodelist.$SLURM_JOB_ID</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;process will start at : &quot;</span><br><span class="line">date</span><br><span class="line">echo &quot;++++++++++++++++++++++++++++++++++++++++&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nvidia-smi</span><br><span class="line">source /home/software/anaconda/anaconda3-2023.03/bin/activate pytorch</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">wget https://mirrors.tuna.tsinghua.edu.cn/julia-releases/bin/winnt/x86/1.9/julia-1.9.1-win32.tar.gz</span></span><br><span class="line">python train.py -c configs/config.json -m as</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifconfig</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ping baidu.com</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">jupyter notebook</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">conda list | grep mmeng</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">which</span> python</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">python demo/image_demo.py demo/demo.jpg rtmdet_tiny_8xb32-300e_coco.py --weights rtmdet_tiny_8xb32-300e_coco_20220902_112414-78e30dcc.pth --device cuda:0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mpirun -np $SLURM_NPROCS hostname</span><br><span class="line"></span><br><span class="line">echo &quot;++++++++++++++++++++++++++++++++++++++++&quot;</span><br><span class="line">echo &quot;processs will sleep 30s&quot;</span><br><span class="line">sleep 30</span><br><span class="line">echo &quot;process end at : &quot;</span><br><span class="line">date</span><br><span class="line">rm -rf $CURDIR/nodelist.$SLURM_JOB_ID</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>和上面没有什么差别，但是我们只需要激活自己的环境，使用source，之后就是和之前一样，使用python进行训练，上面的参数，重点关注#SBATCH –gres&#x3D;gpu:1  这个是分配gpu的数量。</p><p>然后使用训练代码sbatch gpu.slurm进行训练</p><p>之后使用cat 进程号.out来查看训练流程</p><h1 id="推理流程"><a href="#推理流程" class="headerlink" title="推理流程"></a>推理流程</h1><p>从服务器下载权重文件，只需要g-20000.pth来进行生成，因为是生成阶段，所以我们只要进行生成器，同事还需要，这个的config文件。</p><p>下载到本地使用本地的webui来进行执行。或者直接在服务器使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例</span></span><br><span class="line">python inference_main.py -m &quot;logs/44k/G_30400.pth&quot; -c &quot;configs/config.json&quot; -n &quot;君の知らない物語-src.wav&quot; -t 0 -s &quot;nen&quot;</span><br></pre></td></tr></table></figure><p>注意推理也是只要人声阶段。</p><h1 id="合成音频"><a href="#合成音频" class="headerlink" title="合成音频"></a>合成音频</h1><p>使用剪映，把谷歌生成得到的人声，还有使用uvr5提取的伴奏，都拖到剪映的音轨上面，进行对齐，这样，我们就可以直接使用剪映导出生成的视频。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/svc-develop-team/so-vits-svc/blob/4.1-Stab</summary>
      
    
    
    
    
    <category term="语音识别" scheme="http://yoursite.com/tags/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"/>
    
    <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>cs144实验</title>
    <link href="http://yoursite.com/2023/07/09/cs144%E5%AE%9E%E9%AA%8C/"/>
    <id>http://yoursite.com/2023/07/09/cs144%E5%AE%9E%E9%AA%8C/</id>
    <published>2023-07-09T03:48:37.000Z</published>
    <updated>2023-07-10T08:23:38.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab0-：warm-up"><a href="#lab0-：warm-up" class="headerlink" title="lab0 ：warm up"></a>lab0 ：warm up</h1><p>第0张就是温习一下网络的相关知识。</p><h2 id="1-Set-up-GNU-x2F-Linux"><a href="#1-Set-up-GNU-x2F-Linux" class="headerlink" title="1 Set up GNU&#x2F;Linux"></a>1 Set up GNU&#x2F;Linux</h2><p>配置环境就直接跳过了，按照官方教程就行</p><h2 id="2-Networking-by-hand"><a href="#2-Networking-by-hand" class="headerlink" title="2 Networking by hand"></a>2 Networking by hand</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ telnet cs144.keithw.org http</span><br><span class="line">GET /hello HTTP/1.1</span><br><span class="line">Host: cs144.keithw.org</span><br><span class="line">Connection: close</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>终端输入上述代码</p><p>新建一个会话进行观察</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ netcat -v -l -n -p 9090</span><br><span class="line">$ telnet localhost 9090</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-Writing-webget"><a href="#3-Writing-webget" class="headerlink" title="3 Writing webget"></a>3 Writing webget</h2><p>思路<br>实现 apps&#x2F;webget.cc 中的 get_URL().<br>实现思路基本按照实验指导的提示和代码注释, 建立连接后发送 HTTP 请求报文. 然后打印回复报文的内容. 由于回复报文可能不止一个, 因此需要通过检查 EOF 标志位来判断是否接收完毕.</p><p>​<br>    void get_URL(const string &amp;host, const string &amp;path) {<br>        &#x2F;&#x2F; Your code here.&#x2F;&#x2F; You will need to connect to the “http” service on<br>    &#x2F;&#x2F; the computer whose name is in the “host” string,<br>    &#x2F;&#x2F; then request the URL path given in the “path” string.</p><pre><code>// Then you&#39;ll need to print out everything the server sends back,// (not just one call to read() -- everything) until you reach// the &quot;eof&quot; (end of file).// 直接参照tcp socks的api来哦发请求,使用address,还有TCPSocket socks&#123;&#125;;socks.connect(Address(host,&quot;http&quot;));// 发送apisocks.write(&quot;GET &quot;+path+&quot; HTTP/1.1\r\nHost: &quot;+host+&quot;\r\n\r\n&quot;);socks.shutdown(SHUT_WR);while(!socks.eof())&#123;    cout&lt;&lt;socks.read();&#125;// 关闭管道socks.close();cerr &lt;&lt; &quot;Function called: get_URL(&quot; &lt;&lt; host &lt;&lt; &quot;, &quot; &lt;&lt; path &lt;&lt; &quot;).\n&quot;;cerr &lt;&lt; &quot;Warning: get_URL() has not been implemented yet.\n&quot;;</code></pre><p>}</p><h2 id="4-in-memory-reliable-byte-stream"><a href="#4-in-memory-reliable-byte-stream" class="headerlink" title="4.in-memory reliable byte stream"></a>4.in-memory reliable byte stream</h2><p>任务二要求我们实现一个内存内的有序可靠字节流：</p><ul><li><p>字节流可以从写入端写入，并以相同的顺序，从读取端读取</p></li><li><p>字节流是有限的，写者可以终止写入。而读者可以在读取到字节流末尾时，不再读取。</p></li><li><p>字节流支持流量控制，以控制内存的使用。当所使用的缓冲区爆满时，将禁止写入操作。</p></li><li><p>写入的字节流可能会很长，必须考虑到字节流大于缓冲区大小的情况。即便缓冲区只有1字节大小，所实现的程序也必须支持正常的写入读取操作。</p></li><li><p>在单线程环境下执行，无需考虑多线程生产者-消费者模型下各类条件竞争问题。</p></li></ul><p><img src="https://kiprey.github.io/2021/11/cs144-lab1/image-20211105142904316.png" alt="image-20211105142904316"></p><p>参照这张图，我们现在要实现的是bytestream，他的主要功能就是从队头取文件，队尾放文件。符合这个的数据结构是双端队列，dequeue。因此我们需要加入这个数据结构</p><p>下面，我们来看他需要实现的方法，还需要那些额外变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! Construct a stream with room for `capacity` bytes.</span></span><br><span class="line">    <span class="built_in">ByteStream</span>(<span class="type">const</span> <span class="type">size_t</span> capacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name &quot;Input&quot; interface for the writer</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Write a string of bytes into the stream. Write as many</span></span><br><span class="line">    <span class="comment">//! as will fit, and return how many were written.</span></span><br><span class="line">    <span class="comment">//! \returns the number of bytes accepted into the stream</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string &amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns the number of additional bytes that the stream has space for</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">remaining_capacity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Signal that the byte stream has reached its ending</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">end_input</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Indicate that the stream suffered an error.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_error</span><span class="params">()</span> </span>&#123; _error = <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name &quot;Output&quot; interface for the reader</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Peek at next &quot;len&quot; bytes of the stream</span></span><br><span class="line">    <span class="comment">//! \returns a string</span></span><br><span class="line">    <span class="function">std::string <span class="title">peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Remove bytes from the buffer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span></span><br><span class="line">    <span class="comment">//! \returns a string</span></span><br><span class="line">    <span class="function">std::string <span class="title">read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns `true` if the stream input has ended</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">input_ended</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns `true` if the stream has suffered an error</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">error</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _error; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns the maximum amount that can currently be read from the stream</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns `true` if the buffer is empty</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">buffer_empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns `true` if the output has reached the ending</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eof</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name General accounting</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Total number of bytes written</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">bytes_written</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Total number of bytes popped</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">bytes_read</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们发现，bool还有size_t是需要进行返回的函数，因此加入 <strong>bool is_eof; size_t _capacity; size_t _written_size; size_t _read_size;</strong> 最后我们还要加上上面推理得到的数据结构双端队列deque <strong>deque<char> _output;</char></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint: This doesn&#x27;t need to be a sophisticated data structure at</span></span><br><span class="line">    <span class="comment">// all, but if any of your tests are taking longer than a second,</span></span><br><span class="line">    <span class="comment">// that&#x27;s a sign that you probably want to keep exploring</span></span><br><span class="line">    <span class="comment">// different approaches.</span></span><br><span class="line">    <span class="type">size_t</span> _capacity;</span><br><span class="line">    <span class="type">bool</span> is_eof;</span><br><span class="line">    <span class="type">size_t</span> _written_size;<span class="comment">//当前已经写入了的</span></span><br><span class="line">    <span class="type">size_t</span> _read_size;<span class="comment">//当前已经写入了的</span></span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">char</span>&gt; _output;</span><br><span class="line">    <span class="type">bool</span> _error&#123;&#125;;  <span class="comment">//!&lt; Flag indicating that the stream suffered an error.</span></span><br></pre></td></tr></table></figure><p>首先是实现构造函数，把上面新加入的变量全部初始化</p><p><strong>ByteStream::ByteStream(const size_t capacity):  _capacity(capacity),is_eof(false),_written_size(0),_read_size(0),_output() {}</strong></p><p>接下来，我们把需要返回的，先进行返回</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123;is_eof=<span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> is_eof; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _output.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _output.<span class="built_in">size</span>()==<span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> is_eof&amp;&amp;_output.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _written_size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _read_size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _capacity-_output.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure><ol><li>结束输入就是设置标识符eof为结束</li><li>eof代表牌既不能输入，而且也不能读取，就是没有队列长度</li><li>剩余空间就是最先开始的长度-当前buffer占用的长度</li></ol><p>接下来我们就是实现，双端队列的write</p><p>size_t ByteStream::write(const string &amp;data) {</p><ol><li>我们首先需要判断，还能不能写，不能写就返回</li><li>之后进行判断，当前能写的长度和data的长度，哪一个少，我们王少的写，同时写入长度增加</li><li>最后返回写入了多少长度</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(data);</span></span><br><span class="line">    <span class="keyword">if</span> (is_eof)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> l1=data.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> l2=_capacity-_output.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> left =<span class="built_in">min</span>(l1,l2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;left;i++)&#123;</span><br><span class="line">        _written_size++;</span><br><span class="line">        _output.<span class="built_in">push_back</span>(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一个函数peek_out和队列的输出后汉书一样，输出队头元素</p><ol><li>判断最长能输出的长度</li><li>然后调用队列的输出pop，</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(len);</span></span><br><span class="line">    <span class="type">size_t</span> l1=_output.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> l2=len;</span><br><span class="line">    <span class="type">size_t</span> out_size=<span class="built_in">min</span>(l1,l2);</span><br><span class="line">    string s;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(_output.<span class="built_in">begin</span>(), _output.<span class="built_in">begin</span>() +out_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下一个pop。和队列的pop一样，参照上面的，但是需要加入到已经读取了read_size</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void ByteStream::pop_output(const size_t len) &#123; </span><br><span class="line">    size_t l1=_written_size;</span><br><span class="line">    size_t l2=len;</span><br><span class="line">    size_t out_size=min(l1,l2);</span><br><span class="line">    // _written_size-=out_size;</span><br><span class="line">    _read_size+=out_size;</span><br><span class="line">    for(size_t i=0;i&lt;out_size;i++)&#123;</span><br><span class="line">        _output.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>现在我们要实现read代码，他的思路就是调用peek，还有pop就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be popped and returned</span></span><br><span class="line"><span class="comment">//! \returns a string</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    string data=<span class="keyword">this</span>-&gt;<span class="built_in">peek_output</span>(len);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">pop_output</span>(len);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>总体来说第一个还是比较简单的，我们按照这个图发现，byte_stream是最底层的模块，他的作用就是退工读写队列，明白他是双端队列就好办了</p><p><img src="https://kiprey.github.io/2021/11/cs144-lab1/image-20211105142904316.png" alt="image-20211105142904316"></p><p>明白了，这个，我们需要实现的就是write还有read功能，write写入到队尾，看剩余长度够不够，选择最小的进行写入。read也是选择最小的进行读取。思路和使用普通的队列差不多</p><h1 id="lab1-：StreamReassembler"><a href="#lab1-：StreamReassembler" class="headerlink" title="lab1 ：StreamReassembler"></a>lab1 ：StreamReassembler</h1><p>在我们所实现的流重组器中，有以下几种特性：</p><ul><li><p>接收子字符串。这些子字符串中包含了一串字节，以及该字符串在<strong>总的数据流</strong>中的<strong>第一个字节的索引</strong>。</p><p>流的每个字节都有自己唯一的索引，从零开始向上计数。</p></li><li><p>StreamReassembler 中存在一个 ByteStream 用于输出，当重组器知道了流的下一个字节，它就会将其写入至 ByteStream中。</p></li></ul><p>需要注意的是，传入的子串中：</p><ul><li><p>子串之间可能相互重复，存在重叠部分</p><blockquote><p>但假设重叠部分数据完全重复。</p><p>不存在某些 index 下的数据在某个子串中是一种数据，在另一个子串里又是另一种数据。</p></blockquote><blockquote><p>重叠部分的处理最为麻烦。</p></blockquote></li><li><p>可能会传一些已经被装配了的数据</p></li><li><p>如果 ByteStream 已满，则必须暂停装配，将未装配数据暂时保存起来</p></li></ul><p>除了上面的要求以外，容量 Capacity 需要严格限制：</p><p><img src="https://kiprey.github.io/2021/11/cs144-lab1/image-20211107124153476.png" alt="image-20211107124153476"></p><p>为了便于说明，将图中的<strong>绿色区域</strong>称为 ByteStream，将图中<strong>存放红色区域的内存范围（即 first unassembled - first unacceptable）</strong>称为 Unassembled_strs。</p><p>CS144 要求将 <strong>ByteStream + Unassembled_strs 的内存占用总和</strong>限制在 <strong>Reassember 中构造函数传入的 capacity 大小</strong>。因此我们在构造 Reassembler 时，需要既将传入的 capacity 参数设置为 <code>ByteStream</code>的缓冲区大小上限，也将其设置为<strong>first unassembled - first unacceptable</strong>的范围大小，以避免极端情况下的内存使用。</p><blockquote><p>思路：</p><ol><li><p>这一个的任务是要求我们实现重组机器reassemble</p></li><li><p>主要功能包括对收到的字符串进行排序，之后传入到之前的byte_stream写入到缓存里面</p></li><li><p>根据上面的图，我们可以确定，绿色的是已经排序好了的，是在byte_tream里面的</p></li><li><p>绿色的+红色的是capacity，我们目前能放入到assemble的只有红色的</p></li><li><p>我们确定还没有排好序的为next_index,最大读取的就是next_index+(capacity-byte_stream。size)</p></li><li><p>同时在红色地区可能有元素，就是没有排序，我们使用unordered_map&lt;int，char&gt;来进行记录，下表的值，例如rec[100]&#x3D;”c”这也是为了让byte_stream容易write</p></li></ol></blockquote><p><strong>因此我们需要</strong></p><p>根据上面的思路，我们来看api， <strong>void push_substring(const std::string &amp;data, const uint64_t index, const bool eof);</strong>  </p><ol><li>需要我们把data放入到index的位置，并且设置eof</li><li>首先根据上面的分析，最长能够到达的是next_index+(capacity-byte_stream。size)，如果大于等于，就说明超过了，直接return</li><li>接下来就是如果index+data.size()&lt;&#x3D;next_index+_output.remaining_capacity()&amp;&amp;eof表示写入完成，那么我们设置，stream_byte的is_eof为true</li><li>之后就是开始加载到reassemble的流程，和之前一样，data的前半部分可能已经被加载到重组器里面了，我们选择最大的开始，max(next_index,index),然后选择最小的长度，作为能放入到重组器的min（iondex+data.size，next_index+(capacity-byte_stream。size)，作为读取的开始，然后我们放入到rec作为缓冲   <strong>注意（rec可能当前索引i已经有值了，这时候直接跳过</strong></li></ol><p>上半部分代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// DUMMY_CODE(data, index, eof);</span></span><br><span class="line">    <span class="comment">// 首先进行检索,看当前的index是不是超过</span></span><br><span class="line">    <span class="keyword">if</span>(index&gt;=next_index+_output.<span class="built_in">remaining_capacity</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 直接结束,说明索引,已经超过剩下的buffer里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(eof&amp;&amp;index+data.<span class="built_in">size</span>()&lt;=next_index+_output.<span class="built_in">remaining_capacity</span>())&#123;</span><br><span class="line">        is_eof=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 代表写入结束,next+out是写入</span></span><br><span class="line">        <span class="comment">// output是之前那个byte</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index+data.<span class="built_in">size</span>()&gt;next_index)&#123;</span><br><span class="line">        <span class="comment">// 首先选最小的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i=(index &gt; next_index? index: next_index); i &lt; next_index+ _output.<span class="built_in">remaining_capacity</span>() &amp;&amp; i &lt; index + data.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* code */</span></span><br><span class="line">            <span class="comment">// 直接选择最小的,然后这是输入的</span></span><br><span class="line">            <span class="keyword">if</span> (rec.<span class="built_in">count</span>(i)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//set里面没有这个,进行加入data</span></span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">size</span>()&lt;=i)</span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/* code */</span></span><br><span class="line">                    <span class="function">string <span class="title">add</span><span class="params">(i,<span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">//                    s.reserve(2*i);</span></span><br><span class="line">                    s+=add;</span><br><span class="line"><span class="comment">//                    cout&lt;&lt;s.capacity();</span></span><br><span class="line">                    <span class="comment">//扩容</span></span><br><span class="line">                &#125;</span><br><span class="line">                s[i]=data[i-index];</span><br><span class="line">                <span class="comment">//直接写入</span></span><br><span class="line">                rec.<span class="built_in">insert</span>(i);</span><br><span class="line">                unassembled_bytes_++;</span><br><span class="line">                <span class="comment">//这是没有整理的,放入到字符串里面</span></span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在已经写完了的情况下，我们就是对rec进行重拍程字符串，丢到stream_byte来进行写入，遍历next_index，看当前是不是有索引值，悠久进行加入，然后同事，构造一个新的字符串，直到next_index没有值，我们就不在进行while。结束之后，如果有eof标志，也要进行设置byte_stream为写入完成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//写入结束,放入到output里面</span></span><br><span class="line">        <span class="type">size_t</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="type">size_t</span> back=next_index;</span><br><span class="line">        <span class="keyword">while</span> (rec.<span class="built_in">count</span>(next_index)&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* code */</span></span><br><span class="line">            n++;</span><br><span class="line">            rec.<span class="built_in">erase</span>(next_index);</span><br><span class="line">            next_index++;</span><br><span class="line">            unassembled_bytes_--;</span><br><span class="line">            <span class="comment">//这是已经写好了,然后进行减少</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        string x=s.<span class="built_in">substr</span>(back,n);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;x;</span></span><br><span class="line">        _output.<span class="built_in">write</span>(x);</span><br><span class="line">        <span class="comment">//写入这个单词</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is_eof &amp;&amp; <span class="built_in">empty</span>()) &#123;</span><br><span class="line">       _output.<span class="built_in">end_input</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DUMMY_CODE(data, index, eof);</span></span><br><span class="line">    <span class="comment">// 首先进行检索,看当前的index是不是超过</span></span><br><span class="line">    <span class="keyword">if</span>(index&gt;=next_index+_output.<span class="built_in">remaining_capacity</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 直接结束,说明索引,已经超过剩下的buffer里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(eof&amp;&amp;index+data.<span class="built_in">size</span>()&lt;=next_index+_output.<span class="built_in">remaining_capacity</span>())&#123;</span><br><span class="line">        is_eof=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 代表写入结束,next+out是写入</span></span><br><span class="line">        <span class="comment">// output是之前那个byte</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index+data.<span class="built_in">size</span>()&gt;next_index)&#123;</span><br><span class="line">        <span class="comment">// 首先选最小的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i=(index &gt; next_index? index: next_index); i &lt; next_index+ _output.<span class="built_in">remaining_capacity</span>() &amp;&amp; i &lt; index + data.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* code */</span></span><br><span class="line">            <span class="comment">// 直接选择最小的,然后这是输入的</span></span><br><span class="line">            <span class="keyword">if</span> (rec.<span class="built_in">count</span>(i)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//set里面没有这个,进行加入data</span></span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">size</span>()&lt;=i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* code */</span></span><br><span class="line">                    <span class="function">string <span class="title">add</span><span class="params">(i,<span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">//                    s.reserve(2*i);</span></span><br><span class="line">                    s+=add;</span><br><span class="line"><span class="comment">//                    cout&lt;&lt;s.capacity();</span></span><br><span class="line">                    <span class="comment">//扩容</span></span><br><span class="line">                &#125;</span><br><span class="line">                s[i]=data[i-index];</span><br><span class="line">                <span class="comment">//直接写入</span></span><br><span class="line">                rec.<span class="built_in">insert</span>(i);</span><br><span class="line">                unassembled_bytes_++;</span><br><span class="line">                <span class="comment">//这是没有整理的,放入到字符串里面</span></span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//写入结束,放入到output里面</span></span><br><span class="line">        <span class="type">size_t</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="type">size_t</span> back=next_index;</span><br><span class="line">        <span class="keyword">while</span> (rec.<span class="built_in">count</span>(next_index)&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* code */</span></span><br><span class="line">            n++;</span><br><span class="line">            rec.<span class="built_in">erase</span>(next_index);</span><br><span class="line">            next_index++;</span><br><span class="line">            unassembled_bytes_--;</span><br><span class="line">            <span class="comment">//这是已经写好了,然后进行减少</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        string x=s.<span class="built_in">substr</span>(back,n);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;x;</span></span><br><span class="line">        _output.<span class="built_in">write</span>(x);</span><br><span class="line">        <span class="comment">//写入这个单词</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is_eof &amp;&amp; <span class="built_in">empty</span>()) &#123;</span><br><span class="line">       _output.<span class="built_in">end_input</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的我们，直接返回所需要的元素就行。设置那个重组器构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">StreamReassembler::StreamReassembler(const size_t capacity) : next_index(0),rec(),s(capacity,&#x27;\0&#x27;),is_eof(false),unassembled_bytes_(0),_output(capacity), _capacity(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line">//! \details This function accepts a substring (aka a segment) of bytes,</span><br><span class="line">size_t StreamReassembler::unassembled_bytes() const &#123; return unassembled_bytes_; &#125;</span><br><span class="line"></span><br><span class="line">bool StreamReassembler::empty() const &#123; return unassembled_bytes_==0; &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一个的作业，主要是处理充排气，我们都知道tcp接受的时候，可能会先收到后发来的tcp分段，乱序到达，需要进行排列之后才能写入，所以这一届的任务就是实现重拍器实现tcp发送的一个任务。主要的难点就是完全理解这张图</p><p><img src="https://kiprey.github.io/2021/11/cs144-lab1/image-20211107124153476.png" alt="image-20211107124153476"></p><p>知道这个容量是byte_stream+还没有重组的，然后使用数据结构map，记录每一个位置的索引值</p><h1 id="Lab-2-the-TCP-receiver"><a href="#Lab-2-the-TCP-receiver" class="headerlink" title="Lab 2: the TCP receiver"></a>Lab 2: the TCP receiver</h1><p>经典看不懂到底说的是什么</p><p>结合 Lab1 中实现的字节流重组器，可以发现，在数据的收发过程中存在几种序列号：</p><ul><li>序列号 <code>seqno</code>：32bit 无符号整数，从初始序列号 ISN 开始递增，SYN 和 FIN 各占一个编号，溢出之后从 0 开始接着数</li><li>绝对序列号 <code>absolute seqno</code>：64bit 无符号整数，从 0 开始递增，0 对应 ISN，不会溢出</li><li>字节流索引 <code>stream index</code>：64bit 无符号整数，从 0 开始递增，不考虑 SYN 报文段，所以 0 对应 ISN + 1，不会溢出</li></ul><p>假设 ISN 为 232−2232−2，待传输的数据为 <code>cat</code>，那么三种编号的关系如下表所示：</p><p><a href="https://img2023.cnblogs.com/blog/2065884/202304/2065884-20230425145852558-156889302.png"><img src="https://img2023.cnblogs.com/blog/2065884/202304/2065884-20230425145852558-156889302.png" alt="img"></a></p><p>由于 <code>uint32_t</code> 的数值范围为 0∼232−10∼232−1，所以 <code>a</code> 对应的报文段序列号溢出，又从 0 开始计数了。</p><p>处于安全性考虑，以及避免与之前的 TCP 报文混淆，TCP 需要让每个 seqno 都不可被猜测到，并且降低重复的可能性。因此 TCP seqno 不会从 0 开始，而是从一个 32 位随机数起步（称为<strong>初始序列号 ISN</strong>）</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16888898613871688889861341.png" alt="16888898613871688889861341.png"></p><p>思路：</p><blockquote><ol><li>首先实现序列号转绝对序列号，因为我们发送的是32位的seqno，但是接受之后，他会变成64位的，但是因为64位的位置更大，所以我们需要checkpoint，做为基准点，看他到底是哪一个</li><li>从64位转到32位，就容易点，根据上面的公式，进行移项，我们只需要abs+isn,强转到32位就行</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! Transform an &quot;absolute&quot; 64-bit sequence number (zero-indexed) into a WrappingInt32</span></span><br><span class="line"><span class="comment">//! \param n The input absolute 64-bit sequence number</span></span><br><span class="line"><span class="comment">//! \param isn The initial sequence number</span></span><br><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="type">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123; <span class="keyword">return</span> WrappingInt32&#123;isn + <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(n)&#125;; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint64_t unwrap(WrappingInt32 n, WrappingInt32 isn, uint64_t checkpoint) </span><br></pre></td></tr></table></figure><p>对于这个api，我们根据上面的分析是checkpoint是附近的值，来基于确认的我们知道（seqno之间的差距）一定等于abs之间的差距，所以我们可以先把chekpoint转到32来，计算他与n之间的差别，然后checkpoint与差值进行计算，因为是uint，所以一定大于0.如果小于0，需要加上2的32</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="type">uint64_t</span> checkpoint)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    DUMMY_CODE(n, isn, checkpoint);</span></span><br><span class="line"><span class="type">int32_t</span> min_step = n - <span class="built_in">wrap</span>(checkpoint, isn);</span><br><span class="line"><span class="comment">// 将步数加到checkpoint上</span></span><br><span class="line"><span class="type">int64_t</span> ret = checkpoint + min_step;</span><br><span class="line"><span class="comment">// 如果反着走的话要加2^32</span></span><br><span class="line"><span class="keyword">return</span> ret &gt;= <span class="number">0</span> ? <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(ret) : ret + (<span class="number">1ul</span> &lt;&lt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCPReceiver-实现"><a href="#TCPReceiver-实现" class="headerlink" title="TCPReceiver 实现"></a>TCPReceiver 实现<img src="https://img2023.cnblogs.com/blog/2065884/202304/2065884-20230425160212576-1281077767.png" alt="img"></h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>需要实现一些类成员函数</p><ul><li><p><code>segment_received()</code>: 该函数将会在每次获取到 TCP 报文时被调用。该函数需要完成：</p><ul><li><p>如果接收到了 SYN 包，则设置 ISN 编号。</p><p>注意：SYN 和 FIN 包<strong>仍然可以携带用户数据并一同传输</strong>。同时，<strong>同一个数据包下既可以设置 SYN 标志也可以设置 FIN 标志</strong>。</p></li><li><p>将获取到的数据传入流重组器，并在接收到 FIN 包时终止数据传输。</p></li></ul></li><li><p><code>ackno()</code>：返回接收方<strong>尚未获取到的第一个字节的字节索引</strong>。如果 ISN 暂未被设置，则返回空。</p></li><li><p><code>window_size()</code>：返回接收窗口的大小，即<strong>第一个未组装的字节索引</strong>和<strong>第一个不可接受的字节索引</strong>之间的长度。</p></li></ul><p>这是 CS144 对 TCP receiver 的期望执行流程：</p><p><img src="https://kiprey.github.io/2021/11/cs144-lab2/image-20211107122822566.png" alt="image-20211107122822566"></p><p>第三个我们可以直接返回，因为我们在重组器就知道，这个串口就是容量-byte_stream的长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPReceiver::window_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _capacity-_reassembler.<span class="built_in">stream_out</span>().<span class="built_in">buffer_size</span>(); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们看这个api，**void TCPReceiver::segment_received(const TCPSegment &amp;seg) **， 作用就是把收到的tcp片段，进行设置，如果我们自己没有syn，这个有，就设置他为isn,并且在把这个包传入到重组器里面。同时我们进行写入的是index，需要转换成64位（上文的unwarp），然后索引还需要-1，data是在seg的payload字段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPReceiver::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这个题目的意识就是要求我们把这个seg代码来进行写入到我们的接收器里面</span></span><br><span class="line"><span class="comment">// 首先没有isn，就直接失败</span></span><br><span class="line">    <span class="keyword">if</span>(!_set_syn_flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!seg.<span class="built_in">header</span>().syn)<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 没有开头直接就是失败</span></span><br><span class="line">        _set_syn_flag=<span class="literal">true</span>;</span><br><span class="line">        _isn=seg.<span class="built_in">header</span>().seqno;</span><br><span class="line">        <span class="comment">// 序列化在头文件里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接下来我们就是来进行计算seq转化为绝对值，因为seq是32，所以需要我们上面的unwrap</span></span><br><span class="line">    <span class="comment">// 得到相对值checkpoint</span></span><br><span class="line">    <span class="type">uint64_t</span> checkpoint =_reassembler.<span class="built_in">stream_out</span>().<span class="built_in">bytes_written</span>()+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 已经写入了的，作为相对值，这个是在stream里面的，已经排好序的，可以作为相对值</span></span><br><span class="line">    <span class="type">uint64_t</span> convert_seq = <span class="built_in">unwrap</span>(seg.<span class="built_in">header</span>().seqno,_isn,checkpoint);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个知识相对值，我们的stream index</span></span><br><span class="line">    <span class="comment">// 要在上面进行减少1</span></span><br><span class="line">    <span class="keyword">auto</span> stream_index = convert_seq <span class="number">-1</span> +(seg.<span class="built_in">header</span>().syn);</span><br><span class="line">    <span class="comment">// 接下来是写入，调用之前的代码</span></span><br><span class="line">    _reassembler.<span class="built_in">push_substring</span>(seg.<span class="built_in">payload</span>().<span class="built_in">copy</span>(),stream_index,seg.<span class="built_in">header</span>().fin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我接下来，我们看 <strong>optional<WrappingInt32> TCPReceiver::ackno() const</WrappingInt32></strong>，这个作用就是返回ackno，代表，下一次可以接受的位置，就是上一个实验的next_index位置，那么我们只需要把64位，转成32位，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">optional&lt;WrappingInt32&gt; <span class="title">TCPReceiver::ackno</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//    返回ack</span></span><br><span class="line">    <span class="keyword">if</span>(!_set_syn_flag)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算下一个，就是相当于之前的next——index，只需要求出</span></span><br><span class="line">     <span class="type">uint64_t</span> abs_ack_no = _reassembler.<span class="built_in">stream_out</span>().<span class="built_in">bytes_written</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果当前处于 FIN_RECV 状态，则还需要加上 FIN 标志长度</span></span><br><span class="line">    <span class="keyword">if</span> (_reassembler.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>())</span><br><span class="line">        ++abs_ack_no;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">WrappingInt32</span>(_isn) + abs_ack_no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这一届的任务就是让我们知道接收器的作用。</p><ol><li>接受分段，设置isn，然后交给重拍器进行处理</li><li>返回ackno，下一个需要对方发来的序列号</li><li>计算串口，能容纳多少，为了拥塞控制</li></ol><h1 id="lab-3-：TCPSender-实现"><a href="#lab-3-：TCPSender-实现" class="headerlink" title="lab 3 ：TCPSender 实现"></a>lab 3 ：TCPSender 实现</h1><p><img src="https://kiprey.github.io/2021/11/cs144-lab1/image-20211105142904316.png" alt="image-20211105142904316"></p><p>我们已经实现了receiver部分，现在就是sende部分。</p><p>在该实验中，我们需要完成 TCPSender 的以下四个接口：</p><ul><li><p><strong>fill_window</strong>：TCPSender 从 ByteStream 中读取数据，并以 TCPSegement 的形式发送，尽可能地填充接收者的<strong>窗口</strong>。但每个TCP段的大小不得超过 <code>TCPConfig::MAX PAYLOAD SIZE</code>。</p><blockquote><p>若接收方的 Windows size 为 0，则发送方将按照接收方 window size 为 1 的情况进行处理，持续发包。</p><p>因为虽然此时发送方发送的数据包可能会被接收方拒绝，但接收方可以在反向发送 ack 包时，将自己最新的 window size 返回给发送者。否则若双方停止了通信，那么当接收方的 window size 变大后，发送方仍然无法得知接收方可接受的字节数量。</p><p>若远程没有 ack 这个在 window size 为 0 的情况下发送的一字节数据包，那么发送者重传时<strong>不要将 RTO 乘2</strong>。这是因为将 RTO 双倍的目的是为了避免网络拥堵，但此时的数据包丢弃并不是因为网络拥堵的问题，而是远程放不下了。</p></blockquote></li><li><p><strong>ack_received</strong>：对接收方返回的 ackno 和 window size 进行处理。丢弃那些<strong>已经完全确认但仍然处于追踪队列</strong>的数据包。同时如果 window size 仍然存在空闲，则继续发包。</p></li><li><p><strong>tick</strong>：该函数将会被调用以指示经过的时间长度。发送方可能需要重新发送一些超时且没有被确认的数据包。</p></li><li><p><strong>send_empty_segment</strong>：生成并发送一个<strong>在 seq 空间中长度为 0</strong> 并<strong>正确设置 seqno</strong> 的 TCPSegment，这可让用户发送一个空的 ACK 段。</p></li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>我们首先拿最简单的trick进行分析，**void TCPSender::tick(const size_t ms_since_last_tick)**，这个函数的作用就是传入时间来进行模拟时钟，如果景观这些时间超过了定时器规定的时间，就需要进行重新发送文件，同事重启定时器。</p><p>为了使用方便，我们自定义一个定时器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">uint32_t</span> _rto;          <span class="comment">// 超时时间</span></span><br><span class="line">    <span class="type">uint32_t</span> _remain_time;<span class="comment">// 剩余时间</span></span><br><span class="line">    <span class="type">bool</span> _is_running;<span class="comment">// 是否在运行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Timer</span>(<span class="type">uint32_t</span> rto);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动计时器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止计时器</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否超时</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_time_out</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置过去了多少时间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">elapse</span><span class="params">(<span class="type">size_t</span> eplased)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时时间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_time_out</span><span class="params">(<span class="type">uint32_t</span> duration)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>剩余时间，规定的超时时间，还有是否开启的定时器，我们只需要一下几个函数，开启，关闭，是不是超时，设置rto时间，还有更新剩余时间。</p><p>对于trick这个函数，思路就是</p><ol><li>首先更新定时器剩余时间，如果没有超过，就直接return</li><li>如果超过，再看待确认队列是不是空的，是空的，就初始化为最开始的rto，然后返回</li><li>不是，就需要进行重传，重新放入到sender的发送队列，并且更新rto，加倍红船时间（timer的设置时间函数）</li><li>最后打开定时器</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123; </span><br><span class="line">    _timer.<span class="built_in">elapse</span>(ms_since_last_tick);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!_timer.<span class="built_in">is_time_out</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_outstand_segments.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> _timer.<span class="built_in">set_time_out</span>(_initial_retransmission_timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时需要重发第一个报文段，同时将超时时间翻倍</span></span><br><span class="line">    _segments_out.<span class="built_in">push</span>(_outstand_segments.<span class="built_in">front</span>().first);</span><br><span class="line">    <span class="keyword">if</span>(_window_size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">         _consecutive_retxs += <span class="number">1</span>;</span><br><span class="line">    _timer.<span class="built_in">set_time_out</span>(_initial_retransmission_timeout * (<span class="number">1</span> &lt;&lt; _consecutive_retxs));</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">    _timer.<span class="built_in">start</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>接下来就是返回能直接返回的，我们设置重传变量，到时候直接返回</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">TCPSender::consecutive_retransmissions</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _outstand_bytes; &#125;</span><br></pre></td></tr></table></figure><p>返回没有被确认的字节数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">TCPSender::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _outstand_bytes; &#125;</span><br></pre></td></tr></table></figure><p>‘<img src="https://img2023.cnblogs.com/blog/2065884/202304/2065884-20230425140312132-987858718.png" alt="img"></p><p><img src="https://kiprey.github.io/2021/11/cs144-lab1/image-20211107124153476.png" alt="image-20211107124153476"></p><p>现在我们研究fill_windows这个函数，void TCPSender::fill_window()，函数的意识，就是让我们发送byte_stream里面的byte，这个就是发送代码。由于tcp是可靠传输，他有选择重传还有超时重传的机制，保证tcp发送seg能够被确认。因此这个ill_window的作用，就是进行发送seg。</p><p>整个作用就是</p><ol><li>发送最大的长度seg，加入到待确认队列里面</li><li>如果还没有设置syn表示，就自己先发一个syn包</li><li>最后，如果是byte——stream已经发送完了，而且窗口还有剩余的，那就发送fin停止包</li></ol><p><img src="https://img-blog.csdnimg.cn/b798399e091a4c02bb94f6a47d8f7ca3.png" alt="在这里插入图片描述"></p><p><strong>（注意）L:haishi需要按照上面这幅图来理解，ack代表已经进行确认的,next代表下一个序列号,那么我们最大能发送的max(_window_size, static_cast<uint16_t>(1)) + _ack_seq - _next_seqno</uint16_t></strong>,ack只是没有进行确认，next是还没有进行发送的，这和上面接受的重组器差不多，ackno相当于第一个没有阅读的，next和上面的next一样都是第一个没有使用的。</p><ol><li>如果当前还没有建立通信syn，而且等待队列也是空的，那么首先我发syn</li><li>如果不是，就首先计算，当前最大的剩余大小max(_window_size, static_cast<uint16_t>(1)) + _ack_seq - _next_seqno</uint16_t></li><li>然后计算byte_stream能够发送的最大值，之后，剩余减去最大值，一直while</li><li>去除data，构建seg（我们自己实现了一个新的发送seg方法</li><li>之后如果把byte发送完了，但是窗口还有剩余，我们就发送fin结束包</li></ol><blockquote><p>发送代码</p><ol><li>首先构造seg，之后进行设置他head，包括，syn，fin，还有序列号（这个直接用next——seqno）生成</li><li>放入到待确认的队列，更新待确认的byte的长度</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::send_segment</span><span class="params">(string &amp;&amp;data, <span class="type">bool</span> syn, <span class="type">bool</span> fin)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建报文段</span></span><br><span class="line">    TCPSegment segment;</span><br><span class="line">    segment.<span class="built_in">header</span>().syn = syn;</span><br><span class="line">    segment.<span class="built_in">header</span>().fin = fin;</span><br><span class="line">    segment.<span class="built_in">header</span>().seqno = <span class="built_in">next_seqno</span>();</span><br><span class="line">    segment.<span class="built_in">payload</span>() = std::<span class="built_in">move</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将报文段放到发送队列中</span></span><br><span class="line">    _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">    _outstand_segments.<span class="built_in">push</span>(&#123;segment, _next_seqno&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新序号</span></span><br><span class="line">    <span class="keyword">auto</span> len = segment.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">    _outstand_bytes += len;</span><br><span class="line">    _next_seqno += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>整体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!_is_syned) &#123;</span><br><span class="line">        <span class="comment">// 等待 SYN 超时</span></span><br><span class="line">        <span class="keyword">if</span> (!_outstand_segments.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送一个 SYN 包</span></span><br><span class="line">        <span class="built_in">send_segment</span>(<span class="string">&quot;&quot;</span>, <span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> remain_size = <span class="built_in">max</span>(_window_size, <span class="built_in">static_cast</span>&lt;<span class="type">uint16_t</span>&gt;(<span class="number">1</span>)) + _ack_seq - _next_seqno;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当缓冲区中有待发送数据时就发送数据报文段</span></span><br><span class="line">        <span class="keyword">while</span> (remain_size &gt; <span class="number">0</span> &amp;&amp; !_stream.<span class="built_in">buffer_empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ws = <span class="built_in">min</span>(<span class="built_in">min</span>(remain_size, TCPConfig::MAX_PAYLOAD_SIZE), _stream.<span class="built_in">buffer_size</span>());</span><br><span class="line">            remain_size -= ws;</span><br><span class="line"></span><br><span class="line">            string &amp;&amp;data = _stream.<span class="built_in">peek_output</span>(ws);</span><br><span class="line">            _stream.<span class="built_in">pop_output</span>(ws);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 置位 FIN</span></span><br><span class="line">            _is_fin |= (_stream.<span class="built_in">eof</span>() &amp;&amp; !_is_fin &amp;&amp; remain_size &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">send_segment</span>(std::<span class="built_in">move</span>(data), <span class="literal">false</span>, _is_fin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓冲区输入结束时发送 FIN（缓冲区为空时不会进入循环体，需要再次发送）</span></span><br><span class="line">        <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp; !_is_fin &amp;&amp; remain_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _is_fin = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">send_segment</span>(<span class="string">&quot;&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码就相当于是tcp里面的发送代码，建立绘画，并且把没有进行确认的seg放入到待确认的队列里面</p><hr><p>下面我们来看 <strong>void TCPSender::ack_received(const WrappingInt32 ackno, const uint16_t window_size)</strong> 这个api</p><p>他传入的是返回号ackno，还有更新发送窗口的大小。这个就相当于得到ack号来进行确认之前传的文件是不是已经收到</p><ol><li>如果当前ack号&lt;&#x3D;我自己的ackno，相当于返回的是没有，直接return</li><li>如果当前的ack，大于我要法的next_seqno，那也是没用</li><li>我们只要接受到ack号，就把拥塞控制回复到最开始，重传次数也变成0</li><li>之后就是累计确认</li><li>确认完成之后，我们再次进行发送使用fill_window</li><li>最后如果还有没有进行确认的，就需要我们进行使用打开计时器了</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="type">const</span> WrappingInt32 ackno, <span class="type">const</span> <span class="type">uint16_t</span> window_size)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ack_seq = <span class="built_in">unwrap</span>(ackno, _isn, _ack_seq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// absolute ackno 不能落在窗口外</span></span><br><span class="line">    <span class="keyword">if</span> (ack_seq &gt; _next_seqno)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    _window_size = window_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略已处理过的确认应答号</span></span><br><span class="line">    <span class="keyword">if</span> (ack_seq &lt;= _ack_seq)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    _ack_seq = ack_seq;</span><br><span class="line">    _is_syned = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置超时时间为初始值</span></span><br><span class="line">    _timer.<span class="built_in">set_time_out</span>(_initial_retransmission_timeout);</span><br><span class="line">    _consecutive_retxs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除已被确认的报文段</span></span><br><span class="line">    <span class="keyword">while</span> (!_outstand_segments.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;[segment, seqno] = _outstand_segments.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (seqno &gt;= ack_seq)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        _outstand_bytes -= segment.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">        _outstand_segments.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次填满发送窗口</span></span><br><span class="line">    <span class="built_in">fill_window</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还有没被确认的报文段就重启计时器</span></span><br><span class="line">    <span class="keyword">if</span> (!_outstand_segments.<span class="built_in">empty</span>())</span><br><span class="line">        _timer.<span class="built_in">start</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _timer.<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这一部分主要是为了完成，ack发送器的确认，确认成功之后，我就接着再次发送，相当于tcp的三次握手，首先，是建立syn，没有收到syn，那就是我来进行发送，之后获取到ack，那么我们就代表建立成功，更新syn为true，同事更新本地ack为接收到的ack，然后累计确认已近收到了的seg，最后收到确认之后，sender还是需要进行发送，调用fill—windows，最后来进行设置计时器打开与关闭</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这一届需要我们实现的是tcp的发送端，我们需要完成发送byte里面的字段，然后放入到待确认的队列里面，根据会传来的ackno来进行累计确认还有更新，相当于实现tcp的三次握手阶段，我们需要进行发送的文件方法，然后使用累计确认，来确保tcp完整的连接。</p><h1 id="lab4-tcp-connection"><a href="#lab4-tcp-connection" class="headerlink" title="lab4 tcp connection"></a>lab4 tcp connection</h1><p>投降了，这一个，直接抄的<a href="https://kiprey.github.io/2021/11/cs144-lab4/">CS144计算机网络 Lab4 | Kiprey’s Blog</a>，完全看不懂到底在说什么，不知所云，边界测试条件也是一堆，放弃了</p><p>TCPConnection 需要将 TCPSender 和 TCPReceiver 结合，实现成一个 TCP 终端，同时收发数据。</p><p>TCPConnection 有几个规则需要遵守：</p><p>对于<strong>接收数据段</strong>而言：</p><ul><li><p>如果接收到的数据包设置了 RST 标志，则将输入输出字节流全部设置为 错误 状态，并永久关闭 TCP 连接。</p></li><li><p>如果没有收到 RST 标志，则将该数据包传达给 TCPReceiver 来处理，它将对数据包中的 seqno、SYN、payload、FIN 进行处理。</p></li><li><p>如果接收到的数据包中设置了 ACK 标志，则向<strong>当前 TCPConnection</strong> 中<strong>它自己的 TCPSender</strong> 告知远程终端的 ackno 和 window_size。</p><blockquote><p>这一步相当重要，因为数据包在网络中以乱序形式发送，因此远程发送给本地的 ackno 存在滞后性。</p><p>将远程的 ackno 和 window size 附加至发送数据中可以降低这种滞后性，提高 TCP 效率。</p></blockquote></li><li><p>如果接收到的 TCP 数据包包含了一个<strong>有效 seqno</strong>，则 TCPConnection 必须至少返回一个 TCP 包作为回复，以告知远程终端 此时的 ackno 和 window size。</p></li><li><p>如果接收到的 TCP 数据包<strong>包含的 seqno 是无效</strong>的，则 TCPConnection 也需要回复一个类似的无效数据包。这是因为远程终端可能会发送无效数据包以确认当前连接是否有效，同时查看此时接收方的 ackno 和 window size。这被称为 TCP 的 <code>keep-alive</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPYif (_receiver.ackno().has_value() &amp;&amp; seg.length_in_sequence_space() == 0 &amp;&amp; seg.header().seqno == _receiver.ackno().value() - 1) &#123;</span><br><span class="line">  _sender.send_empty_segment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>对于<strong>发送数据段</strong>来说：</p><ul><li>当 TCPSender 将一个 TCPSegment 数据包添加到待发送队列中时，TCPConnection 需要从中取出并将其发送。</li><li>在发送当前数据包之前，TCPConnection 会获取当前<strong>它自己的 TCPReceiver</strong> 的 ackno 和 window size，将其放置进待发送 TCPSegment 中，并设置其 ACK 标志。</li></ul><p>TCPConnection 需要检测时间的流逝。它存在一个 tick 函数，该函数将会被操作系统持续调用。当 TCPConnection 的 tick 函数被调用后，它需要</p><ul><li>告知 TCPSender 时间的流逝，这可能会让 TCPSender 重新发送被丢弃的数据包</li><li>如果连续重传次数超过 <code>TCPConfig::MAX RETX ATTEMPTS</code>，则发送一个 RST 包。</li><li>在条件适合的情况下关闭 TCP 连接（当处于 TCP 的 TIME_WAIT 状态时）。</li></ul><p>TCP 连接的关闭稍微麻烦一些，主要有以下几种情况需要考虑：</p><ul><li><p><strong>接收方收到 RST 标志或者发送方发送 RST 标志</strong>后，设置当前 TCPConnection 的输入输出字节流的状态为错误状态，并<strong>立即</strong>停止退出。这种属于暴力退出（unclear shutdown），可能会导致<strong>尚未传输完成的数据丢失</strong>（例如仍然在网络中运输的数据包在<strong>接收方收到RST标志后</strong>被丢弃）。</p></li><li><p>若想让双方都在数据流收发完整后退出（clear shutdonw），则情况略微麻烦一点。先上张四次挥手的图：</p><p><img src="https://kiprey.github.io/2021/11/cs144-lab4/image-20210515092825158.png" alt="img"></p><p>简单讲下挥手的流程：</p><ul><li><p>当<strong>客户端</strong>的数据全部发送完成，则将会发送 FIN 包以告知服务器 <strong>客户端数据全部发送完成</strong>（发送完成，不等于<strong>被接收完成</strong>）。但请注意，此时的服务器仍然可以发送数据至客户端。</p></li><li><p>当服务器对 客户端的 FIN 进行 ack 后，则说明<strong>服务器确认接收客户端的全部数据</strong>。</p></li><li><p>服务器继续发送数据，直到服务器的数据已经全部发送完成，则向客户端发送 FIN 包以告知<strong>服务端数据全部发送完成</strong>。</p></li><li><p>当客户端对服务端的 FIN <strong>发送</strong> ack 后，则说明<strong>客户端确认接收服务端的全部数据</strong>。注意，此时客户端可以确认：</p><ul><li><strong>服务端</strong>成功接收<strong>客户端</strong>全部数据</li><li><strong>客户端</strong>成功接收<strong>服务端</strong>的全部数据</li></ul><p>此时客户端可以百分百相信，<strong>此时断开连接对客户端是没有任何危害的</strong>。</p><p>但是！当服务器没接收到 客户端的 ACK 时，</p><ul><li>服务器可以确认它成功接收客户端全部数据</li><li>服务器<strong>不知道客户端是否成功接收服务端的全部数据</strong></li></ul><p>也就是说，服务器一定要获得到客户端的 ACK 才能关闭。</p><p>若服务器在超时时间内没获得到客户端的 FIN ACK，则会重发 FIN 包。但假如此时客户端已经断连，那么服务器将<strong>永远无法获取到客户端的 FIN ACK</strong>。因此即便客户端已经完成了它的所有任务，它仍然需要等待服务器端一小段时间，以便于处理服务端的 FIN 包。</p><p>当服务器获取到了客户端的 FIN_ACK 后，它就直接关闭连接。而客户端也会在超时后静默关闭。此时双方均成功获取对方的全部数据，没有造成任何危害。</p><blockquote><p>这里有个很重要的点是，<strong>TCP 不会对 ACK 包来进行 ACK</strong>。例如服务端不会对客户端发来的 FIN_ACK</p></blockquote></li></ul></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>常见的返回值，直接调用receiver或者sender得到，或者自己加入这个值</p><p>[<a href="https://blog.csdn.net/LostUnravel/article/details/124870729">CS144] Lab 4: The TCP connection_cs144 lab4 tcpconnection实现笔记_PeakCrosser的博客-CSDN博客</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">unassembled_bytes</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _time_since_last_segment_received; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _active; &#125;</span><br></pre></td></tr></table></figure><p>首先还是先用trick函数来实现，void TCPConnection::tick(const size_t ms_since_last_tick) ，这个传入的是时间，我们需要用这个歌时间，进行更新sender的trick，还有更新，上次接受到的时间片段。如果经过这个sender的trick，定时器重传次数超时了，我们就需要关闭这个连接，使用rst的方式关闭连接。如果是正常关闭，那就设置active为false就行，然后发送segment</p><blockquote><p>对于<strong>发送数据段</strong>来说：</p><ul><li>当 TCPSender 将一个 TCPSegment 数据包添加到待发送队列中时，TCPConnection 需要从中取出并将其发送。</li><li>在发送当前数据包之前，TCPConnection 会获取当前<strong>它自己的 TCPReceiver</strong> 的 ackno 和 window size，将其放置进待发送 TCPSegment 中，并设置其 ACK 标志。</li></ul></blockquote><p>参照上面的思路，我们需要做的就是，从sender里面的发送队列选择seg，然后，加入ackno，来作为发送的标识（这个是receiver）里面进行得到，最后就是设置窗口大小，然后放入到connection的发送队列里面</p><p><strong>主要功能就是从sender取值，然后装配ack，之后放入到connection的</strong></p><ol><li>sender获取seg</li><li>receiver获取ackno进行装配</li><li>放入到connection得到发送队列里面</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::send_segments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment segment = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        optional&lt;WrappingInt32&gt; ackno = _receiver.<span class="built_in">ackno</span>();</span><br><span class="line">        <span class="comment">// if TCP does not receive SYN segments from the remote peer, i.e. at SYN_SENT state</span></span><br><span class="line">        <span class="comment">// TCP will not set ACK flag and seqno</span></span><br><span class="line">        <span class="keyword">if</span> (ackno.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            segment.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            segment.<span class="built_in">header</span>().ackno = ackno.<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set the local receiver&#x27;s window size</span></span><br><span class="line">        segment.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>() &lt;= numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>()</span><br><span class="line">                                   ? _receiver.<span class="built_in">window_size</span>()</span><br><span class="line">                                   : numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        _segments_out.<span class="built_in">emplace</span>(segment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面实现connect这个，这个代码只会在刚开始建立连接的时候才是用，我们的作用就是发送数据到sender，然后connection从sender进行取值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>write()</code> 方法</p><p>该方法即上层应用向 TCP 的字节流中写入数据进行发送.写数据</p><p>调用sender的byte进行写入数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_active) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> ret = _sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><blockquote><p>对于<strong>接收数据段</strong>而言：</p><ul><li><p>如果接收到的数据包设置了 RST 标志，则将输入输出字节流全部设置为 错误 状态，并永久关闭 TCP 连接。</p></li><li><p>如果没有收到 RST 标志，则将该数据包传达给 TCPReceiver 来处理，它将对数据包中的 seqno、SYN、payload、FIN 进行处理。</p></li><li><p>如果接收到的数据包中设置了 ACK 标志，则向<strong>当前 TCPConnection</strong> 中<strong>它自己的 TCPSender</strong> 告知远程终端的 ackno 和 window_size。</p><blockquote><p>这一步相当重要，因为数据包在网络中以乱序形式发送，因此远程发送给本地的 ackno 存在滞后性。</p><p>将远程的 ackno 和 window size 附加至发送数据中可以降低这种滞后性，提高 TCP 效率。</p></blockquote></li><li><p>如果接收到的 TCP 数据包包含了一个<strong>有效 seqno</strong>，则 TCPConnection 必须至少返回一个 TCP 包作为回复，以告知远程终端 此时的 ackno 和 window size。</p></li><li><p>如果接收到的 TCP 数据包<strong>包含的 seqno 是无效</strong>的，则 TCPConnection 也需要回复一个类似的无效数据包。这是因为远程终端可能会发送无效数据包以确认当前连接是否有效，同时查看此时接收方的 ackno 和 window size。这被称为 TCP 的 <code>keep-alive</code>。</p></li></ul></blockquote><p>那句上面的介绍，我们知道connection的接送流程是什么。</p><ol><li>判断是不是rst，是就设置rxt，然后直接非正常关闭</li><li>不是就交给receiver处理，使用receiver的segment-receiver（得到index，还有数据交给重组器进行处理）</li><li>同事这个接受端如果设置ack，就要交给sender进行处理，这样构成tcp可靠传输，更新窗口</li><li>同时接收到欧晓的seqno，就需要我们进行返回我们的窗口大小</li><li>如果无效，发送一个空的seg</li></ol><p><code>end_input_stream()</code> 方法</p><p>该方法即结束需要发送的数据流, 即出站流. 因此需要调用 <code>_sender.steam_in().end_input()</code> 方法. 而结束流的隐含信息是要<strong>发送一个 FIN 报文段</strong>,</p><p>sender的作用就是进行发送byte—stream的数据，所以我们首先进行设置byte-stream为结束状态，然后调用这个fill，进行发送fin挥手包，最后还是需要发送到connection的</p><p>（只要使用fill-windows，就一定要进行发送到connection</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    _time_since_last_segment_received_ms = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果发来的是一个 ACK 包，则无需发送 ACK</span></span><br><span class="line">    <span class="type">bool</span> need_send_ack = seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line"><span class="comment">// 读取并处理接收到的数据</span></span><br><span class="line"><span class="comment">// _receiver 足够鲁棒以至于无需进行任何过滤</span></span><br><span class="line">_receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是 RST 包，则直接终止</span></span><br><span class="line"><span class="comment">//! <span class="doctag">NOTE:</span> 当 TCP 处于任何状态时，均需绝对接受 RST。因为这可以防止尚未到来数据包产生的影响</span></span><br><span class="line"><span class="keyword">if</span> (seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">    _set_rst_state(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果收到了 ACK 包，则更新 _sender 的状态并补充发送数据</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> _sender 足够鲁棒以至于无需关注传入 ack 是否可靠</span></span><br><span class="line"><span class="built_in">assert</span>(_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>());</span><br><span class="line"><span class="keyword">if</span> (seg.<span class="built_in">header</span>().ack) &#123;</span><br><span class="line">    _sender.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win);</span><br><span class="line">    <span class="comment">// _sender.fill_window(); // 这行其实是多余的，因为已经在 ack_received 中被调用了，不过这里显示说明一下其操作</span></span><br><span class="line">    <span class="comment">// 如果原本需要发送空ack，并且此时 sender 发送了新数据，则停止发送空ack</span></span><br><span class="line">    <span class="keyword">if</span> (need_send_ack &amp;&amp; !_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>())</span><br><span class="line">        need_send_ack = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是 LISEN 到了 SYN</span></span><br><span class="line"><span class="keyword">if</span> (TCPState::<span class="built_in">state_summary</span>(_receiver) == TCPReceiverStateSummary::SYN_RECV &amp;&amp;</span><br><span class="line">    TCPState::<span class="built_in">state_summary</span>(_sender) == TCPSenderStateSummary::CLOSED) &#123;</span><br><span class="line">    <span class="comment">// 此时肯定是第一次调用 fill_window，因此会发送 SYN + ACK</span></span><br><span class="line">    <span class="built_in">connect</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 TCP 断开连接时是否时需要等待</span></span><br><span class="line"><span class="comment">// CLOSE_WAIT</span></span><br><span class="line"><span class="keyword">if</span> (TCPState::<span class="built_in">state_summary</span>(_receiver) == TCPReceiverStateSummary::FIN_RECV &amp;&amp;</span><br><span class="line">    TCPState::<span class="built_in">state_summary</span>(_sender) == TCPSenderStateSummary::SYN_ACKED)</span><br><span class="line">    _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果到了准备断开连接的时候。服务器端先断</span></span><br><span class="line"><span class="comment">// CLOSED</span></span><br><span class="line"><span class="keyword">if</span> (TCPState::<span class="built_in">state_summary</span>(_receiver) == TCPReceiverStateSummary::FIN_RECV &amp;&amp;</span><br><span class="line">    TCPState::<span class="built_in">state_summary</span>(_sender) == TCPSenderStateSummary::FIN_ACKED &amp;&amp; !_linger_after_streams_finish) &#123;</span><br><span class="line">    _is_active = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果收到的数据包里没有任何数据，则这个数据包可能只是为了 keep-alive</span></span><br><span class="line"><span class="keyword">if</span> (need_send_ack)</span><br><span class="line">    _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">_trans_segments_to_out_with_ack_and_win();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体流程如下</p><ol><li>检测是不是还不是alive</li><li>检查是不是rst</li><li>接下来看，是不是刚开始建立绘画的ack状态，（没有ackno还有next发送的，刚开始进行建立）</li><li>之后就是receiver接受这个seg，同事如果有ack，那么sender也需要进行校验</li><li>如果是刚建立的，那么还是需要进行发送fill_windows作为返回放入到sender的发送器</li><li>如果自己的发送器还有接收器都为空，那么就说明彻底结束，不需要继续keep alive</li><li>如果接收到的 TCP 数据包<strong>包含的 seqno 是无效</strong>的，则 TCPConnection 也需要回复一个类似的无效数据包，返回处理特殊情况</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_active) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reset the timer</span></span><br><span class="line">    _time_since_last_segment_received = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> TCPHeader &amp;header = seg.<span class="built_in">header</span>();</span><br><span class="line">    <span class="comment">// if TCP does not receive SYN from remote peer, and not send SYN to remote peer</span></span><br><span class="line">    <span class="keyword">if</span> (!_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; _sender.<span class="built_in">next_seqno_absolute</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// at this time, TCP acts as a server,</span></span><br><span class="line">        <span class="comment">// and should not receive any segment except it has SYN flag</span></span><br><span class="line">        <span class="keyword">if</span>(!header.syn) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">        <span class="comment">// try to send SYN segment, use for opening TCP at the same time</span></span><br><span class="line">        <span class="built_in">connect</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the TCP ends in an unclean shutdown when receiving RST segment</span></span><br><span class="line">    <span class="keyword">if</span> (header.rst) &#123;</span><br><span class="line">        <span class="built_in">unclean_shutdown</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">    <span class="comment">// if TCP sends SYN segment as a client but does not receive SYN from remote peer,</span></span><br><span class="line">    <span class="comment">// the local TCP should not handle it, too. </span></span><br><span class="line">    <span class="keyword">if</span> (!_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the `_linger_after_streams_finish` the first time the inbound stream ends</span></span><br><span class="line">    <span class="keyword">if</span> (!_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>()) &#123;</span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// use the remote peer&#x27;s ackno and window size to update the local sending window</span></span><br><span class="line">    <span class="keyword">if</span> (header.ack) &#123;</span><br><span class="line">        _sender.<span class="built_in">ack_received</span>(header.ackno, header.win);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="comment">// makes sure that at least one segment is sent in reply</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() &gt; <span class="number">0</span> &amp;&amp; _sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// an extra special case to respond to a keep-alive segment</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span> &amp;&amp; header.seqno == _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后一个就是关闭，分为正常操作，还有不正常。正常直接就是不在activate活跃，不正常全部进入error状态</p><p>下面是正常关闭</p><blockquote><p>TCP 的正常关闭即 TCP 的四次挥手, 是本实验中最为复杂的地方, 其中也有笔者不是很确定的地方.<br>TCP 正常关闭的四个前提已经在 #要点 中提到, 如下即前提与代码的对应:</p><p>Prereq#1: _receiver.unassembled_bytes()&#x3D;&#x3D;0 &amp;&amp; _receiver.stream_out().input_ended(), 实际上可以直接转化为 _receiver.stream_out().input_ended()(此处使用 _receiver.stream_out().eof() 方法同样能通过测试, 任务指导中描述使用的 ended, 因此这里笔者选择了前者).<br>Prereq#2: _sender.stream_in().eof(). 这里需要是 eof() 方法而非 input_ended(), 因为要确保发送字节流的所有数据已经全部发送出去.<br>Prereq#3: _sender.bytes_in_flight()&#x3D;&#x3D;0</p></blockquote><p>主要就是发送器为eof，接收器为eof，然后还没有没被确认的byte</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// TCP clean shutdown</span><br><span class="line">if (_receiver.stream_out().input_ended() &amp;&amp; _sender.stream_in().eof() &amp;&amp; _sender.bytes_in_flight() == 0 &amp;&amp; (!_linger_after_streams_finish || _time_since_last_segment_received &gt;= 10 * _cfg.rt_timeout)) &#123;</span><br><span class="line">    _active = false;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不正常的关闭就是设置为error，然后也是关闭</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">TCPConnection::unclean_shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _active = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后一个就是rst，这个作用就是封装的时候，我们从sender里面提取的seg加入一个rst标志位，然后再次调用connection的发送代码来进行发送。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::send_RST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    TCPSegment segment = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">    _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">    optional&lt;WrappingInt32&gt; ackno = _receiver.<span class="built_in">ackno</span>();</span><br><span class="line">    <span class="keyword">if</span> (ackno.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        segment.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">        segment.<span class="built_in">header</span>().ackno = ackno.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    segment.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>() &lt;= numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>()</span><br><span class="line">                               ? _receiver.<span class="built_in">window_size</span>()</span><br><span class="line">                               : numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    segment.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">    _segments_out.<span class="built_in">emplace</span>(segment);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unclean_shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>整体代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_connection.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy implementation of a TCP connection</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For Lab 4, please replace with a real implementation that passes the</span></span><br><span class="line"><span class="comment">// automated checks run by `make check`.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;...<span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">unassembled_bytes</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _time_since_last_segment_received; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_active) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reset the timer</span></span><br><span class="line">    _time_since_last_segment_received = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> TCPHeader &amp;header = seg.<span class="built_in">header</span>();</span><br><span class="line">    <span class="comment">// if TCP does not receive SYN from remote peer, and not send SYN to remote peer</span></span><br><span class="line">    <span class="keyword">if</span> (!_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; _sender.<span class="built_in">next_seqno_absolute</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// at this time, TCP acts as a server,</span></span><br><span class="line">        <span class="comment">// and should not receive any segment except it has SYN flag</span></span><br><span class="line">        <span class="keyword">if</span> (!header.syn) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">        <span class="comment">// try to send SYN segment, use for opening TCP at the same time</span></span><br><span class="line">        <span class="built_in">connect</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the TCP ends in an unclean shutdown when receiving RST segment</span></span><br><span class="line">    <span class="keyword">if</span> (header.rst) &#123;</span><br><span class="line">        <span class="built_in">unclean_shutdown</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">    <span class="comment">// if TCP sends SYN segment as a client but does not receive SYN from remote peer,</span></span><br><span class="line">    <span class="comment">// the local TCP should not handle it, too.</span></span><br><span class="line">    <span class="keyword">if</span> (!_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the `_linger_after_streams_finish` the first time the inbound stream ends</span></span><br><span class="line">    <span class="keyword">if</span> (!_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>()) &#123;</span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// use the remote peer&#x27;s ackno and window size to update the local sending window</span></span><br><span class="line">    <span class="keyword">if</span> (header.ack) &#123;</span><br><span class="line">        _sender.<span class="built_in">ack_received</span>(header.ackno, header.win);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="comment">// makes sure that at least one segment is sent in reply</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() &gt; <span class="number">0</span> &amp;&amp; _sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// an extra special case to respond to a keep-alive segment</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span> &amp;&amp; header.seqno == _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _active; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_active) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> ret = _sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_active) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _time_since_last_segment_received += ms_since_last_tick;</span><br><span class="line">    _sender.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line">    <span class="comment">// TCP unclean shutdown if the number of consecutive retransmissions</span></span><br><span class="line">    <span class="comment">// is more than an upper limit</span></span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">consecutive_retransmissions</span>() &gt; TCPConfig::MAX_RETX_ATTEMPTS) &#123;</span><br><span class="line">        <span class="built_in">send_RST</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TCP clean shutdown if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (!_linger_after_streams_finish || _time_since_last_segment_received &gt;= <span class="number">10</span> * _cfg.rt_timeout)) &#123;</span><br><span class="line">        _active = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// send segments when `_sender.tick()` has a retransmission</span></span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCPConnection::~<span class="built_in">TCPConnection</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">active</span>()) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Warning: Unclean shutdown of TCPConnection\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Your code here: need to send a RST segment to the peer</span></span><br><span class="line">            <span class="built_in">send_RST</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception destructing TCP FSM: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::send_segments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment segment = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        optional&lt;WrappingInt32&gt; ackno = _receiver.<span class="built_in">ackno</span>();</span><br><span class="line">        <span class="comment">// if TCP does not receive SYN segments from the remote peer, i.e. at SYN_SENT state</span></span><br><span class="line">        <span class="comment">// TCP will not set ACK flag and seqno</span></span><br><span class="line">        <span class="keyword">if</span> (ackno.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            segment.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            segment.<span class="built_in">header</span>().ackno = ackno.<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set the local receiver&#x27;s window size</span></span><br><span class="line">        segment.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>() &lt;= numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>()</span><br><span class="line">                                   ? _receiver.<span class="built_in">window_size</span>()</span><br><span class="line">                                   : numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        _segments_out.<span class="built_in">emplace</span>(segment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::send_RST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    TCPSegment segment = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">    _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">    optional&lt;WrappingInt32&gt; ackno = _receiver.<span class="built_in">ackno</span>();</span><br><span class="line">    <span class="keyword">if</span> (ackno.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        segment.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">        segment.<span class="built_in">header</span>().ackno = ackno.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    segment.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>() &lt;= numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>() ? _receiver.<span class="built_in">window_size</span>()</span><br><span class="line">                                                                                      : numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    segment.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">    _segments_out.<span class="built_in">emplace</span>(segment);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unclean_shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">TCPConnection::unclean_shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _active = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>这一届主要是实现如何建立连接，在两个对等节点之间。我们调用之前实现的sender还有receiver来进行处理。这一节的边界条件太多，直接参考的别人的实现。</p><p>主要实现的功能就是发送还有接受</p><p>connection的发送功能就是从sender里面获取seg，然后进行封装ack来发送，放入到自己的connection的队列</p><p>connection的接受功能就比较多，建立会话联系，1.刚开始建立syn的时候收到seg，这个歌时候要看他有没有syn标识，有就直接交给receiver处理，因为这个时候不需要进行校验ack，保证tcp的完整性。2.如果是rst错误，直接不安全的关闭连接。3.普通的seg，来确保收到的正确，这个时候就需要receiver还有sender，receiver手机seg，sender使用ackno更新窗口还有确认之前发送的已经到达，之后还需要发送自己文件，sender使用fill-windows来发送。最后是特殊条件，还有放入到sender队列里面，这个时候，就需要connection进行发送。</p><p>trick的功能</p><ol><li>更新sender里面的定时器</li><li>然后超时设置rst</li><li>之后就是接着发送send（因为重传，可能会放入新的seg到sender的队列里面）</li></ol><p>剩下的就是普通的代码，可以直接返回的。</p><p>总体来说，这个代码还是非常难得。不像xv6那种有提示，这个代码的提示基本没有，操作说明说了和没有说一样，只能按照别人已经实现了的代码，来倒退这个函数到底是要干什么。这几个la做完，的确对tcp的可靠传输，还有拥塞控制有了更一步的了解。主要的是还是要参考，下面2张图。</p><p>知道sender，还有receiver的底层</p><p><img src="https://img2023.cnblogs.com/blog/2065884/202304/2065884-20230425140312132-987858718.png" alt="img"></p><p>然后重组器的实现机制，和发送器能发送的窗口。</p><ol><li>重组器的next就是第一个没有assemble的</li><li>发送器的窗口大小是ack+windows—next，ack是第一个还没有读入到的，绿色的就是没有确认的</li></ol><p><img src="https://kiprey.github.io/2021/11/cs144-lab1/image-20211107124153476.png" alt="image-20211107124153476"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab0-：warm-up&quot;&gt;&lt;a href=&quot;#lab0-：warm-up&quot; class=&quot;headerlink&quot; title=&quot;lab0 ：warm up&quot;&gt;&lt;/a&gt;lab0 ：warm up&lt;/h1&gt;&lt;p&gt;第0张就是温习一下网络的相关知识。&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    
    <category term="cs144" scheme="http://yoursite.com/tags/cs144/"/>
    
    <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>warp配置clash</title>
    <link href="http://yoursite.com/2023/07/09/warp%E9%85%8D%E7%BD%AEclash/"/>
    <id>http://yoursite.com/2023/07/09/warp%E9%85%8D%E7%BD%AEclash/</id>
    <published>2023-07-09T03:11:38.000Z</published>
    <updated>2023-07-09T03:43:53.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是WARP"><a href="#什么是WARP" class="headerlink" title="什么是WARP"></a>什么是WARP</h1><p>WARP是cloudflare公司推出的可以用来保护使用者隐私的一款服务，对于经常使用WARP来解锁vps流媒体的人再熟悉不过了。</p><p>WARP基于wireguard协议，使用UDP来传输数据，也就意味着在公网中的高QOS，但是WARP的ip相对比较干净，对外访问网络的出口 IP 被很多网站视为真实用户，可以用来解锁流媒体，谷歌学术等。</p><p>本文是基于作者的粗略了解成文，故很多地方可能会出现些许错误，若出现错误，还望各位海涵，并发邮件通知我，我会尽快修改。</p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>直接去官网1.1.1.1进行下载，有安卓还有windows客户端。</p><h1 id="获取24PB流量"><a href="#获取24PB流量" class="headerlink" title="获取24PB流量"></a>获取24PB流量</h1><p>打开Telegram机器人，按要求输入命令进行获取warp+ unlimited license key Wrap+ Bot：<a href="https://t.me/generatewarpplusbot">https://t.me/generatewarpplusbot</a></p><p><img src="https://lykqq.com/usr/uploads/2023/04/518483876.png" alt="96080-fuatm3pq65e.png"></p><p>更换密钥到客户端</p><p><img src="https://lykqq.com/usr/uploads/2023/04/3541976739.png" alt="91479-g9o0s6b1mdl.png"></p><p><img src="https://lykqq.com/usr/uploads/2023/04/2513971098.png" alt="77465-masdybx7iq.png"></p><h1 id="windows连接"><a href="#windows连接" class="headerlink" title="windows连接"></a>windows连接</h1><p>windows连接需要使用clash进行前置连接登录，设置clash为tun模式，然后打开warp。</p><h1 id="提取warp配置"><a href="#提取warp配置" class="headerlink" title="提取warp配置"></a>提取warp配置</h1><p>使用github上的wgcf这个来进行获取配置。warp本质上是基于wireguard协议来进行生成的。因此我们完全可以不需要使用客户端，直接使用支持wireguard协议的第三方客户端来进行使用。</p><p>1.下载wgcf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -O wgcf https://github.com/ViRb3/wgcf/releases/download/v2.1.4/wgcf_2.1.4_linux_amd64</span><br><span class="line">chmod +x wgcf</span><br></pre></td></tr></table></figure><p>2、注册 WARP 账户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./wgcf register</span><br></pre></td></tr></table></figure><p>在root文件夹下就会出现&#x2F;root&#x2F;wgcf-account.toml文件，里面是wgcf申请的免费账户信息，<strong>你可以将license_key替换成你自己的warp+ key，获取方法打开App右上角菜单 三 –&gt; 账户 –&gt; 按键，复制替换即可。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./wgcf update</span><br></pre></td></tr></table></figure><p>在这一步。我们可以把我们24pb流量的key进行更换，然后再进行升级</p><p>3生成Wire­Guard配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./wgcf generate</span><br></pre></td></tr></table></figure><p>在root文件夹下就会出现&#x2F;root&#x2F;wgcf-profile.conf文件，这就是wgcf生成的Wire­Guard配置文件，可以导入到任何一个支持Wire­Guard协议的软件中使用。</p><p>（可选）4.优选ip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N https://gitlab.com/Misaka-blog/warp-script/-/raw/main/files/warp-yxip/warp-yxip.sh &amp;&amp; bash warp-yxip.sh</span><br></pre></td></tr></table></figure><p>获取优选ip，得到更好的连接体验，更换endpoint为刚刚获取的优选ip还有端口，在wgcf的配置文件里面</p><p><img src="https://github.com/getsomecat/GetSomeCats/raw/Surge/%E4%BC%98%E9%80%89WARP%E7%9A%84EndPoint%20IP%EF%BC%8C%E6%8F%90%E9%AB%98%E6%9C%AC%E5%9C%B0WARP%E8%8A%82%E7%82%B9%E8%AE%BF%E9%97%AE%E6%80%A7%E3%80%81%E4%BF%AE%E6%94%B9%E5%AE%98%E6%96%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84EndPoint%20IP%E4%BB%A5%E5%8F%8A%E8%A7%A3%E9%94%81ChatGPT.assets/20230328001632.png" alt="20230328001632"></p><p><img src="https://github.com/getsomecat/GetSomeCats/raw/Surge/%E4%BC%98%E9%80%89WARP%E7%9A%84EndPoint%20IP%EF%BC%8C%E6%8F%90%E9%AB%98%E6%9C%AC%E5%9C%B0WARP%E8%8A%82%E7%82%B9%E8%AE%BF%E9%97%AE%E6%80%A7%E3%80%81%E4%BF%AE%E6%94%B9%E5%AE%98%E6%96%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84EndPoint%20IP%E4%BB%A5%E5%8F%8A%E8%A7%A3%E9%94%81ChatGPT.assets/20230328001706.png" alt="20230328001706"></p><p><img src="https://github.com/getsomecat/GetSomeCats/raw/Surge/%E4%BC%98%E9%80%89WARP%E7%9A%84EndPoint%20IP%EF%BC%8C%E6%8F%90%E9%AB%98%E6%9C%AC%E5%9C%B0WARP%E8%8A%82%E7%82%B9%E8%AE%BF%E9%97%AE%E6%80%A7%E3%80%81%E4%BF%AE%E6%94%B9%E5%AE%98%E6%96%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84EndPoint%20IP%E4%BB%A5%E5%8F%8A%E8%A7%A3%E9%94%81ChatGPT.assets/20230312172834.png" alt="20230312172834"></p><h1 id="clash配置wireguard"><a href="#clash配置wireguard" class="headerlink" title="clash配置wireguard"></a>clash配置wireguard</h1><p>参照官方的clash配置文件写法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">proxies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;wg&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">wireguard</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">myserver.dyn.org</span> <span class="comment">#aka peer endpoint</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">51820</span> <span class="comment">#aka peer endpoint port</span></span><br><span class="line">    <span class="attr">ip:</span> <span class="number">10.90</span><span class="number">.0</span><span class="number">.2</span> <span class="comment">#aka self ip address or address</span></span><br><span class="line">    <span class="comment"># ipv6: your_ipv6 #aka self ipv6 address or address</span></span><br><span class="line">    <span class="attr">private-key:</span> <span class="string">ANtlGLhcIXthucHavUPT0q8AOmHu+6+smP4Vfh3M2W8=</span></span><br><span class="line">    <span class="attr">public-key:</span> <span class="string">RPoEJdhT+kGH07EnIrwmKrbAdPlRqRwsrzgx4VAYGy0=</span></span><br><span class="line">    <span class="comment"># preshared-key: 66l8JUDdpHBBSKezlDVwNKyaNaEm+xZ+3/1JzXNJ39k=</span></span><br><span class="line">    <span class="comment"># dns: [1.1.1.1, 8.8.8.8]</span></span><br><span class="line">    <span class="comment"># mtu: 1420</span></span><br><span class="line">    <span class="attr">udp:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">remote-dns-resolve:</span> <span class="literal">true</span> <span class="comment">#start support from Premium 2023.02.16</span></span><br></pre></td></tr></table></figure><p>我们需要设置的只有公钥私钥，还有ip地址</p><p>这些文件，直接按照提取的参考config来进行配置，server可以设置成之前得到的优选ip</p><h1 id="（可选）clash设置relay，进行链式配置（得到稳定台湾ip）"><a href="#（可选）clash设置relay，进行链式配置（得到稳定台湾ip）" class="headerlink" title="（可选）clash设置relay，进行链式配置（得到稳定台湾ip）"></a>（可选）clash设置relay，进行链式配置（得到稳定台湾ip）</h1><p>1.设置代理组，参照官方clash文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Proxy Groups:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;relay&quot;</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">relay</span></span><br><span class="line">  <span class="attr">proxies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">select</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">vmess1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ss1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ss2</span></span><br><span class="line"> <span class="comment">#disable-udp: true</span></span><br></pre></td></tr></table></figure><p>类型是relay。</p><p>原理：clash首先会通过垃圾机场，访问warp，warp得到ip是基于访问ip的来进行生成附近的ip。所以我们可以用垃圾机场的ip得到稳定优质台湾ip。</p><p>接下来，我们还需要进行配置策略组，让访问网站走relay代理组</p><p><img src="https://docs.cfw.lbyczf.com/assets/img/ui-profiles-rules1.d499c4e2.png" alt="img"></p><p>只需要在这里进行添加match，选择relay，就可以走链式代理</p><ul><li>MATCH：全匹配</li></ul><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16888739339471688873933188.png" alt="16888739339471688873933188.png"></p><p>这样所有的匹配就会走clash的链式代理组。</p><p>安卓使用sagernet，手动设置代理链就可以使用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是WARP&quot;&gt;&lt;a href=&quot;#什么是WARP&quot; class=&quot;headerlink&quot; title=&quot;什么是WARP&quot;&gt;&lt;/a&gt;什么是WARP&lt;/h1&gt;&lt;p&gt;WARP是cloudflare公司推出的可以用来保护使用者隐私的一款服务，对于经常使用WARP来解锁</summary>
      
    
    
    
    
    <category term="warp" scheme="http://yoursite.com/tags/warp/"/>
    
    <category term="cf" scheme="http://yoursite.com/tags/cf/"/>
    
    <category term="clash" scheme="http://yoursite.com/tags/clash/"/>
    
  </entry>
  
  <entry>
    <title>mmseg代码课</title>
    <link href="http://yoursite.com/2023/06/14/mmseg%E4%BB%A3%E7%A0%81%E8%AF%BE/"/>
    <id>http://yoursite.com/2023/06/14/mmseg%E4%BB%A3%E7%A0%81%E8%AF%BE/</id>
    <published>2023-06-14T07:45:40.000Z</published>
    <updated>2023-06-14T11:28:59.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像分割简介"><a href="#图像分割简介" class="headerlink" title="图像分割简介"></a>图像分割简介</h1><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/1686729066208MMSEG.png"></p><p>主要介绍了图像分割发展历程。之前了解了一些图像分割，主要是使用调色板，png图像来进行保存图像。因此对每一个标签都需要绘画一种颜色。</p><p>为了让每一个像素值都是一个类别，需要使用膨胀卷积，保存图像不变，输出 的是图像，不是类别</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/1686729232196MMseg%E4%BB%A3%E7%A0%81%E8%AF%BE.png"></p><p>因此在训练的时候，需要不仅仅写cfg，还需要再写dataset，这个是核心函数，定义颜色，还有类别，分割的显示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同济子豪兄 2023-2-15</span></span><br><span class="line"><span class="keyword">from</span> mmseg.registry <span class="keyword">import</span> DATASETS</span><br><span class="line"><span class="keyword">from</span> .basesegdataset <span class="keyword">import</span> BaseSegDataset</span><br><span class="line"></span><br><span class="line"><span class="meta">@DATASETS.register_module()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WatermelonDataset</span>(<span class="title class_ inherited__">BaseSegDataset</span>):</span><br><span class="line">    <span class="comment"># 类别和对应的可视化配色</span></span><br><span class="line">    METAINFO = &#123;</span><br><span class="line">        <span class="string">&#x27;classes&#x27;</span>:[<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;seed-black&#x27;</span>, <span class="string">&#x27;seed-white&#x27;</span>, <span class="string">&#x27;Unlabeled&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;palette&#x27;</span>:[[<span class="number">132</span>,<span class="number">41</span>,<span class="number">246</span>], [<span class="number">228</span>,<span class="number">193</span>,<span class="number">110</span>], [<span class="number">152</span>,<span class="number">16</span>,<span class="number">60</span>], [<span class="number">58</span>,<span class="number">221</span>,<span class="number">254</span>], [<span class="number">41</span>,<span class="number">169</span>,<span class="number">226</span>], [<span class="number">155</span>,<span class="number">155</span>,<span class="number">155</span>]]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 指定图像扩展名、标注扩展名</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">                 img_suffix=<span class="string">&#x27;.jpg&#x27;</span>,</span></span><br><span class="line"><span class="params">                 seg_map_suffix=<span class="string">&#x27;.png&#x27;</span>,</span></span><br><span class="line"><span class="params">                 reduce_zero_label=<span class="literal">False</span>, <span class="comment"># 类别ID为0的类别是否需要除去</span></span></span><br><span class="line"><span class="params">                 **kwargs</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__(</span><br><span class="line">            img_suffix=img_suffix,</span><br><span class="line">            seg_map_suffix=seg_map_suffix,</span><br><span class="line">            reduce_zero_label=reduce_zero_label,</span><br><span class="line">            **kwargs)</span><br></pre></td></tr></table></figure><p>之后进行设置cfg</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line">norm_cfg = <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;BN&#x27;</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">data_preprocessor = <span class="built_in">dict</span>(</span><br><span class="line">    <span class="built_in">type</span>=<span class="string">&#x27;SegDataPreProcessor&#x27;</span>,</span><br><span class="line">    mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>],</span><br><span class="line">    std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>],</span><br><span class="line">    bgr_to_rgb=<span class="literal">True</span>,</span><br><span class="line">    pad_val=<span class="number">0</span>,</span><br><span class="line">    seg_pad_val=<span class="number">255</span>,</span><br><span class="line">    size=(<span class="number">64</span>, <span class="number">64</span>))</span><br><span class="line">model = <span class="built_in">dict</span>(</span><br><span class="line">    <span class="built_in">type</span>=<span class="string">&#x27;EncoderDecoder&#x27;</span>,</span><br><span class="line">    data_preprocessor=<span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&#x27;SegDataPreProcessor&#x27;</span>,</span><br><span class="line">        mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>],</span><br><span class="line">        std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>],</span><br><span class="line">        bgr_to_rgb=<span class="literal">True</span>,</span><br><span class="line">        pad_val=<span class="number">0</span>,</span><br><span class="line">        seg_pad_val=<span class="number">255</span>,</span><br><span class="line">        size=(<span class="number">256</span>, <span class="number">256</span>)),</span><br><span class="line">    pretrained=<span class="string">&#x27;open-mmlab://resnet50_v1c&#x27;</span>,</span><br><span class="line">    backbone=<span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&#x27;ResNetV1c&#x27;</span>,</span><br><span class="line">        depth=<span class="number">50</span>,</span><br><span class="line">        num_stages=<span class="number">4</span>,</span><br><span class="line">        out_indices=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        dilations=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line">        strides=(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        norm_cfg=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;BN&#x27;</span>, requires_grad=<span class="literal">True</span>),</span><br><span class="line">        norm_eval=<span class="literal">False</span>,</span><br><span class="line">        style=<span class="string">&#x27;pytorch&#x27;</span>,</span><br><span class="line">        contract_dilation=<span class="literal">True</span>),</span><br><span class="line">    decode_head=<span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&#x27;PSPHead&#x27;</span>,</span><br><span class="line">        in_channels=<span class="number">2048</span>,</span><br><span class="line">        in_index=<span class="number">3</span>,</span><br><span class="line">        channels=<span class="number">512</span>,</span><br><span class="line">        pool_scales=(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>),</span><br><span class="line">        dropout_ratio=<span class="number">0.1</span>,</span><br><span class="line">        num_classes=<span class="number">6</span>,</span><br><span class="line">        norm_cfg=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;BN&#x27;</span>, requires_grad=<span class="literal">True</span>),</span><br><span class="line">        align_corners=<span class="literal">False</span>,</span><br><span class="line">        loss_decode=<span class="built_in">dict</span>(</span><br><span class="line">            <span class="built_in">type</span>=<span class="string">&#x27;CrossEntropyLoss&#x27;</span>, use_sigmoid=<span class="literal">False</span>, loss_weight=<span class="number">1.0</span>)),</span><br><span class="line">    auxiliary_head=<span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&#x27;FCNHead&#x27;</span>,</span><br><span class="line">        in_channels=<span class="number">1024</span>,</span><br><span class="line">        in_index=<span class="number">2</span>,</span><br><span class="line">        channels=<span class="number">256</span>,</span><br><span class="line">        num_convs=<span class="number">1</span>,</span><br><span class="line">        concat_input=<span class="literal">False</span>,</span><br><span class="line">        dropout_ratio=<span class="number">0.1</span>,</span><br><span class="line">        num_classes=<span class="number">6</span>,</span><br><span class="line">        norm_cfg=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;BN&#x27;</span>, requires_grad=<span class="literal">True</span>),</span><br><span class="line">        align_corners=<span class="literal">False</span>,</span><br><span class="line">        loss_decode=<span class="built_in">dict</span>(</span><br><span class="line">            <span class="built_in">type</span>=<span class="string">&#x27;CrossEntropyLoss&#x27;</span>, use_sigmoid=<span class="literal">False</span>, loss_weight=<span class="number">0.4</span>)),</span><br><span class="line">    train_cfg=<span class="built_in">dict</span>(),</span><br><span class="line">    test_cfg=<span class="built_in">dict</span>(mode=<span class="string">&#x27;whole&#x27;</span>))</span><br><span class="line"></span><br><span class="line">dataset_type = <span class="string">&#x27;WatermelonDataset&#x27;</span></span><br><span class="line">data_root = <span class="string">&#x27;watermelon/Watermelon87_Semantic_Seg_Mask/&#x27;</span></span><br><span class="line">crop_size = (<span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">train_pipeline = [</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;LoadImageFromFile&#x27;</span>),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;LoadAnnotations&#x27;</span>),</span><br><span class="line">    <span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&#x27;RandomResize&#x27;</span>,</span><br><span class="line">        scale=(<span class="number">2048</span>, <span class="number">1024</span>),</span><br><span class="line">        ratio_range=(<span class="number">0.5</span>, <span class="number">2.0</span>),</span><br><span class="line">        keep_ratio=<span class="literal">True</span>),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;RandomCrop&#x27;</span>, crop_size=(<span class="number">64</span>, <span class="number">64</span>), cat_max_ratio=<span class="number">0.75</span>),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;RandomFlip&#x27;</span>, prob=<span class="number">0.5</span>),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;PhotoMetricDistortion&#x27;</span>),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;PackSegInputs&#x27;</span>)</span><br><span class="line">]</span><br><span class="line">test_pipeline = [</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;LoadImageFromFile&#x27;</span>),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;Resize&#x27;</span>, scale=(<span class="number">2048</span>, <span class="number">1024</span>), keep_ratio=<span class="literal">True</span>),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;LoadAnnotations&#x27;</span>),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;PackSegInputs&#x27;</span>)</span><br><span class="line">]</span><br><span class="line">img_ratios = [<span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1.0</span>, <span class="number">1.25</span>, <span class="number">1.5</span>, <span class="number">1.75</span>]</span><br><span class="line">tta_pipeline = [</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;LoadImageFromFile&#x27;</span>, file_client_args=<span class="built_in">dict</span>(backend=<span class="string">&#x27;disk&#x27;</span>)),</span><br><span class="line">    <span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&#x27;TestTimeAug&#x27;</span>,</span><br><span class="line">        transforms=[[&#123;</span><br><span class="line">            <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Resize&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;scale_factor&#x27;</span>: <span class="number">0.5</span>,</span><br><span class="line">            <span class="string">&#x27;keep_ratio&#x27;</span>: <span class="literal">True</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Resize&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;scale_factor&#x27;</span>: <span class="number">0.75</span>,</span><br><span class="line">            <span class="string">&#x27;keep_ratio&#x27;</span>: <span class="literal">True</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Resize&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;scale_factor&#x27;</span>: <span class="number">1.0</span>,</span><br><span class="line">            <span class="string">&#x27;keep_ratio&#x27;</span>: <span class="literal">True</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Resize&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;scale_factor&#x27;</span>: <span class="number">1.25</span>,</span><br><span class="line">            <span class="string">&#x27;keep_ratio&#x27;</span>: <span class="literal">True</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Resize&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;scale_factor&#x27;</span>: <span class="number">1.5</span>,</span><br><span class="line">            <span class="string">&#x27;keep_ratio&#x27;</span>: <span class="literal">True</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Resize&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;scale_factor&#x27;</span>: <span class="number">1.75</span>,</span><br><span class="line">            <span class="string">&#x27;keep_ratio&#x27;</span>: <span class="literal">True</span></span><br><span class="line">        &#125;],</span><br><span class="line">                    [&#123;</span><br><span class="line">                        <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;RandomFlip&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;prob&#x27;</span>: <span class="number">0.0</span>,</span><br><span class="line">                        <span class="string">&#x27;direction&#x27;</span>: <span class="string">&#x27;horizontal&#x27;</span></span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;RandomFlip&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;prob&#x27;</span>: <span class="number">1.0</span>,</span><br><span class="line">                        <span class="string">&#x27;direction&#x27;</span>: <span class="string">&#x27;horizontal&#x27;</span></span><br><span class="line">                    &#125;], [&#123;</span><br><span class="line">                        <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;LoadAnnotations&#x27;</span></span><br><span class="line">                    &#125;], [&#123;</span><br><span class="line">                        <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;PackSegInputs&#x27;</span></span><br><span class="line">                    &#125;]])</span><br><span class="line">]</span><br><span class="line">train_dataloader = <span class="built_in">dict</span>(</span><br><span class="line">    batch_size=<span class="number">8</span>,</span><br><span class="line">    num_workers=<span class="number">2</span>,</span><br><span class="line">    persistent_workers=<span class="literal">True</span>,</span><br><span class="line">    sampler=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;InfiniteSampler&#x27;</span>, shuffle=<span class="literal">True</span>),</span><br><span class="line">    dataset=<span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&#x27;DubaiDataset&#x27;</span>,</span><br><span class="line">        data_root=<span class="string">&#x27;watermelon/Watermelon87_Semantic_Seg_Mask/&#x27;</span>,</span><br><span class="line">        data_prefix=<span class="built_in">dict</span>(</span><br><span class="line">            img_path=<span class="string">&#x27;img_dir/train&#x27;</span>, seg_map_path=<span class="string">&#x27;ann_dir/train&#x27;</span>),</span><br><span class="line">        pipeline=[</span><br><span class="line">            <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;LoadImageFromFile&#x27;</span>),</span><br><span class="line">            <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;LoadAnnotations&#x27;</span>),</span><br><span class="line">            <span class="built_in">dict</span>(</span><br><span class="line">                <span class="built_in">type</span>=<span class="string">&#x27;RandomResize&#x27;</span>,</span><br><span class="line">                scale=(<span class="number">2048</span>, <span class="number">1024</span>),</span><br><span class="line">                ratio_range=(<span class="number">0.5</span>, <span class="number">2.0</span>),</span><br><span class="line">                keep_ratio=<span class="literal">True</span>),</span><br><span class="line">            <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;RandomCrop&#x27;</span>, crop_size=(<span class="number">64</span>, <span class="number">64</span>), cat_max_ratio=<span class="number">0.75</span>),</span><br><span class="line">            <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;RandomFlip&#x27;</span>, prob=<span class="number">0.5</span>),</span><br><span class="line">            <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;PhotoMetricDistortion&#x27;</span>),</span><br><span class="line">            <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;PackSegInputs&#x27;</span>)</span><br><span class="line">        ]))</span><br><span class="line">val_dataloader = <span class="built_in">dict</span>(</span><br><span class="line">    batch_size=<span class="number">1</span>,</span><br><span class="line">    num_workers=<span class="number">4</span>,</span><br><span class="line">    persistent_workers=<span class="literal">True</span>,</span><br><span class="line">    sampler=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;DefaultSampler&#x27;</span>, shuffle=<span class="literal">False</span>),</span><br><span class="line">    dataset=<span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&#x27;DubaiDataset&#x27;</span>,</span><br><span class="line">        data_root=<span class="string">&#x27;watermelon/Watermelon87_Semantic_Seg_Mask/&#x27;</span>,</span><br><span class="line">        data_prefix=<span class="built_in">dict</span>(img_path=<span class="string">&#x27;img_dir/val&#x27;</span>, seg_map_path=<span class="string">&#x27;ann_dir/val&#x27;</span>),</span><br><span class="line">        pipeline=[</span><br><span class="line">            <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;LoadImageFromFile&#x27;</span>),</span><br><span class="line">            <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;Resize&#x27;</span>, scale=(<span class="number">2048</span>, <span class="number">1024</span>), keep_ratio=<span class="literal">True</span>),</span><br><span class="line">            <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;LoadAnnotations&#x27;</span>),</span><br><span class="line">            <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;PackSegInputs&#x27;</span>)</span><br><span class="line">        ]))</span><br><span class="line">test_dataloader = <span class="built_in">dict</span>(</span><br><span class="line">    batch_size=<span class="number">1</span>,</span><br><span class="line">    num_workers=<span class="number">4</span>,</span><br><span class="line">    persistent_workers=<span class="literal">True</span>,</span><br><span class="line">    sampler=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;DefaultSampler&#x27;</span>, shuffle=<span class="literal">False</span>),</span><br><span class="line">    dataset=<span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&#x27;DubaiDataset&#x27;</span>,</span><br><span class="line">        data_root=<span class="string">&#x27;watermelon/Watermelon87_Semantic_Seg_Mask/&#x27;</span>,</span><br><span class="line">        data_prefix=<span class="built_in">dict</span>(img_path=<span class="string">&#x27;img_dir/val&#x27;</span>, seg_map_path=<span class="string">&#x27;ann_dir/val&#x27;</span>),</span><br><span class="line">        pipeline=[</span><br><span class="line">            <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;LoadImageFromFile&#x27;</span>),</span><br><span class="line">            <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;Resize&#x27;</span>, scale=(<span class="number">2048</span>, <span class="number">1024</span>), keep_ratio=<span class="literal">True</span>),</span><br><span class="line">            <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;LoadAnnotations&#x27;</span>),</span><br><span class="line">            <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;PackSegInputs&#x27;</span>)</span><br><span class="line">        ]))</span><br><span class="line">val_evaluator = <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;IoUMetric&#x27;</span>, iou_metrics=[<span class="string">&#x27;mIoU&#x27;</span>])</span><br><span class="line">test_evaluator = <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;IoUMetric&#x27;</span>, iou_metrics=[<span class="string">&#x27;mIoU&#x27;</span>])</span><br><span class="line">default_scope = <span class="string">&#x27;mmseg&#x27;</span></span><br><span class="line">env_cfg = <span class="built_in">dict</span>(</span><br><span class="line">    cudnn_benchmark=<span class="literal">True</span>,</span><br><span class="line">    mp_cfg=<span class="built_in">dict</span>(mp_start_method=<span class="string">&#x27;fork&#x27;</span>, opencv_num_threads=<span class="number">0</span>),</span><br><span class="line">    dist_cfg=<span class="built_in">dict</span>(backend=<span class="string">&#x27;nccl&#x27;</span>))</span><br><span class="line">vis_backends = [<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;LocalVisBackend&#x27;</span>)]</span><br><span class="line">visualizer = <span class="built_in">dict</span>(</span><br><span class="line">    <span class="built_in">type</span>=<span class="string">&#x27;SegLocalVisualizer&#x27;</span>,</span><br><span class="line">    vis_backends=[<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;LocalVisBackend&#x27;</span>)],</span><br><span class="line">    name=<span class="string">&#x27;visualizer&#x27;</span>)</span><br><span class="line">log_processor = <span class="built_in">dict</span>(by_epoch=<span class="literal">False</span>)</span><br><span class="line">log_level = <span class="string">&#x27;INFO&#x27;</span></span><br><span class="line">load_from = <span class="literal">None</span></span><br><span class="line">resume = <span class="literal">False</span></span><br><span class="line">tta_model = <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;SegTTAModel&#x27;</span>)</span><br><span class="line">optimizer = <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;SGD&#x27;</span>, lr=<span class="number">0.01</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">0.0005</span>)</span><br><span class="line">optim_wrapper = <span class="built_in">dict</span>(</span><br><span class="line">    <span class="built_in">type</span>=<span class="string">&#x27;OptimWrapper&#x27;</span>,</span><br><span class="line">    optimizer=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;SGD&#x27;</span>, lr=<span class="number">0.01</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">0.0005</span>),</span><br><span class="line">    clip_grad=<span class="literal">None</span>)</span><br><span class="line">param_scheduler = [</span><br><span class="line">    <span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&#x27;PolyLR&#x27;</span>,</span><br><span class="line">        eta_min=<span class="number">0.0001</span>,</span><br><span class="line">        power=<span class="number">0.9</span>,</span><br><span class="line">        begin=<span class="number">0</span>,</span><br><span class="line">        end=<span class="number">40000</span>,</span><br><span class="line">        by_epoch=<span class="literal">False</span>)</span><br><span class="line">]</span><br><span class="line">train_cfg = <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;IterBasedTrainLoop&#x27;</span>, max_iters=<span class="number">3000</span>, val_interval=<span class="number">400</span>)</span><br><span class="line">val_cfg = <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;ValLoop&#x27;</span>)</span><br><span class="line">test_cfg = <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;TestLoop&#x27;</span>)</span><br><span class="line">default_hooks = <span class="built_in">dict</span>(</span><br><span class="line">    timer=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;IterTimerHook&#x27;</span>),</span><br><span class="line">    logger=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;LoggerHook&#x27;</span>, interval=<span class="number">100</span>, log_metric_by_epoch=<span class="literal">False</span>),</span><br><span class="line">    param_scheduler=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;ParamSchedulerHook&#x27;</span>),</span><br><span class="line">    checkpoint=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;CheckpointHook&#x27;</span>, by_epoch=<span class="literal">False</span>, interval=<span class="number">1500</span>),</span><br><span class="line">    sampler_seed=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;DistSamplerSeedHook&#x27;</span>),</span><br><span class="line">    visualization=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;SegVisualizationHook&#x27;</span>))</span><br><span class="line">work_dir = <span class="string">&#x27;./work_dirs/watermelon&#x27;</span></span><br><span class="line">randomness = <span class="built_in">dict</span>(seed=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要是参考子豪兄的代码</p><p><a href="https://github.com/TommyZihao/MMSegmentation_Tutorials.git">https://github.com/TommyZihao/MMSegmentation_Tutorials.git</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图像分割简介&quot;&gt;&lt;a href=&quot;#图像分割简介&quot; class=&quot;headerlink&quot; title=&quot;图像分割简介&quot;&gt;&lt;/a&gt;图像分割简介&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://fastly.jsdelivr.net/gh/weijia99/blog</summary>
      
    
    
    
    
    <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
    <category term="segmentation" scheme="http://yoursite.com/tags/segmentation/"/>
    
  </entry>
  
  <entry>
    <title>mmdet代码实战</title>
    <link href="http://yoursite.com/2023/06/10/mmdet%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2023/06/10/mmdet%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/</id>
    <published>2023-06-10T09:01:45.000Z</published>
    <updated>2023-06-10T09:11:45.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MMDetection代码实战"><a href="#MMDetection代码实战" class="headerlink" title="MMDetection代码实战"></a>MMDetection代码实战</h1><p>这一届主要讲解了，如何构建cfg，如何在目标检测上设置自己的配置文件。主要的思维导图如下</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/1686387759691MMDetection%E4%BB%A3%E7%A0%81.png"></p><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>直接跳过</p><h2 id="2-设置配置文件"><a href="#2-设置配置文件" class="headerlink" title="2.设置配置文件"></a>2.设置配置文件</h2><p>我们首先设置metainfo，因为只有一个猫类，所以我们只写猫，还有类别是1，那么head头输出就是1，然后设置dataset，首先是设置metainfo，然后就是设置json文件，还有iimg的文件，之后就是设置学习率，还有一些保存checkpoint的配置。</p><p>为了验证模型的数据对不对，我们使用自定义代买来进行检查，传入到cfg，之后吧dataset进行可视化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现在是测试cfg对不对的</span></span><br><span class="line"><span class="keyword">from</span> mmdet.registry <span class="keyword">import</span> DATASETS,VISUALIZERS</span><br><span class="line"><span class="keyword">from</span> mmengine.config <span class="keyword">import</span> Config</span><br><span class="line"><span class="keyword">from</span> mmengine.registry <span class="keyword">import</span> init_default_scope</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">cfg = Config.fromfile(<span class="string">&#x27;./rtmdet_tiny_1xb12-40e_balloon.py&#x27;</span>)</span><br><span class="line">init_default_scope(cfg.get(<span class="string">&#x27;default_scope&#x27;</span>,<span class="string">&#x27;mmdet&#x27;</span>))</span><br><span class="line"></span><br><span class="line">dataset = DATASETS.build(cfg.train_dataloader.dataset)</span><br><span class="line">visualizer = VISUALIZERS.build(cfg.visualizer)</span><br><span class="line">visualizer.dataset_meta = dataset.metainfo</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">16</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    item = dataset[i]</span><br><span class="line">    img = item[<span class="string">&#x27;inputs&#x27;</span>].permute(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>).numpy()</span><br><span class="line">    data_sample = item[<span class="string">&#x27;data_samples&#x27;</span>].numpy()</span><br><span class="line">    gt_instances =data_sample.gt_instances</span><br><span class="line">    img_path = os.path.basename(item[<span class="string">&#x27;data_samples&#x27;</span>].img_path)</span><br><span class="line">    </span><br><span class="line">    gt_bboxes = gt_instances.get(<span class="string">&#x27;bboxes&#x27;</span>,<span class="literal">None</span>)</span><br><span class="line">    gt_instances.bboxes = gt_bboxes.tensor</span><br><span class="line">    data_sample.gt_instances = gt_instances</span><br><span class="line">    </span><br><span class="line">    visualizer.add_datasample(</span><br><span class="line">        os.path.basename(img_path),</span><br><span class="line">        img,</span><br><span class="line">        data_sample,</span><br><span class="line">        draw_pred=<span class="literal">False</span>,</span><br><span class="line">        show = <span class="literal">False</span>,</span><br><span class="line">    )</span><br><span class="line">    drawed_image = visualizer.get_image()</span><br><span class="line">    </span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">4</span>,i+<span class="number">1</span>)</span><br><span class="line">    plt.imshow(drawed_image[...,[<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]])    </span><br><span class="line">    plt.title(img_path)</span><br><span class="line">    plt.xticks([])</span><br><span class="line">    plt.yticks([])</span><br></pre></td></tr></table></figure><p>之后就是训练阶段，使用train来进行训练</p><h2 id="3-测试与分析"><a href="#3-测试与分析" class="headerlink" title="3.测试与分析"></a>3.测试与分析</h2><p>测试与之前一样，使用test来测，使用–show dir可以可视化。之后就是对图像进行特征化，这个时候需要借助mmyolo的功能，因此需要下载mmyolo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python demo/featmap_vis_demo.py 5555705118_3390d70abe_b.jpg ../mmdetection/rtmdet_tiny_1xb12-40e_balloon.py ../mmdetection/work_dirs/rtmdet_tiny_1xb12-40e_balloon/best_coco_bbox_mAP_epoch_80.pth --channel-reduction squeeze_mean --target-layers neck</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python demo/boxam_vis_demo.py 5555705118_3390d70abe_b.jpg ../mmdetection/rtmdet_tiny_1xb12-40e_balloon.py ../mmdetection/work_dirs/rtmdet_tiny_1xb12-40e_balloon/best_coco_bbox_mAP_epoch_80.pth --target-layer neck.out_convs[2]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MMDetection代码实战&quot;&gt;&lt;a href=&quot;#MMDetection代码实战&quot; class=&quot;headerlink&quot; title=&quot;MMDetection代码实战&quot;&gt;&lt;/a&gt;MMDetection代码实战&lt;/h1&gt;&lt;p&gt;这一届主要讲解了，如何构建cfg，如</summary>
      
    
    
    
    
    <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
    <category term="detection" scheme="http://yoursite.com/tags/detection/"/>
    
  </entry>
  
  <entry>
    <title>mmpretrain实战</title>
    <link href="http://yoursite.com/2023/06/07/mmpretrain%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2023/06/07/mmpretrain%E5%AE%9E%E6%88%98/</id>
    <published>2023-06-07T08:04:01.000Z</published>
    <updated>2023-06-07T09:11:31.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mmpretrain实战"><a href="#mmpretrain实战" class="headerlink" title="mmpretrain实战"></a>mmpretrain实战</h1><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/1686128130571mmpretrain.png"></p><p>主要讲解了安装,还有使用教程.安装教程直接参考官网.下面讲解一下mmpretrain使用</p><h2 id="实战教程"><a href="#实战教程" class="headerlink" title="实战教程"></a>实战教程</h2><h3 id="2-1简单使用"><a href="#2-1简单使用" class="headerlink" title="2.1简单使用"></a>2.1简单使用</h3><p>我们可以直接从定义好的模型来进行推理,首先list_model可以列出所有的分类,然后通过关键字可以识别出来resnet所有的模型,然后我们通过get_model,输入关键字就可以得到模型,之后,我们通过使用inference来进行传入模型,还有ckp,还有图形就可以直接来进行推理.</p><h3 id="2-2自定义使用"><a href="#2-2自定义使用" class="headerlink" title="2.2自定义使用"></a>2.2自定义使用</h3><p>首先整个mmlab都是通过使用cfg来进行配置的,所以我们如果要进行自己的resnet50配置,我们可以从官网的cfg来进行参考.</p><p>首先是模型,模型分为backbone骨干网络,head就是输出头,使用neck来进行连接网络.然后最后的loss,实在模型里就定义号了,使用的是topk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># model settings</span></span><br><span class="line">model = <span class="built_in">dict</span>(</span><br><span class="line">    <span class="built_in">type</span>=<span class="string">&#x27;ImageClassifier&#x27;</span>,</span><br><span class="line">    backbone=<span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&#x27;ResNet&#x27;</span>,</span><br><span class="line">        depth=<span class="number">50</span>,</span><br><span class="line">        num_stages=<span class="number">4</span>,</span><br><span class="line">        out_indices=(<span class="number">3</span>, ),</span><br><span class="line">        style=<span class="string">&#x27;pytorch&#x27;</span>),</span><br><span class="line">    neck=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;GlobalAveragePooling&#x27;</span>),</span><br><span class="line">    head=<span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&#x27;LinearClsHead&#x27;</span>,</span><br><span class="line">        num_classes=<span class="number">33</span>,</span><br><span class="line">        in_channels=<span class="number">2048</span>,</span><br><span class="line">        loss=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;CrossEntropyLoss&#x27;</span>, loss_weight=<span class="number">1.0</span>),</span><br><span class="line">        topk=(<span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line">    ),</span><br><span class="line">    init_cfg = <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;Pretrained&#x27;</span>,checkpoint = <span class="string">&#x27;https://download.openmmlab.com/mmclassification/v0/resnet/resnet50_8xb32_in1k_20210831-ea4938fc.pth&#x27;</span>)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>之后就是dataset的配置,我们使用的type是自定义的type,设置输入的train,还有val路径,之后设置val的评估指标,使用top1.</p><p>下面就是训练时候的配置,循环次数,还有优化器</p><p>最后就是训练时候的配置,自动保存权重最高的,还有值保留最近5个文件</p><p>剩下的地方可以设置args参数 例如load_file还有work-dir</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work_dir = <span class="string">&#x27;./exp&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkpoint=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;CheckpointHook&#x27;</span>, interval=<span class="number">1</span>,max_keep_ckpts=<span class="number">5</span>,save_best=<span class="string">&#x27;auto&#x27;</span>),</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mmpretrain实战&quot;&gt;&lt;a href=&quot;#mmpretrain实战&quot; class=&quot;headerlink&quot; title=&quot;mmpretrain实战&quot;&gt;&lt;/a&gt;mmpretrain实战&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://fastly.jsdel</summary>
      
    
    
    
    
    <category term="mmlab" scheme="http://yoursite.com/tags/mmlab/"/>
    
    <category term="image classification" scheme="http://yoursite.com/tags/image-classification/"/>
    
  </entry>
  
  <entry>
    <title>MMPose实战</title>
    <link href="http://yoursite.com/2023/06/03/MMPose%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2023/06/03/MMPose%E5%AE%9E%E6%88%98/</id>
    <published>2023-06-03T11:33:33.000Z</published>
    <updated>2023-06-03T12:30:29.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-mmpose实战"><a href="#1-mmpose实战" class="headerlink" title="1.mmpose实战"></a>1.mmpose实战</h1><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/1685794454339MMPose%E5%AE%9E%E6%88%98.png"></p><p>主要包括安装，mmdet实战，mmpose实战等三部分</p><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>安装方法，可以直接去看官网教程，主要是是首先下载pytorch，之后下载mmcv，使用mim来进行安装。然后在github下载源码，使用源码进行安装。难点包括网速原因（ladder或者是搜索加速网站）</p><p>建议新装一个环境，pytorch和mmcv要一一对应。我之前是2.0.安装之后无法训练，是版本原因。所以重装了一个conda环境。</p><h2 id="2-mmdet"><a href="#2-mmdet" class="headerlink" title="2.mmdet"></a>2.mmdet</h2><p>mmlab代码的整体训练流程</p><ol><li>数据集同意处理程coco的格式，使用lableme</li><li>设置cfg配置文件，这个歌文件包括模型，优化器，超参数，数据集还有pipeline，和权重</li><li>使用train来训练上述cfg或者是分布式训练使用bash脚本bash dist——train模型cfg</li><li>之后就是使用test来进行验证文件 test 模型 +pth进行验证</li><li>之后就是预测，一般使用命令行得到结果</li></ol><h2 id="3-mmpose"><a href="#3-mmpose" class="headerlink" title="3.mmpose"></a>3.mmpose</h2><p>与mmdet同理，还是多个步骤</p><p>最后一步是集合mmdet的权重+mmpose的权重来指定向下来进行预测</p><h2 id="4-作业"><a href="#4-作业" class="headerlink" title="4.作业"></a>4.作业</h2><p>关于中医耳朵</p><ol><li>首先是数据集下载，使用bypy这个python包进行下载</li><li>使用mmdet的训练流程来进行训练</li><li>使用mmposexunlliucheng进行训练</li><li>使用test来进行计算准确率</li><li>集合上述两个一起进行结果预测</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-mmpose实战&quot;&gt;&lt;a href=&quot;#1-mmpose实战&quot; class=&quot;headerlink&quot; title=&quot;1.mmpose实战&quot;&gt;&lt;/a&gt;1.mmpose实战&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://fastly.jsdelivr.net/</summary>
      
    
    
    
    
    <category term="mmlab" scheme="http://yoursite.com/tags/mmlab/"/>
    
  </entry>
  
  <entry>
    <title>人体关键点检测</title>
    <link href="http://yoursite.com/2023/06/02/%E4%BA%BA%E4%BD%93%E5%85%B3%E9%94%AE%E7%82%B9%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2023/06/02/%E4%BA%BA%E4%BD%93%E5%85%B3%E9%94%AE%E7%82%B9%E6%A3%80%E6%B5%8B/</id>
    <published>2023-06-02T13:28:46.000Z</published>
    <updated>2023-06-02T13:49:41.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人体关键点检测"><a href="#人体关键点检测" class="headerlink" title="人体关键点检测"></a>人体关键点检测</h1><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/1685712470039%E4%BA%BA%E4%BD%93%E5%85%B3%E9%94%AE%E6%A3%80%E6%B5%8B.png"></p><p>今天，这一节课的内容主要可以看成，人体关键点检测的综述。包括2d，3d人天姿态检测。主要介绍上述的算法，还有包括常用评价指标。</p><h2 id="1-检测思路"><a href="#1-检测思路" class="headerlink" title="1.检测思路"></a>1.检测思路</h2><h3 id="1-1自顶向下"><a href="#1-1自顶向下" class="headerlink" title="1.1自顶向下"></a>1.1自顶向下</h3><p>思路就是首先识别出人，之后在进行关键点识别，这样的缺点就是整体精度收到检测器算法，还有一个就是计算量太大了。</p><h3 id="1-2自底向上"><a href="#1-2自底向上" class="headerlink" title="1.2自底向上"></a>1.2自底向上</h3><p>先识别关键点，之后再次识别人类。计算量就少很多。</p><h3 id="1-3基于回归的"><a href="#1-3基于回归的" class="headerlink" title="1.3基于回归的"></a>1.3基于回归的</h3><p>根据图像直接回归出来坐标</p><h3 id="1-4基于热力图"><a href="#1-4基于热力图" class="headerlink" title="1.4基于热力图"></a>1.4基于热力图</h3><p>热力图是输出与原图比例一样的图像，但是每一个通道里面，关键点的坐标是1.预测出关键点既可以进行绘制。同时关键点一般使用max，或者是进行求期望获得</p><h2 id="2-2d检测"><a href="#2-2d检测" class="headerlink" title="2.2d检测"></a>2.2d检测</h2><h3 id="2-1自顶向下"><a href="#2-1自顶向下" class="headerlink" title="2.1自顶向下"></a>2.1自顶向下</h3><p>回归：包括DeepPOse（直接输出坐标），级联DeepPose，RLE（借鉴Flow思想，把分布运用多个高斯分布来进行拟合）</p><p>热力图：HourGlass（跳连接，是对称的自己），baseline（resnet+反卷积），HRNET（高分辨率，自己生成高分辨率+低分辨率的）</p><h3 id="2-2自底向上"><a href="#2-2自底向上" class="headerlink" title="2.2自底向上"></a>2.2自底向上</h3><p>openPose：先进行预测关键点，然后计算亲和度，高得就是同一个人</p><h3 id="2-3单阶段"><a href="#2-3单阶段" class="headerlink" title="2.3单阶段"></a>2.3单阶段</h3><p>一个阶段就可以结算出来结果。</p><p>包括：SPM（回归位置+方向向量），层级SPM（分部位来进行回归）</p><h3 id="2-4TRansform"><a href="#2-4TRansform" class="headerlink" title="2.4TRansform"></a>2.4TRansform</h3><p>PPTR：都是用一套DeRT个骨干网络，先框选人，之后关键点预测的时候把transform里面的q换成关键点）</p><p>TokenPose：cnn得到特征信息，之后在与pose信息一起add，然后放入到transform进行炼丹</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="3-3d检测"><a href="#3-3d检测" class="headerlink" title="3.3d检测"></a>3.3d检测</h2><p>难点就是如何从2位换源到3维</p><p>解决思路：</p><ol><li>直接2d还原生成3d   coarse</li><li>利用视频，首先生成单帧的2d ，之后2d再次生3d  cideoPOse</li><li>利用多个视角   voxelPose</li></ol><h2 id="4-评价指标"><a href="#4-评价指标" class="headerlink" title="4.评价指标"></a>4.评价指标</h2><p>PCP：准确率</p><p>PDJ：在一定比例</p><p>PCK：在阈值范围里</p><p>oks：计算公式</p><h2 id="5-DensePOse"><a href="#5-DensePOse" class="headerlink" title="5.DensePOse"></a>5.DensePOse</h2><p>把人体划分成24块，每一个部分256*256，有14个关键点</p><p>主要算法包括：rcnn+dense reg，SMPL，SMPLisy和HMR</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;人体关键点检测&quot;&gt;&lt;a href=&quot;#人体关键点检测&quot; class=&quot;headerlink&quot; title=&quot;人体关键点检测&quot;&gt;&lt;/a&gt;人体关键点检测&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://fastly.jsdelivr.net/gh/weijia99/</summary>
      
    
    
    
    
    <category term="MMPose" scheme="http://yoursite.com/tags/MMPose/"/>
    
    <category term="cv" scheme="http://yoursite.com/tags/cv/"/>
    
  </entry>
  
  <entry>
    <title>mmlab简介</title>
    <link href="http://yoursite.com/2023/06/01/mmlab%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2023/06/01/mmlab%E7%AE%80%E4%BB%8B/</id>
    <published>2023-06-01T11:50:44.000Z</published>
    <updated>2023-06-01T12:01:14.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mmlab简介"><a href="#mmlab简介" class="headerlink" title="mmlab简介"></a>mmlab简介</h1><p>mmlab算法库是mmlab实验室在github上开源的一系列算法。由港中文的汤晓鸥教授建立的。本节主要介绍mmlab算法库相关简介</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16856202144211685620214365.png"></p><p>思维导图如上。主要包括目标检测，3d点云，图像分割，图像识别，视频理解，还有AIGC等相关应用。最后还有部署的算法库mmdeploy。目前几乎涵盖了计算机视觉相关的所有领域。在学术界还有工业界都被广泛的使用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mmlab简介&quot;&gt;&lt;a href=&quot;#mmlab简介&quot; class=&quot;headerlink&quot; title=&quot;mmlab简介&quot;&gt;&lt;/a&gt;mmlab简介&lt;/h1&gt;&lt;p&gt;mmlab算法库是mmlab实验室在github上开源的一系列算法。由港中文的汤晓鸥教授建立的。本节</summary>
      
    
    
    
    
    <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
    <category term="mmlab" scheme="http://yoursite.com/tags/mmlab/"/>
    
  </entry>
  
  <entry>
    <title>deepin安装docker和pytorch</title>
    <link href="http://yoursite.com/2023/06/01/deepin%E5%AE%89%E8%A3%85docker/"/>
    <id>http://yoursite.com/2023/06/01/deepin%E5%AE%89%E8%A3%85docker/</id>
    <published>2023-06-01T09:28:58.000Z</published>
    <updated>2023-06-01T10:18:44.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deepin安装docker和pytorch"><a href="#deepin安装docker和pytorch" class="headerlink" title="deepin安装docker和pytorch"></a>deepin安装docker和pytorch</h1><p>总体的流程图大致如下，首先是安装linux，这个直接跳过，接下来就是安装docker，之后，安装docker之后，安装pytorch image，然后使用vscode来进行深度学习开发。这样。不需要每次都要进行配置环境，直接使用这个镜像，构建多个容器，可以互不影响。</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/1685611681945deepin%E5%AE%89%E8%A3%85docker.png"></p><h2 id="1-docker相关设置"><a href="#1-docker相关设置" class="headerlink" title="1.docker相关设置"></a>1.docker相关设置</h2><h3 id="1-docker安装"><a href="#1-docker安装" class="headerlink" title="1.docker安装"></a>1.docker安装</h3><blockquote><p>前情提示，由于dockerhub，最近几天已经被gfw给404了，建议首先安装好了就来进行更换镜像。</p></blockquote><p>由于deepin是Debian的分支，因此我们选择Debian的安装命令，详细教程参考<a href="https://www.runoob.com/docker/debian-docker-install.html">Debian Docker 安装 | 菜鸟教程 (runoob.com)</a></p><p>主要命令就是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure><p><strong>注意，安装完成之后，请务必换源</strong></p><p><a href="https://www.runoob.com/docker/docker-mirror-acceleration.html">Docker 镜像加速 | 菜鸟教程 (runoob.com)</a></p><p>主要是在下面进行在  &#x2F;etc&#x2F;docker&#x2F;daemon.json 下面增加源，这个地方也可以修改，image默认下载的地方</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl daemon-reload</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl restart docker</span></span><br></pre></td></tr></table></figure><p>之后执行重启。</p><h3 id="1-2加入到docker用户组"><a href="#1-2加入到docker用户组" class="headerlink" title="1.2加入到docker用户组"></a>1.2加入到docker用户组</h3><p>之后，因为使用docker默认是需要特权docker组里的成员才能使用，所以我们需要把当前用户加入到docker组里面</p><p>主要参考的是这个博文，首先查看是不是已经有了docker用户组，已经有了我们直接进行加入当前用户，然后进行重启。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /etc/group | grep docker</span><br><span class="line"></span><br><span class="line">sudo usermod -aG docker 要添加的user</span><br><span class="line"></span><br><span class="line">sudo chmod a+rw /var/run/docker.sock</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3附加内容（配置自己的images）"><a href="#1-3附加内容（配置自己的images）" class="headerlink" title="1.3附加内容（配置自己的images）"></a>1.3附加内容（配置自己的images）</h3><p>每次换到一个新电脑的时候，最麻烦的事情就是进行环境配置，下载所需要的安装软件，一个个的执行。现在有了docker，我们可以直接去dockerhub你输入命令来得到所需要的环境。例如java开发的环境（mysql，MongoDB和redis等）。</p><p>参考下面的教程：</p><p><a href="https://blog.chennn.com/docker-build-java-development-environment/">Docker搭建Java开发环境 (chennn.com)</a></p><p>现在我要构建一个属于自己的开发环境，例如只需要java和maven，那么我们改如何得到呢。现在，这里我们需要使用的是dockerfile这个文件，通过这个文件看我们可以构建出来哦自己的images。</p><p>。dockerfile语法如下 ：<a href="https://www.runoob.com/docker/docker-dockerfile.html">Docker Dockerfile | 菜鸟教程 (runoob.com)</a></p><p>首先需要定义一个from，这个就相当于原始文件，我们首先定义from openjdk，来作为自己的原始image，之后根据自己的需要来进行修改。之后，我们需要使用maven，这里我们选择编译安装。分为下面几步。</p><ol><li>下载maven源码</li><li>进行解压</li><li>然后进行移动到local目录里面</li><li>设置环境变量</li></ol><p>我们使用run 来执行每一个shell 命令，</p><p>之后就是设置环境变量，因为gfw的原因，有时候，我们需要使用代理，还有吧上面的源码放入到env上面，所以需要使用或者其他端口隐射到envv来进行设置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8</span><br><span class="line"></span><br><span class="line">RUN wget https://dlcdn.apache.org/maven/maven-3/3.8.6/binaries/apache-maven-3.8.6-bin.zip</span><br><span class="line">RUN unzip apache-maven-3.8.6-bin.zip</span><br><span class="line">RUN mv apache-maven-3.8.6 /usr/local/maven</span><br><span class="line">RUN rm -rf apache-maven-3.8.6-bin.zip</span><br><span class="line"></span><br><span class="line">ENV MAVEN_HOME=/usr/local/maven</span><br><span class="line">ENV PATH=$MAVEN_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>这样，我们就构建好了自己的开发包。</p><p>上面的代码还可以精简，我们只需要使用一个run ，剩下的全部用&amp;&amp;连接shell命令就可以</p><p>然后 我们进行构建，使用这个dockerfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t java-env:8 .</span><br></pre></td></tr></table></figure><p>最后我们就是启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name java-base-env java-env:8</span><br></pre></td></tr></table></figure><p>如果需要进入到容器内部，我们可以使用docker exec -it 容器名称</p><hr><blockquote><p>扩展：使用gateway来进行远程开发。我们可以在images里面安装openssherver，然后修改、etc&#x2F;ssh&#x2F;sshd_config里面的允许root登录还有密码登录，之后，设置这个为自动启动。</p></blockquote><p>参考下面这个连接：<a href="https://zhuanlan.zhihu.com/p/80099904">VSCode+Docker: 打造最舒适的深度学习环境 - 知乎 (zhihu.com)</a></p><p>之后，我们在docker启动的时候设置端口映射这个容器，吧9001或者其他端口映射到22，然后使用gateway进行远程连接，输入端口9001，账户密码，就可以进行开发了。</p><h2 id="2-deepin配置pytorch镜像"><a href="#2-deepin配置pytorch镜像" class="headerlink" title="2.deepin配置pytorch镜像"></a>2.deepin配置pytorch镜像</h2><h3 id="2-1deepin的设置"><a href="#2-1deepin的设置" class="headerlink" title="2.1deepin的设置"></a>2.1deepin的设置</h3><p>首先，我们需要对deepin进行设置，默认没有安装cuda，我们直接使用deepin官方的命令，安装cuda-toolkit，还有nvidia-smi进行apt安装。之后就完成了。有些版本是需屏蔽自己显卡，然后才能安装，笔者目前没有与到，安装比较简单。命令都在开始的思维导图上面。</p><h3 id="2-2（可选）配置proxychains"><a href="#2-2（可选）配置proxychains" class="headerlink" title="2.2（可选）配置proxychains"></a>2.2（可选）配置proxychains</h3><p>来进行国内访问加速，直接apt 进行安装就行，然后修改配置文件 &#x2F;etc&#x2F;proxychains.conf。</p><p>参考这篇文章 <a href="https://zhuanlan.zhihu.com/p/166375631">linux命令行代理神器-proxychains - 知乎 (zhihu.com)</a></p><p>在.bashrc里面设置alias pr &#x3D;proxychains，进行缩短单词</p><h3 id="2-3安装pytorch"><a href="#2-3安装pytorch" class="headerlink" title="2.3安装pytorch"></a>2.3安装pytorch</h3><p>直接根据沐神的github推荐的image来使用</p><p><a href="https://github.com/mli/transformers-benchmarks">mli&#x2F;transformers-benchmarks: real Transformer TeraFLOPS on various GPUs (github.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --gpus all -it --rm -p 8888:8888 -v ~:/workspace \</span><br><span class="line">--ipc=host --ulimit memlock=-1 --ulimit stack=67108864 \</span><br><span class="line">nvcr.io/nvidia/pytorch:22.07-py3</span><br></pre></td></tr></table></figure><p>这样我们直接进入到容器里面了。我们使用screen 吧这个容器放入到后台执行。</p><p>这样就安装完成。同事还把我们的home目录隐射到workdir里面，我们可以访问到workdir的文件来找到服务器的文件</p><h2 id="3-vscode-x2F-idea-x2F-pycharm的使用"><a href="#3-vscode-x2F-idea-x2F-pycharm的使用" class="headerlink" title="3.vscode&#x2F;idea&#x2F;pycharm的使用"></a>3.vscode&#x2F;idea&#x2F;pycharm的使用</h2><h3 id="3-1vscode进行配置"><a href="#3-1vscode进行配置" class="headerlink" title="3.1vscode进行配置"></a>3.1vscode进行配置</h3><p>我们首先进去插件商店，安装dev dontainer。之后使用远程连接到docker宿主机上 </p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16856142119451685614211207.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16856142399431685614239438.png"></p><p>在宿主机上面选择开发容器，我们就可以进入到刚刚的pytorch容器里面</p><h3 id="3-2idea的设置"><a href="#3-2idea的设置" class="headerlink" title="3.2idea的设置"></a>3.2idea的设置</h3><p>这里直接使用gateway来进行设置，选择新建一个ssh，我们输入之前映射到22的端口，还有账号密码（详情加1.3），然后进行连接，之后选择后端版本的idea，这样idea后端就部署到容器里面。之后，我们就可以进行远程及开发</p><h3 id="3-2pycharm设置"><a href="#3-2pycharm设置" class="headerlink" title="3.2pycharm设置"></a>3.2pycharm设置</h3><p>对于pycharm，不需要上述那么复杂，我们直接进行远程开发，ssh到宿主机器的22端口，然后我们选择解释器interpret为docker里面的容器，就可以直接执行python代码，来进行调试开发了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;deepin安装docker和pytorch&quot;&gt;&lt;a href=&quot;#deepin安装docker和pytorch&quot; class=&quot;headerlink&quot; title=&quot;deepin安装docker和pytorch&quot;&gt;&lt;/a&gt;deepin安装docker和pytor</summary>
      
    
    
    
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
    <category term="torch" scheme="http://yoursite.com/tags/torch/"/>
    
    <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>mysql学习</title>
    <link href="http://yoursite.com/2023/04/19/mysql%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2023/04/19/mysql%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-04-19T11:25:58.000Z</published>
    <updated>2023-04-24T09:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL是怎样运行的"><a href="#MySQL是怎样运行的" class="headerlink" title="MySQL是怎样运行的"></a>MySQL是怎样运行的</h1><h2 id="0-语法篇"><a href="#0-语法篇" class="headerlink" title="0.语法篇"></a>0.语法篇</h2><p>常用的关键字:</p><ol><li>distinct,select distinct* from来进行去重</li><li>排序order by id des(下降</li><li>in(a,b)&#x3D;&#x3D;a or b</li><li>查询的时候,列可以直接进行操作,如果我们要求对(欸一个分数+10)&#x3D;&#x3D;select score+10 from</li><li>null无论什么操作还是null</li><li>字符串函数啊,left,right,substr都是进行截取</li><li>count(列名)就是来进行统计由多少个</li><li>分组查询,这个相当于多个目录(省,市,县来进行分段)使用group by province</li><li>例如求语文,英语,数学的平均分,写三个函数太累,select avg(subject) from group by subject</li><li>分组之后先接着进行过滤,例如,只想统计分数平均值大于60,后面市having by(不能用where,因为这是计算后的结果)</li><li>多表查询,外连接,分为做连接,还有右连接(核心就是完整的保留那一边),内连接就是只有都相等才进行保留</li><li>子查询,select * where id&#x3D;(查询语句),根据查询语句返回的结果再次进行查询</li><li>并集查询,使用union查询多个,会过滤重复的结果</li><li>视图view,相当于自己预先定义函数,然后进行了查询的结果存放的地方,再视图里操作页会影响原始表</li><li>储存程序,相当于函数,可以设定变量,@a来进行对变量a来进行赋值,会有返回值</li><li>储存过程,没有返回值,直接进行操作</li><li>下一个就是游标,相当于list</li><li>trigger触发器,就是进行检查,可以自定义每次增加删除,检查分数是不是小于100</li></ol><h2 id="1-前言篇"><a href="#1-前言篇" class="headerlink" title="1.前言篇"></a>1.前言篇</h2><blockquote><p>执行一条sql,都发生了什么</p></blockquote><p>主要包含一下流程,首先是连接启,之后查询缓存,缓存失败,进行语法分析,解析阿来就是对语法进行优化,然后才是执行,之后返回结果</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p><ol><li>server负责api的调用,分析还有执行sql,常用的存储过程还有触发器,视图都在这一层</li><li>存储层负责的是数据的存放还读取,数据库的innodb索引都在这一层</li></ol><h3 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1.连接器"></a>1.连接器</h3><p>负责身份认证还有权限相关的(登录mysql的时候)</p><p>show processlist查看当前的连接数目,空闲时间超过wait_time会哦被断开,最大的连接再max_connection上面,</p><h3 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2.查询缓存"></a>2.查询缓存</h3><p>mysql8.0删除这个功能了因为对于更新比较频繁的表,这个缓存基本就没有用,更新一次就删除缓存一次.</p><h3 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3.分析器"></a>3.分析器</h3><p>作用就是对语句进行分析,看这条语句要干什么.主要包括语法分析还有此法分析,语法分析就是看你是不是输入错误的单词,此法分析就是提取关键词</p><h3 id="4-执行器"><a href="#4-执行器" class="headerlink" title="4.执行器"></a>4.执行器</h3><p>执行sql查询语句,首先第一步就是看你有没有权限来查这个</p><ol><li>预处理器,检查是不是含有这个字段,把*替换成全表</li><li>优化器主要确定查询方案,因为一个数据库可能有多条索引,查找时间最小的</li><li>执行器执行,主键索引查询,全表查询,索引下推(建立二级索引agename,这个索引,直接根据开闭原则来进行判断)</li></ol><h2 id="2-mysql的一行记录是怎么存放的"><a href="#2-mysql的一行记录是怎么存放的" class="headerlink" title="2.mysql的一行记录是怎么存放的"></a>2.mysql的一行记录是怎么存放的</h2><blockquote><p>可以看到，共有三个文件，这三个文件分别代表着：</p><ul><li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li><li>t_order.frm ，t_order 的<strong>表结构</strong>会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li><li>t_order.ibd，t_order 的<strong>表数据</strong>会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。</li></ul><p>好了，现在我们知道了一张数据库表的数据是保存在「 表名字.ibd 」的文件里的，这个文件也称为独占表空间文件</p></blockquote><p>一张表的结构再frm里面,数据再ibd里面</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p><p>一个表空间可以由多个段组成,段是可以由多个不连续的区构成,区是由连续的页构成,页是由连续的记录进行组成</p><p><strong>页:</strong></p><p>​一个页大小是16kb,mysql的读写都是以页为单位,长江的页还有数据页面,undo页面,还有redo</p><p>区:</p><p>一个区的大小是1MB,那么就有64个页面,为了让相邻的两个页面的物理位置相邻,划分的一个1MB物理空间,这样就是顺序io</p><blockquote><p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了</strong>。</p><h4 id><a href="#" class="headerlink" title></a></h4></blockquote><p>段:</p><p>段是由多个区间构成的,一般分为索引段</p><p>​</p><ul><li>索引段：存放 B + 树的非叶子节点的区的集合；</li><li>数据段：存放 B + 树的叶子节点的区的集合；</li><li>回滚段：存放的是回滚数据的区的集合，之前讲<a href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离 (opens new window)</a>的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。</li></ul><p>索引都在非叶子节点上面,数据都在叶子上面,还有回滚数据</p><h2 id="3-索引"><a href="#3-索引" class="headerlink" title="3.索引"></a>3.索引</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%8F%90%E7%BA%B2.png" alt="img"></p><h3 id="3-1索引简介"><a href="#3-1索引简介" class="headerlink" title="3.1索引简介"></a>3.1索引简介</h3><p>索引是一种排好序的数据结构,作用相当于数据的目录 </p><p>优缺点:</p><ol><li>减少查询时间</li><li>但是数据增删改的时候会更新索引</li><li>会浪费一定的物理空间</li></ol><h3 id="3-2索引的分类"><a href="#3-2索引的分类" class="headerlink" title="3.2索引的分类"></a>3.2索引的分类</h3><p>数据结构;b+,hash,full-text</p><p>物理结构:主键索引,耳机索引(两个关键字何在一起)</p><p>字段:主键,唯一(unique),普通,前</p><p>数据结构:</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.drawio.png" alt="img"></p><p>主键查询,</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95btree.drawio.png" alt="二级索引 B+Tree"></p><p>最后一层才是数据节点,主键索引的是全部数据,耳机索引知识主键值,然后进行徽标才能得到值</p><blockquote><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul></blockquote><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E5%9B%9E%E8%A1%A8.drawio.png" alt="回表"></p><h3 id="3-3B树与B-树"><a href="#3-3B树与B-树" class="headerlink" title="3.3B树与B+树"></a>3.3B树与B+树</h3><ol><li>B树每个节点都有数据,b+树只有页节点才有数据</li><li>b树的叶节点是单独存在的,但是b+树是用单链表连接到下一个的</li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdgV8QoMTlAsFLK9yrPWQiapWzXLEtpJD3IsGAXyTsJQvXibTAnIYHKkIekK7licSTVftymQZ2gs4kEw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><blockquote><p>因为 <strong>B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助</strong>，比如说我们想知道 12 月 1 日和 12 月 12 日之间的订单，这个时候可以先查找到 12 月 1 日所在的叶子节点，然后利用链表向右遍历，直到找到 12 月12 日的节点，这样就不需要从根节点查询了，进一步节省查询需要的时间</p></blockquote><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推:"></a>索引下推:</h2><blockquote><ul><li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li><li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li></ul></blockquote><p>就是说,可以直接用联合索引来进行提权哦判断不符合的数据</p><h3 id="3-4什么时候需要索引"><a href="#3-4什么时候需要索引" class="headerlink" title="3.4什么时候需要索引"></a>3.4什么时候需要索引</h3><ol><li>id唯一</li><li>经常使用where,order by,groupby的字段</li></ol><p>不用的情况:不用where的字段,大量重复数据sex</p><h2 id="4-InnoDB引擎"><a href="#4-InnoDB引擎" class="headerlink" title="4.InnoDB引擎"></a>4.InnoDB引擎</h2><blockquote><p>这一章主要是讲MySQL默认引擎，包括基本单位，还有管理的基本单位</p></blockquote><h3 id="4-1简介"><a href="#4-1简介" class="headerlink" title="4.1简介"></a>4.1简介</h3><ol><li>盘与内存使用的是页，一个页大小是16kB</li><li>innoDB存放每一条记录叫做行</li><li>行是由头信息还有数据信息组成</li><li>主要有下面四种格式，compact，redunnat</li><li>首先是compact，（前面得到头信息，记录可变唱的字段，然后从小到大来记录，每一个字段的长度）</li><li>第二个就是记录这一行的null的数量（记录方法是one-hot方法，每一个列都是01表示）</li></ol><p>插入代码块如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alterr table student row_format = compact</span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE.png" alt="img"></p><p>记录的真实数据,包含三个隐藏列,默认idrow,trx表示食物id,是哪一个事务生成的,roll point代表回滚的</p><p><strong>varchar(n) 中 n 最大取值为多少？</strong></p><p>一行记录最大能存储 <strong>65535 字节的数据</strong>，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。</p><p>如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。</p><p>计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL<strong>值列表所占用的字</strong>节数 &#x3D; 65535 - 2 - 1 &#x3D; 65532。</p><p>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;&#x3D; 65535。</p><blockquote><p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p></blockquote><h3 id="4-2INnoDB数据页结构"><a href="#4-2INnoDB数据页结构" class="headerlink" title="4.2INnoDB数据页结构"></a>4.2INnoDB数据页结构</h3><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16819843724461681984371693.png"></p><blockquote><p>这一张主要讲解的是数据页，还有B+树的实现，介绍数据页的结构，包括记录，还有头结构</p></blockquote><ol><li>每一条记录都是存放在user record</li><li>n_owned 记录拥有的小弟</li><li>next记录吓一跳页面</li><li>还有两条虚拟记录，一个是infir+super</li><li>free space是记录空闲空间</li><li>page dir表示这是不是叶子节点</li></ol><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16819844104451681984409840.png">****</p><p>这是一条记录头信息，有包括id，还有拥有的小弟</p><p><strong>头信息：</strong>del——flag，next record吓一跳记录，heap_no相对记录在堆，还有一个type，表示是</p><p>删除记录：并不是在页面实际删除，而是设置一个del标记为1</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16819846234451681984623071.png"></p><blockquote><p>主每一条记录都用于n——cow这个适用于分组的，然后del代表为是不删除，还有相对位置，之后就是下一个记录的位置</p></blockquote><p>然后有两条虚拟记录，一个是最小的，还有一个是最大记录，当相当于虚拟头结点还有虚拟尾结点</p><p>这两个位置是最靠前的一个是0，一个是1，</p><p>page dire：这个作用就是为了把之前的记录进行3-4个一组来进行结合，记录最后一个索引最大的值为slot，n_row代表的是还有几个小弟</p><p>每一个slot代表</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16819850594441681985058988.png"></p><p>每一个slot代表一个地址</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16819852004481681985200031.png"></p><ol><li>一个页面是包含多个记录的</li><li>一个页面要进行分组,最小记录还有最大记录,之后就是数据记录来进行分组</li><li>分组最大的放入slot里面,他记录自己包含的小弟</li></ol><blockquote><p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p></blockquote><p>B+树每一个节点都是数据页</p><blockquote><ul><li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li><li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li><li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li></ul></blockquote><h2 id="5-事务"><a href="#5-事务" class="headerlink" title="5.事务"></a>5.事务</h2><p>事务是逻辑上一组操作,要么执行,要么不执行.实现事务,要遵循4个特性,aicd(原子性,一致性,隔离性,最后就是持久性)一只猩猩,就是操作完成,还是满足约束,隔离性,不会对其他事务进行影响.</p><h3 id="5-1并发事务带来的影响"><a href="#5-1并发事务带来的影响" class="headerlink" title="5.1并发事务带来的影响"></a>5.1并发事务带来的影响</h3><p>会出现,脏读,不可重复,幻读.</p><p>脏读:读取没有提交的值,然后值又进行回滚了</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/10b513008ea35ee880c592a88adcb12f.png" alt="图片"></p><p>不可重复读:</p><p>读取的值被修改,两次读取不一样</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/f5b4f8f0c0adcf044b34c1f300a95abf.png" alt="图片"></p><p>幻读:</p><p>读取了值,结果下一次读取的时候被删除了</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/d19a1019dc35dfe8cfe7fbff8cd97e31.png" alt="图片"></p><p>四种隔离级别:</p><ol><li>未提交读(脏读,幻读,可重复)</li><li>提交读(幻读,可重复)</li><li>可重复读(幻读)</li><li>可串行化</li></ol><p>可重复读很大程度避免了幻读</p><p>并发事务 的控制方法:基于锁还有mvcc(多版本并发控制)乐观</p><p>mvcc:hi一份数据多个版本,可以通过事务id,查找之前的版本</p><blockquote><h3 id="MySQL-的隔离级别是基于锁实现的吗？"><a href="#MySQL-的隔离级别是基于锁实现的吗？" class="headerlink" title="MySQL 的隔离级别是基于锁实现的吗？"></a>MySQL 的隔离级别是基于锁实现的吗？</h3></blockquote><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p><p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><hr><p><strong>对于四种隔离事务的实现方法</strong></p><ol><li>读未提交:直接读取最新的就行</li><li>可串行化通过枷锁来进行读取</li><li>读提交,使用read view来进行创建快照,读取事务处理王的结果.可重复读是只读取,生成时候的视图值</li></ol><p><strong>mvcc版本控制的实现</strong></p><blockquote><p>在内部，<code>InnoDB</code> 存储引擎为每行数据添加了三个 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">隐藏字段open in new window</a>：</p><ul><li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。此外，<code>delete</code> 操作在内部被视为更新，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除</li><li><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</li><li><code>DB_ROW_ID（6字节）</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</li></ul><hr></blockquote><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p><ol><li>create:创建的时候的id</li><li>m_id,当前的事务id列表(启动了,但是没有提交的事务)</li><li>min是最小的事务id</li><li>max是下一次事务的id</li></ol><p><img src="https://cdn.xiaolincoding.com//mysql/other/f595d13450878acd04affa82731f76c5.png" alt="图片"></p><p>每次进行事务操作的时候,会把trx_id更新为当前id,然后roll_point只想前一个版本,同时把前一个版本写入到undo文件里面</p><blockquote><p>undo文件:用来回滚的,还有一个作用就是mvcc</p></blockquote><ol><li>小于min的事务都可见</li><li>大于max的都不可见</li><li>处于min与max之间的,需要判断是不是再ids列表里面,不在就是可见</li></ol><blockquote><p>可重复读是如何实现的</p></blockquote><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE-new.png" alt="img"></p><p>开始的时候createid是自己,列表也是只有自己,所以a是可以一直</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE2.png" alt="img"></p><p> B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时<strong>发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的</strong>，也就是事务 B 可以获取到这条记录。</p><p>接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将小林的余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成<strong>版本链</strong>，如下图：</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16823261923071682326191600.png"></p><blockquote><p>你可以在上图的「记录的字段」看到，由于事务 A 修改了该记录，以前的记录就变成旧版本记录了，于是最新记录和旧版本记录通过链表的方式串起来，而且最新记录的 trx_id 是事务 A 的事务 id（trx_id &#x3D; 51）。</p><p>然后事务 B 第二次去读取该记录，<strong>发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录</strong>，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p><p>最后，当事物 A 提交事务后，<strong>由于隔离级别时「可重复读」，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事物 A 将小林余额修改为 200 万并提交了事务， 事务 B 第三次读取记录时，读到的记录都是小林余额是 100 万的这条记录</strong>。</p></blockquote><p><strong>就是说:对于事务a已经完成了,他的记录里面的trx更新为51,但是51再事务b里面,所以他要往前寻找第一个小于事务b的min的trx,然后就是50,因此取出50来作为记录</strong></p><blockquote><p>读提交是怎么实现的</p></blockquote><p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E8%AF%BB%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.png" alt="img"></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E8%AF%BB%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A12.drawio.png" alt="img"></p><blockquote><p>而对于幻读现象，不建议将隔离级别升级为串行化，因为这会导致数据库并发时性能很差。MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇<a href="https://xiaolincoding.com/mysql/transaction/phantom.html">文章 (opens new window)</a>），解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：</p><ul><li>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味<strong>着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，</strong>因为可能这期间另外一个事务修改了该记录，并提交了事务。</li><li>「可重复读」隔离级别是<strong>启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>，这样就保证了在事务期间读到的数据都是事务启动前的记录。</li></ul><p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p><p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL是怎样运行的&quot;&gt;&lt;a href=&quot;#MySQL是怎样运行的&quot; class=&quot;headerlink&quot; title=&quot;MySQL是怎样运行的&quot;&gt;&lt;/a&gt;MySQL是怎样运行的&lt;/h1&gt;&lt;h2 id=&quot;0-语法篇&quot;&gt;&lt;a href=&quot;#0-语法篇&quot; class</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>pve折腾</title>
    <link href="http://yoursite.com/2023/04/15/pve%E6%8A%98%E8%85%BE/"/>
    <id>http://yoursite.com/2023/04/15/pve%E6%8A%98%E8%85%BE/</id>
    <published>2023-04-15T13:31:59.000Z</published>
    <updated>2023-04-15T14:43:05.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pve折腾"><a href="#pve折腾" class="headerlink" title="pve折腾"></a>pve折腾</h1><p>自己的老电脑用了5年了，cpu还是4核心的，显卡是1050.硬盘还是1t的机械，都没多少剩余空间了。随着最近的硬盘内存大降价，我就凑巨资300买了一个1t的SATA固态，谁能想到，现在的nvme比SATA还便宜（我当初可是花费500元买的500g的nvme），然后硬盘前几天就到了。于是我就直接安装虚拟机了，想着在虚拟机你运行多个系统，目前已经完成的有openwrt，kali，deepin，安卓x86还有win11.但是win11没有进行显卡直通，其余都接近完美了。下面就对这几天的行为进行一次复盘。</p><h2 id="1-pve安装"><a href="#1-pve安装" class="headerlink" title="1.pve安装"></a>1.pve安装</h2><p>直接去官网进行下载，连接是选择<a href="https://pve.proxmox.com/wiki/Downloads%EF%BC%8C%E9%80%89%E6%8B%A9%E6%9C%80%E6%96%B0%E7%9A%84%E7%89%88%E6%9C%AC%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%EF%BC%8C%E7%84%B6%E5%90%8E%E5%AE%89%E8%A3%85%E7%9A%84%E8%AF%9D%E4%BD%BF%E7%94%A8ventoy%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E6%8A%8Apve%E6%94%BE%E5%85%A5%E5%88%B0u%E7%9B%98%E5%B0%B1%E5%8F%AF%E4%BB%A5%E3%80%82">https://pve.proxmox.com/wiki/Downloads，选择最新的版本就可以进行下载，然后安装的话使用ventoy，只需要把pve放入到u盘就可以。</a></p><p><a href="https://zhuanlan.zhihu.com/p/510216630">https://zhuanlan.zhihu.com/p/510216630</a></p><p>可以参考上面的教程，只不过需要注意的是，要填写的ip,是需要和你的局域网在一个网段里面。我自己定义的网络是192.168.100.2，gate：192.168.100.1。</p><h2 id="2-openwrt安装"><a href="#2-openwrt安装" class="headerlink" title="2.openwrt安装"></a>2.openwrt安装</h2><p>固件是在这个大神的网站下载的，自动编译，还可以进行自定义插件。<a href="https://supes.top/">https://supes.top/</a></p><ol><li>首先把img上传到pve上面</li><li>然后就是新建一个虚拟机，但是不要创建iso</li><li>之后使用img2iso，记住我们的磁盘id，使用qm importdisk 100 &#x2F;openwrt.img local-lvm</li><li>然后再启动项，把这个磁盘进行加入。</li><li>之后进行启动，设置网络ip vim etc</li></ol><p><a href="https://post.smzdm.com/p/a7nqp3r9/">https://post.smzdm.com/p/a7nqp3r9/</a></p><p>参考上面的安装流程</p><p><strong>2.1op作为主路由</strong></p><p>在openwrt里面进行PPPoE拨号，那么op就是要进行桥接2个电脑的网口，一个作为lan，一个作为lan，wan口连接宽带，然后去进行pppoe拨号。</p><p><strong>2.2op作为胖路由</strong></p><p>只需要桥接一个网络口，然后连接主路由的时候，需要进行设置。进入接口里面的lan设置ip为静态ip，然后gate设置为192.168.100.1（主路由的ip），然后dns也是主路由的ip，同时关闭DHCP，这样就不会干扰DHCP。</p><p>主要的痛点就是看你要做旁路由还是主路由，主路由就是没有</p><h2 id="3-deepin安装"><a href="#3-deepin安装" class="headerlink" title="3.deepin安装"></a>3.deepin安装</h2><p>deepin安装就是普通的linux安装流程，但是有一点就是安装pcie直通（把wifi）给deepin，无限网卡教程参考如下</p><p><a href="https://www.orcy.net.cn/185.html">https://www.orcy.net.cn/185.html</a></p><ol><li>修改grup，允许iommu</li><li>更新grub</li><li>重启</li><li>之后增加模块在module里面</li><li>然后就直接在虚拟机上添加pcie设备就行</li></ol><h2 id="4-primeos安装"><a href="#4-primeos安装" class="headerlink" title="4.primeos安装"></a>4.primeos安装</h2><p>目前测试了几个x86的系统在虚拟机上，都无法进行安装，只有三哥的这个才可以，选择的系统是classical版本，安卓7.0，然后也是正常的安装流程，要注意的是在安装的使用，你需要新建一个分区，然后再次写入。就可以了。然后功能都有，play商店也有。</p><h2 id="5-win10-x2F-11的坑"><a href="#5-win10-x2F-11的坑" class="headerlink" title="5.win10&#x2F;11的坑"></a>5.win10&#x2F;11的坑</h2><p>主要是为了远程玩游戏，但是看知乎这篇文章说，原神，不让用虚拟机，然后显卡直通弄了半天也没有成功，可能是win11的问题吧，等有时间了换成win10 ltsc试试。主要参考如下的教程</p><p><a href="https://zhuanlan.zhihu.com/p/571224296">https://zhuanlan.zhihu.com/p/571224296</a></p><p>这个大佬的目前还没有成功</p><p><a href="https://www.youtube.com/watch?v=00GxKDGUhxA&amp;ab_channel=VedioTalk">https://www.youtube.com/watch?v=00GxKDGUhxA&amp;ab_channel=VedioTalk</a></p><p>有关这个大佬得到是核显进行驱动</p><p><a href="https://blog.csdn.net/Qwertyuiop2016/article/details/127940349">https://blog.csdn.net/Qwertyuiop2016/article/details/127940349</a></p><p>这个大佬是直接进行ltsc驱动的，不知道是不是我的版本原因，下次再试试吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pve折腾&quot;&gt;&lt;a href=&quot;#pve折腾&quot; class=&quot;headerlink&quot; title=&quot;pve折腾&quot;&gt;&lt;/a&gt;pve折腾&lt;/h1&gt;&lt;p&gt;自己的老电脑用了5年了，cpu还是4核心的，显卡是1050.硬盘还是1t的机械，都没多少剩余空间了。随着最近的硬盘内</summary>
      
    
    
    
    
    <category term="pve，虚拟机" scheme="http://yoursite.com/tags/pve%EF%BC%8C%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>对抗无聊</title>
    <link href="http://yoursite.com/2023/04/12/%E5%AF%B9%E6%8A%97%E6%97%A0%E8%81%8A/"/>
    <id>http://yoursite.com/2023/04/12/%E5%AF%B9%E6%8A%97%E6%97%A0%E8%81%8A/</id>
    <published>2023-04-12T07:49:53.000Z</published>
    <updated>2023-04-12T08:01:34.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对抗无聊"><a href="#对抗无聊" class="headerlink" title="对抗无聊"></a>对抗无聊</h1><p><a href="https://www.bilibili.com/video/BV1RM4y117yB?share_source=copy_web">https://www.bilibili.com/video/BV1RM4y117yB?share_source=copy_web</a></p><p>视频来源于上方,为什么我们总是感觉到无聊,市因为我们的阈值越来越高了了,很难在感到高兴了. </p><h2 id="1-原因"><a href="#1-原因" class="headerlink" title="1.原因"></a>1.原因</h2><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16812861701951681286169442.png"></p><p>及时满足了乐趣,立刻产生了多巴胺,但是每一次产生的阈值都会减少,这就是为什么我们的乐趣越来越多,但会越来越感觉到无聊.(没有延迟满足,)</p><h2 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h2><p><strong>提升多巴胺基准线</strong></p><ol><li>长期每天有接触到阳光(10-20分钟的阳光散步)</li><li>充足的睡眠(减少褪黑素的摄入)</li><li>多吃芝麻,牛肉,鱼肉,奶酪</li><li>多适量的咖啡因(早上开始来喝)</li></ol><p><strong>应对多巴胺低估</strong></p><p>做更难受的事情</p><ol><li>洗冷水澡</li><li>健身</li><li>看书(比当前更难受)</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对抗无聊&quot;&gt;&lt;a href=&quot;#对抗无聊&quot; class=&quot;headerlink&quot; title=&quot;对抗无聊&quot;&gt;&lt;/a&gt;对抗无聊&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1RM4y117yB?share_sou</summary>
      
    
    
    
    
    <category term="心理学" scheme="http://yoursite.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>mitos</title>
    <link href="http://yoursite.com/2023/04/06/mitos/"/>
    <id>http://yoursite.com/2023/04/06/mitos/</id>
    <published>2023-04-06T14:24:59.000Z</published>
    <updated>2023-06-27T14:12:33.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-S081"><a href="#6-S081" class="headerlink" title="6.S081"></a>6.S081</h1><p>这是mit的公开课，使用xv6来自己实现一个小的操作系统。</p><h2 id="0-预备环节"><a href="#0-预备环节" class="headerlink" title="0.预备环节"></a>0.预备环节</h2><h3 id="0-1安装linux"><a href="#0-1安装linux" class="headerlink" title="0.1安装linux"></a>0.1安装linux</h3><p>本人直接使用的是wsl，安装的是debian系统，可以参照官网的实验步骤。唯一的坑点就是git残酷使用的ssh，不知道是梯子问题，还是校园网问题，一直git不了，课允许lan，一直没有反应，最后还是直接在windows下使用git http才弄下来。</p><h3 id="0-2安装vscode"><a href="#0-2安装vscode" class="headerlink" title="0.2安装vscode"></a>0.2安装vscode</h3><p>vscode主要是讲解如何来配置wsl。需要安装2个插件，一个wsl还有一个是c语言插件。然后重点就是下面三个文件的配置，一个task，一个launch，还有一个是c++——properties，参考下面的连接</p><p><a href="https://code.visualstudio.com/docs/cpp/config-wsl">Visual Studio Code 中的 Linux C++ 和 Windows 子系统入门</a></p><ol><li>tasks。json（配置编译器的位置，还有编译时候所需要的参数-o，-g</li><li>这个是调试选项launch，这个是放入gdb的，有工作目录，还有调试的程序</li><li>最后一个properties就是配置gcc还有gdb的位置</li></ol><hr><p>开始扩展:</p><p>参考这个视频</p><p><a href="https://www.bilibili.com/video/BV1Lv411g7EV/?vd_source=ba1e1ba13062afebe588f7479b936272">mit6s081 通过vscode来debug kernel_哔哩哔哩_bilibili</a></p><p>一直以来的vscode的配置都是直接抄的别人配置好的,对vscode 的task.json haiyou launch.json都有一种莫名的不要输系感觉.并且对使用用gdb来进行调试c制作的make程序都深恶痛绝.直到今天,看完这个视频,才发现并没有多么的可怕.</p><p>下面将要来介绍一下launch.json的配置是为什么</p><ol><li>首先launch.json这个是用来调试的</li><li>调试那么就需要调试器吧,调试器就是gdb</li><li>i那位这个riscv,一般的gdb是只能x64,所以需要使用gdb-mul</li><li>然后调试的话,你也需要调试的文件吧,文件就是kernel&#x2F;kernel,因为xv6最开始是从kernel启动的</li><li>miDebuggerServerAddress这个是远程调试的后端,就是输入make qemu-gdb产生的地址</li><li>然后按住F5就可以启动</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// configuration 包含了 gdb 启动的相关信息</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debug xv6&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="comment">// 如果没有下载c/pp插件 这个type会报错</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="comment">// 你需要的调试的二进制文件 , 默认是kernel/kernel ,因为你先得把xv6启动 你才有机会调试xv6上的用户程序</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/kernel/kernel&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="comment">// 是否在kernel的main函数中 打个断点</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="comment">// make qemu-gdb 会启动一个 gdbserver ,你需要指定一个端口,来连接上这个gdb server, 具体端口可以查看.gdbinit</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost:26001&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="comment">// gdb的路径,  gdb可以是gdb-multiarch 也可以是riscv64-linux-gnu-gdb 具体看你安装的是哪个, 如果是ubuntu的话 </span></span><br><span class="line">          <span class="comment">// 应该是gdb-multiarch 比较多</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb-multiarch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pretty printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;logging&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                 <span class="attr">&quot;engineLogging&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                 <span class="attr">&quot;programOutput&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>问题来了,每次我要进行调试,都要自己手动输入一次make qemu-gdb,那么这就相当于一次任务,我们可以值在执行调试的时候,先执行这个,那么可以顶一个pretask,task.json的任务就是制作一个任务,同理,我们如果按照之前,手工运行的话,可以直接制作一个task,就可以直接运行了</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// launch.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xv6debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/kernel/kernel&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:25000&quot;</span><span class="punctuation">,</span> <span class="comment">//见.gdbinit 中 target remote xxxx:xx</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb-multiarch&quot;</span><span class="punctuation">,</span> <span class="comment">// which gdb-multiarch</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xv6build&quot;</span></span><br><span class="line">            #这里的xv6build就是task的定义</span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tasks.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//指定make qemu的执行位置</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xv6build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;isBackground&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;make qemu-gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;regexp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;beginsPattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.*Now run &#x27;gdb&#x27; in another window.&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;endsPattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者<span class="punctuation">:</span> 扎克蕉</span><br><span class="line">链接<span class="punctuation">:</span> https<span class="punctuation">:</span><span class="comment">//www.515code.com/posts/r1eiw7kt/#1-4-VSCode%E8%B0%83%E8%AF%95</span></span><br><span class="line">来源<span class="punctuation">:</span> <span class="number">515</span>code-实验室</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>常规的c定义</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) Launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++.exe build active file&quot;</span><span class="punctuation">,</span><span class="comment">//调试前执行的任务，就是之前配置的tasks.json中的label字段</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span><span class="comment">//配置类型，只能为cppdbg</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span><span class="comment">//请求配置类型，可以为launch（启动）或attach（附加）</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span><span class="comment">//调试程序的路径名称</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="comment">//调试传递参数</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//true显示外置的控制台窗口，false显示内置终端</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\mingw-w64\\x86_64-8.1.0-win32-seh-rt_v6-rev0\\mingw64\\bin\\gdb.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">#相当于gcc -g file -o x.exe</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558 </span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++.exe build active file&quot;</span><span class="punctuation">,</span><span class="comment">//任务的名字，就是刚才在命令面板中选择的时候所看到的，可以自己设置</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/mingw-w64/x86_64-8.1.0-win32-seh-rt_v6-rev0/mingw64/bin/g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="comment">//编译时候的参数</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span><span class="comment">//添加gdb调试选项</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span><span class="comment">//指定生成可执行文件的名称</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/mingw-w64/x86_64-8.1.0-win32-seh-rt_v6-rev0/mingw64/bin&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="comment">//表示快捷键Ctrl+Shift+B可以运行该任务</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="1-lab-util"><a href="#1-lab-util" class="headerlink" title="1.lab util"></a>1.lab util</h2><p><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/util.html">Lab: Xv6 and Unix utilities (mit.edu)</a></p><p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec01-introduction-and-examples">Lec01 Introduction and Examples (Robert) - MIT6.S081 (gitbook.io)</a></p><p><a href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c1/s0.html">第一章 操作系统接口 · 6.S081 All-In-One (dgs.zone)</a></p><p><a href="https://blog.rayzhang.top/2022/06/27/mit-6.s081-lab-util/">MIT 6.S081 Lab Util 实验 | Ray’s Blog (rayzhang.top)</a></p><p>本次实验主要参考以上四个网站,视频没有看,直接看的博主翻译的文稿,感觉翻译的文稿比视频好很多.</p><p>考研的时候学过操作系统了的,就没怎么看视频,直接找的几个重点章节看了一下.现在复习一下基础知识.</p><p><a href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c1/s0.html">第一章 操作系统接口 · 6.S081 All-In-One (dgs.zone)</a></p><p>直接看这本书就行,主要第一张江的是进程相关的内容,应该算进程管理吧.</p><h3 id="1-1进程和内存"><a href="#1-1进程和内存" class="headerlink" title="1.1进程和内存"></a>1.1进程和内存</h3><p>用户态通过调用内核态的fork接口来进行创建内存,对于子进程来讲,自己的pid是0,但是对于父进程来讲,自己的pid是大于0的,因此,我们考研来进行判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fork()在父进程中返回子进程的PID</span></span><br><span class="line"><span class="comment">// 在子进程中返回0</span></span><br><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">    pid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个是会反应两个结果的,一个是父进程输出parent,通过调用fork达到子进程,此时自己的pid是0,所以输出child</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent: child=1234</span><br><span class="line">child: exiting</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时我们可以使用exec来执行相关shell命令,直接在用户太执行.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char* argv[3];</span><br><span class="line">argv[0] = &quot;echo&quot;;</span><br><span class="line">argv[1] = &quot;hello&quot;;</span><br><span class="line">argv[2] = 0;</span><br><span class="line">exec(&quot;/bin/echo&quot;, argv);</span><br><span class="line">printf(&quot;exec error\n&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-2-I-x2F-O和文件描述符"><a href="#1-2-I-x2F-O和文件描述符" class="headerlink" title="1.2 I&#x2F;O和文件描述符"></a>1.2 I&#x2F;O和文件描述符</h3><p>主要讲的是io的读取和写入的api使用,使用write还有read.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span> buf);</span><br></pre></td></tr></table></figure><p>0代表标准输入流,就是我们输入的东西,buf就是要接受储存的字符串,最后一个是长度,我要接受多长的字符串.</p><p>同理,write就是写入,这个是写入到标准输出流.第一个是要写的保存的地方,然后就是要写的字符串,还有长度.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><h3 id="1-3-管道"><a href="#1-3-管道" class="headerlink" title="1.3 管道"></a>1.3 管道</h3><p>管道就是用于进程通信的,一个用来读取,一个写入 .只能单向联通,半双工.写入的时候读取必须关闭.</p><p>使用方法就是创建一个二位数组,通过pipe来进行调用创建管道,使用close来关闭管道一端然后调用上次的read还有write方法来进行读取还有写入.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序调用<code>pipe</code>，创建一个新的管道，并在数组p中记录读写文件描述符。在<code>fork</code>之后，父子进程都有指向管道的文件描述符。子进程调用<code>close</code>和<code>dup</code>使文件描述符0指向管道的读取端（前面说过优先分配最小的未使用的描述符），然后关闭p中所存的文件描述符，并调用<code>exec</code>运行<code>wc</code>。当<code>wc</code>从它的标准输入读取时，就是从管道读取。父进程关闭管道的读取端，写入管道，然后关闭写入端。</p><blockquote><p>接起来。然后对管道的左端调用<code>fork</code>和<code>runcmd</code>，对管道的右端调用<code>fork</code>和<code>runcmd</code>，并等待两者都完成。管道的右端可能是一个命令，该命令本身包含一个管道(例如，<code>a | b | c</code>)，该管道本身<code>fork</code>为两个新的子进程(一个用于b，一个用于c)。因此，shell可以创建一个进程树。这个树的叶子是命令，内部节点是等待左右两个子进程完成的进程。</p></blockquote><p>队友左右节点都是自己进行创建一个新的fork然后执行之后来返回</p><h3 id="1-4-文件系统"><a href="#1-4-文件系统" class="headerlink" title="1.4 文件系统"></a>1.4 文件系统</h3><p>文件系统就是文件分为文件还有文件夹,文件夹是一个特殊的数据结构,里面包含当前文件夹的所有名称还有他的大小.</p><p>通过调用这个方法来得到答案</p><p>这个stat是类型,如果是文件夹还有一个数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR 1    <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE 2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE 3 <span class="comment">// Device</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> dev;     <span class="comment">// 文件系统的磁盘设备</span></span><br><span class="line">    uint ino;    <span class="comment">// Inode编号</span></span><br><span class="line">    <span class="type">short</span> type;  <span class="comment">// 文件类型</span></span><br><span class="line">    <span class="type">short</span> nlink; <span class="comment">// 指向文件的链接数</span></span><br><span class="line">    uint64 size; <span class="comment">// 文件字节数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-5实验"><a href="#1-5实验" class="headerlink" title="1.5实验"></a>1.5实验</h3><h4 id="1-5-1boot"><a href="#1-5-1boot" class="headerlink" title="1.5.1boot"></a>1.5.1boot</h4><p>启动过程,首先就是git’数据,直接登录网页使用github来进行下载,使用ssh一直卡死.之后切换分支到util就行,然后执行 make qemu.毕竟这个实验是在qemu上进行模拟的</p><h4 id="1-5-2sleep-easy"><a href="#1-5-2sleep-easy" class="headerlink" title="1.5.2sleep (easy)"></a>1.5.2sleep (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h4><p>实现sleep函数.我们可以根据下面提示来进行做</p><blockquote><ul><li>Before you start coding, read Chapter 1 of the <a href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">xv6 book</a>.</li><li>Look at some of the other programs in <code>user/</code> (e.g., <code>user/echo.c</code>, <code>user/grep.c</code>, and <code>user/rm.c</code>) to see how you can obtain the command-line arguments passed to a program.</li><li>If the user forgets to pass an argument, sleep should print an error message.</li><li>The command-line argument is passed as a string; you can convert it to an integer using <code>atoi</code> (see user&#x2F;ulib.c).</li><li>Use the system call <code>sleep</code>.</li><li>See <code>kernel/sysproc.c</code> for the xv6 kernel code that implements the <code>sleep</code> system call (look for <code>sys_sleep</code>), <code>user/user.h</code> for the C definition of <code>sleep</code> callable from a user program, and <code>user/usys.S</code> for the assembler code that jumps from user code into the kernel for <code>sleep</code>.</li><li>Make sure <code>main</code> calls <code>exit()</code> in order to exit your program.</li><li>Add your <code>sleep</code> program to <code>UPROGS</code> in Makefile; once you’ve done that, <code>make qemu</code> will compile your program and you’ll be able to run it from the xv6 shell.</li><li>Look at Kernighan and Ritchie’s book <em>The C programming language (second edition)</em> (K&amp;R) to learn about C.</li></ul></blockquote><p>看ls是如何获取到参数的,如果没有参数,直接反悔哦失败,传递的参数是字符串,你需要使用atoi,直接使用系统调用的sleep功能.然后调用exit来推出这个程序.最后把这个给功能加入到makefile里面.</p><p>上面已经给出了了具体思路,我们只需要写代码就行.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: sleep &lt;ticks&gt;\n&quot;</span>);  <span class="comment">//参数数量不正确，打印错误信息</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> time = atoi(argv[<span class="number">1</span>]);  <span class="comment">//使用atoi转换，见user.h和ulib.c</span></span><br><span class="line">    sleep(time);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>argc是参数个数,argv是参数字符串列表,如果c&lt;2就是不合法,然后直接进行执行调用系统api.之后就是加入到makefile里面.</p><h4 id="1-5-3pingpong-easy"><a href="#1-5-3pingpong-easy" class="headerlink" title="1.5.3pingpong (easy)"></a>1.5.3pingpong (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h4><p>实现pingpong功能就是,具体要求就是两个管道,一个父亲写,儿子读取,一个儿子读取谷歌的父亲管道,然后写入到自己的管道,父亲来读取.使用wait可以保真先后顺序.</p><blockquote><p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</pid></pid></pid></p></blockquote><blockquote><ul><li>Use <code>pipe</code> to create a pipe.</li><li>Use <code>fork</code> to create a child.</li><li>Use <code>read</code> to read from the pipe, and <code>write</code> to write to the pipe.</li><li>Use <code>getpid</code> to find the process ID of the calling process.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li><li>User programs on xv6 have a limited set of library functions available to them. You can see the list in <code>user/user.h</code>; the source (other than for system calls) is in <code>user/ulib.c</code>, <code>user/printf.c</code>, and <code>user/umalloc.c</code>.</li></ul></blockquote><p>根据上面提示,使用pipe创建两个管道,然后使用fork创建孩子进程,之后是以哦那个read来读取,和write来写入.注意要进行关闭管道的一端.只允许单项流通.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[] = &#123;<span class="string">&#x27;P&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> parent2child[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> child2parent[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(parent2child) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create pipe parent2child\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(child2parent) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create pipe child2parent\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();  <span class="comment">// create child process</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create the child process!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child process, read from pipe parent2child,</span></span><br><span class="line">        <span class="comment">// write to pipe child2parent</span></span><br><span class="line">        close(parent2child[<span class="number">1</span>]);</span><br><span class="line">        close(child2parent[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (read(parent2child[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Child: Failed to read from pipe parent2child!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">        <span class="keyword">if</span> (write(child2parent[<span class="number">1</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Child: Failed to write to pipe child2parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent process, write to pipe parent2child,</span></span><br><span class="line">        <span class="comment">// read from pipe child2parent</span></span><br><span class="line">        close(parent2child[<span class="number">0</span>]);</span><br><span class="line">        close(child2parent[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (write(parent2child[<span class="number">1</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Failed to write to pipe parent2child!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (read(child2parent[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to read from pipe child2parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先if的是孩子进程,所以我们关闭父亲写入的,来进行读取,同时关闭孩子的读取来进行写入,把读取的写入到矮子里面.之后就是父亲,父亲是自己先进行写入,然后读取孩子的,也要进行关闭程序.</p><h4 id="1-5-4primes-moderate-x2F-hard"><a href="#1-5-4primes-moderate-x2F-hard" class="headerlink" title="1.5.4primes (moderate)&#x2F;(hard)"></a>1.5.4primes (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)&#x2F;(<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</h4><blockquote><h4 id="write-a-concurrent-version-of-prime-sieve-using-pipes-This-idea-is-due-to-Doug-McIlroy-inventor-of-Unix-pipes-The-picture-halfway-down-this-page-and-the-surrounding-text-explain-how-to-do-it-Your-solution-should-be-in-the-file-user-primes-c"><a href="#write-a-concurrent-version-of-prime-sieve-using-pipes-This-idea-is-due-to-Doug-McIlroy-inventor-of-Unix-pipes-The-picture-halfway-down-this-page-and-the-surrounding-text-explain-how-to-do-it-Your-solution-should-be-in-the-file-user-primes-c" class="headerlink" title="write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user/primes.c."></a>write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</h4></blockquote><p>题目要求,并发使用管道来进行读取输出2-35的素数.思路是一个写入2-35的管道,另外一个管道来进行输出.</p><blockquote><ul><li>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</li><li>Once the first process reaches 35, it should wait until the entire pipeline terminates, including all children, grandchildren, &amp;c. Thus the main primes process should only exit after all the output has been printed, and after all the other primes processes have exited.</li><li>Hint: <code>read</code> returns zero when the write-side of a pipe is closed.</li><li>It’s simplest to directly write 32-bit (4-byte) <code>int</code>s to the pipes, rather than using formatted ASCII I&#x2F;O.</li><li>You should create the processes in the pipeline only as they are needed.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li></ul></blockquote><p>这个提示没什么用,直接看的大佬的版本,思路就是使用快速筛,蠡口上有讲解.主要思路就是第一遍把2的倍数全被设置true,剩下的从false里面读取,如果是当前的倍数的,也设置成true,指导到最后一个值.(这个给可以使用并发执行).</p><blockquote><p>所以这个问题就像是流水线一样，第一个进程将 <code>2~n</code> 依次写给第二个进程，第二个进程筛选非 <code>2</code> 倍数的数输出给第三个进程，第三个进程筛选非 <code>3</code> 倍数的数给第四个进程… 以此类推，单个阶段不一定要全部做完才交给后一阶段，完全可以像流水线一样进行。</p><p>我们的目标是使用 <code>pipe</code> 和 <code>fork</code> 来实现这样的流水线，我们将处理 <code>2~35</code> 的数字，进行素数筛。由于 xv6 的文件描述符和进程数量有限，第一个进程可以在 <code>35</code> 时停止。</p></blockquote><p>使用wait来保真先后顺序,父亲之后才是孩子.在每一个管道的最后一端加入-1,代表管道内容已经结束了.</p><p>整体代码,蠡口刷多了,写起来不是会很费力的.读取老的管道,同时把数字写入到新的管道,创建新进程调用新的管道作为输入,注意也要在最后加入-1作为结尾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prime_num 35</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_child</span><span class="params">(<span class="type">int</span> *read_pipe)</span> &#123;</span><br><span class="line">    close(read_pipe[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> n, status;</span><br><span class="line">    <span class="keyword">if</span> ((status = read(read_pipe[<span class="number">0</span>], &amp;n, <span class="keyword">sizeof</span>(<span class="type">int</span>))) == <span class="number">0</span>) &#123; <span class="comment">// fetch the first number in the row</span></span><br><span class="line">        close(read_pipe[<span class="number">0</span>]);  <span class="comment">// no more numbers in the pipeline</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(status == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to read from pipe!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, n);  <span class="comment">// print out the first number as the prime</span></span><br><span class="line">    <span class="type">int</span> parent_pipe[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(parent_pipe) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create pipe!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create child process!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(read_pipe[<span class="number">0</span>]);</span><br><span class="line">        run_child(parent_pipe);  <span class="comment">// receive number in the new child process</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(parent_pipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="keyword">while</span> ((status = read(read_pipe[<span class="number">0</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">// filter and send numbers to new child process</span></span><br><span class="line">            <span class="keyword">if</span> (num % n != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(write(parent_pipe[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to write to pipe!\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(status == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to read from pipe!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(parent_pipe[<span class="number">1</span>]);</span><br><span class="line">        wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> input_pipe[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(input_pipe) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create pipe!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Failed to create child process!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        run_child(input_pipe); <span class="comment">// child process to filter the numbers</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(input_pipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= prime_num; i++) &#123; <span class="comment">// send 2~35 to the child process</span></span><br><span class="line">            <span class="keyword">if</span>(write(input_pipe[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parent: Fail to write to pipe!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(input_pipe[<span class="number">1</span>]);</span><br><span class="line">        wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-5find-moderate"><a href="#1-5-5find-moderate" class="headerlink" title="1.5.5find (moderate)"></a>1.5.5find (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h4><p>实现查找功能</p><blockquote><ul><li>Look at user&#x2F;ls.c to see how to read directories.</li><li>Use recursion to allow find to descend into sub-directories.</li><li>Don’t recurse into “.” and “..”.</li><li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li><li>You’ll need to use C strings. Have a look at K&amp;R (the C book), for example Section 5.5.</li><li>Note that &#x3D;&#x3D; does not compare strings like in Python. Use strcmp() instead.</li><li>Add the program to <code>UPROGS</code> in Makefile</li></ul></blockquote><p>提示是要我们区看ls的实现,ls把通过switch来对不同的来做判断,我们的现在要求就是根据判断末尾是不是要查找的目标,来进行输出.那么这一个题目就是变成字符串的截取题目.因为对c不是很熟.所以对这个题的代码卡了很久.char *a&#x3D;p.a&#x3D;a+strlen(a).这个意思是把a得到位置移动到最末尾,通过这样就变成截取字符串的操作.</p><ol><li>首先对与目标我们加上&#x2F;,因为每一个文件都是&#x2F;a&#x2F;a&#x2F;b这样的</li><li>然后我们使用ls一样的测策略,对于文件,移动到和目标文件一样长的地方,看他们想不想等,相等就进行输出</li><li>对于文件夹,我们使用递归,但是对于&#x2F;..还有&#x2F;.这个文件夹我们就不在进行递归 </li><li></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory is a file containing a sequence of dirent structures.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>文件夹的数据结构</p><p>实现代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="comment">// Find first character after last slash.</span></span><br><span class="line">    <span class="keyword">for</span> (p = path + <span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">        ;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//返回末尾的文件名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *directory, <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(directory, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot open %s\n&quot;</span>, directory);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot stat %s\n&quot;</span>, directory);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123; <span class="comment">//查看路径类型</span></span><br><span class="line">        <span class="keyword">case</span> T_FILE: <span class="comment">//是文件</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(fmtname(directory), filename) == <span class="number">0</span>) &#123; <span class="comment">//比较路径末尾文件名和查找的文件名</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>, directory);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_DIR: <span class="comment">//是目录</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strlen</span>(directory) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;find: path is too long \n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(buf, directory);</span><br><span class="line">            p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">            *p++ = <span class="string">&#x27;/&#x27;</span>; <span class="comment">//拼凑当前目录路径</span></span><br><span class="line">            <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123; <span class="comment">//遍历目录</span></span><br><span class="line">                <span class="keyword">if</span> (de.inum == <span class="number">0</span> || <span class="built_in">strcmp</span>(<span class="string">&quot;.&quot;</span>, de.name) == <span class="number">0</span> ||</span><br><span class="line">                    <span class="built_in">strcmp</span>(<span class="string">&quot;..&quot;</span>, de.name) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                memmove(p, de.name, DIRSIZ); <span class="comment">//拼凑当前文件路径</span></span><br><span class="line">                p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (stat(buf, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                find(buf, filename); <span class="comment">//调用find递归查找</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: find &lt;directory&gt; &lt;filename&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-lab-syscall"><a href="#2-lab-syscall" class="headerlink" title="2.lab syscall"></a>2.lab syscall</h2><p><a href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c2/s2.html">2.2 用户态，核心态，以及系统调用 · 6.S081 All-In-One (dgs.zone)</a></p><p>操作系统的作用是抽象系统同资源,最基本的目的就是互不影响程序,当一个程序出现问题不会影响下一个程序.所以系统管理员是操作系统,他与硬件打交道.</p><h3 id="2-2用户态，核心态，以及系统调用"><a href="#2-2用户态，核心态，以及系统调用" class="headerlink" title="2.2用户态，核心态，以及系统调用"></a>2.2用户态，核心态，以及系统调用</h3><p>用户态和和心态,和心态就是直接与硬件打交道的</p><p>核心态可以使用特权指令,用户通过条用内核函数的程序,把用户态转移到和心态,然后 在内核指定的路口,进入内核(ecall函数)需要写entry(write),然后通过设置一个数字作为这个函数的映射,内核太调用这个数字实际对那个内核里面的函数来实现方法</p><p><img src="https://blog.rayzhang.top/2022/07/05/mit-6.s081-lab-syscall/syscall_fork.png"></p><p>syscall调用sysproc实际方法</p><h3 id="2-3内核组织"><a href="#2-3内核组织" class="headerlink" title="2.3内核组织"></a>2.3内核组织</h3><p>分为大内核还有小内核,大内核就是和Windows差不多,所以的硬件功能都已经实现,小内核就是自己要实现文件这中内核操作,通过组合操作.</p><h3 id="2-4进程"><a href="#2-4进程" class="headerlink" title="2.4进程"></a>2.4进程</h3><p>进程都有自己的结构体,有自己的状态,还有自己的页表(页表,就是一个进程的虚拟地址空间)</p><h3 id="2-5实验"><a href="#2-5实验" class="headerlink" title="2.5实验"></a>2.5实验</h3><h4 id="2-5-1System-call-tracing-moderate"><a href="#2-5-1System-call-tracing-moderate" class="headerlink" title="2.5.1System call tracing (moderate)"></a>2.5.1System call tracing (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h4><p>实现追踪功能,然后追踪的进程的mask是这样得到 <code>trace(1 &lt;&lt; SYS_fork)</code>,这个参数可以通过argint得到</p><blockquote><ul><li>Add <code>$U/_trace</code> to UPROGS in Makefile</li><li>Run make qemu and you will see that the compiler cannot compile <code>user/trace.c</code>, because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. Once you fix the compilation issues, run trace 32 grep hello README; it will fail because you haven’t implemented the system call in the kernel yet.</li><li>Add a <code>sys_trace()</code> function in <code>kernel/sysproc.c</code> that implements the new system call by remembering its argument in a new variable in the <code>proc</code> structure (see <code>kernel/proc.h</code>). The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, and you can see examples of their use in <code>kernel/sysproc.c</code>.</li><li>Modify <code>fork()</code> (see <code>kernel/proc.c</code>) to copy the trace mask from the parent to the child process.</li><li></li></ul></blockquote><p>给定的提示,我们直接运行make是无法编译成功的.提示是因为无法编译trace.c,因为这个给用户态的功能trace在内核态没有对应实现,我们需要实现.首先就是在userh里面添加trace功能(申明,系统提供的api).之后区usys添加入口,这是上面的陷入,然后添加一个数值在syscall</p><blockquote><p>because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. </p></blockquote><p>尽管添加了之后,你还是没有办法实现,因为你要实现systrace功能在sysproc里面,我们需要把追踪的进程的掩码设置成传入的参数,通过argint得到mask,之后对于该进程创建的子进程,我们也许奥把掩码设置成先对应的mask(复制操作,只需要更改fork的逻辑就行),最后我们把掩码一样的在syscall里进行输出.</p><p><strong>这个题的主要重点,就是让我们了解到系统调用的流程,首先是在user里面注册系统调用函数,然后通过entry进行陷入这个函数,之后调用特殊的数值,来作为系统调用的参数.然后我们在sysproc具体实现这个功能</strong></p><p>主要 的流程就是上图所示</p><blockquote><p>所以，需要有一种方式能够让应用程序可以将控制权转移给内核（Entering Kernel）。</p><p>在RISC-V中，有一个专门的指令用来实现这个功能，叫做ECALL。ECALL接收一个数字参数，当一个用户程序想要将程序执行的控制权转移到内核，它只需要执行ECALL指令，并传入一个数字。这里的数字参数代表了应用程序想要调用的System Call。</p><p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MJX963vbIPHKetjGrZN%2F-MJXAkJxD8pTZOm1Tay_%2Fimage.png?alt=media&token=cf3e26a2-3c26-43b8-aee0-6d5787f8dcf5" alt="img"></p><p>ECALL会跳转到内核中一个特定，由内核控制的位置。我们在这节课的最后可以看到在XV6中存在一个唯一的系统调用接入点，每一次应用程序执行ECALL指令，应用程序都会通过这个接入点进入到内核中。举个例子，不论是Shell还是其他的应用程序，当它在用户空间执行fork时，它并不是直接调用操作系统中对应的函数，而是调用ECALL指令，并将fork对应的数字作为参数传给ECALL。之后再通过ECALL跳转到内核。</p><p>下图中通过一根竖线来区分用户空间和内核空间，左边是用户空间，右边是内核空间。在内核侧，有一个位于syscall.c的函数syscall，每一个从应用程序发起的系统调用都会调用到这个syscall函数，syscall函数会检查ECALL的参数，通过这个参数内核可以知道需要调用的是fork（3.9会有相应的代码跟踪介绍）。</p><p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MJX963vbIPHKetjGrZN%2F-MJXO2n90L0ziqU8mTcg%2Fimage.png?alt=media&token=754f49c1-58a2-42d5-9427-094fc95ab613" alt="img"></p></blockquote><ol><li>在makefile进行注册</li><li>在user里面进行注册函数trace在sys里面进行进入entry</li><li>之后在syscall里面进行设置特殊的数值</li><li>然后调用这个sys_trace,之后在sysproc里实现(思路就是调用新的trace函数)</li><li>trace函数就是把当前mask传给当前进程</li><li>然后在syscall调用,调用结束后.我们来对这个掩码做比较,相同就进行输出</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">    <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>) &#123;  <span class="comment">//获取trace的参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;               <span class="comment">//获取失败返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trace(mask);  <span class="comment">//调用核心函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个trace函数还需要在defs进行申明,不然没发实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span> mask)</span> &#123; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;mask = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对fork的修改,就是把父进程的mask传授那个给子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br><span class="line">  np-&gt;cwd = idup(p-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">  np-&gt;mask = p-&gt;mask; <span class="comment">//复制mask掩码</span></span><br><span class="line"></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line"></span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;wait_lock);</span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line">  release(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;np-&gt;lock);</span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后根据提示,我们在这里进行符合的输出</p><blockquote><p>The 32 is <code>1&lt;&lt;SYS_read</code>. In the second exam</p></blockquote><p>他的逻辑就是把这个给进程进行移动系统的位数,所以我们只要一回来,然后与1,还是1,就说明这个是需要最终的,我们就进行输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(p-&gt;mask &gt;&gt; num &amp; 1) &#123;</span><br><span class="line">      printf(&quot;%d: syscall %s -&gt; %d\n&quot;,p-&gt;pid, syscalls_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;mask &gt;&gt; num &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid, syscalls_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-lab-pgtble"><a href="#3-lab-pgtble" class="headerlink" title="3.lab pgtble"></a>3.lab pgtble</h2><h3 id="3-1基础知识"><a href="#3-1基础知识" class="headerlink" title="3.1基础知识"></a>3.1基础知识</h3><p><img src="https://blog.rayzhang.top/2022/07/22/mit-6.s081-lab-pgtbl/pgtbl-3-level.png" alt="img"></p><p>虚拟地址,通过页表来获取得到ppn(页表项),之后通过页表项目+offset得到最后的物理低值.这是一个三级页表,我没得到的前面两个ppn是下一个页面的地址.转化教程如下walk,让hi偶我们再看每一个pte是不是有效,获得pte使用的全相联,直接把这个虚拟地址进行映射到页表上面,最终与1ff想与,就是在512个里面找到是那一项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span> </span><br><span class="line">  <span class="comment">//pagetable表示一级页表的地址，va为虚拟内存地址，alloc表示是否创建条目</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA) <span class="comment">//虚拟内存地址越界，报错</span></span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123; <span class="comment">//分三级地址</span></span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)]; <span class="comment">//使用位运算获取L2/L1/L0，计算索引位置</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte); <span class="comment">//若条目有效，将页表指针指向下级页表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>) <span class="comment">//若无效，且alloc有设置，创建相关条目</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)]; <span class="comment">//最后返回三级页表中映射的物理地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化流程</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16876974250271687697424363.png" alt="16876974250271687697424363.png"></p><p>首先kinit是初始化锁,之后的kvmint初始化内核页表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  kernel_pagetable = kvmmake();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Make a direct-map page table for the kernel.</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line"></span><br><span class="line">  kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel stacks</span></span><br><span class="line">  proc_mapstacks(kpgtbl);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看kvmake的,她的作用就是映射pa,与设备在内存的地址上面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要使用的map来进行操作,map就是设置映射最底层的实现了，参数分别为页表地址 <code>pagetable</code>，虚拟地址 <code>va</code>，映射大小 <code>sz</code>，物理地址 <code>pa</code> 和访问标志位 <code>perm</code>：</p><p>代码的含义:对虚拟地址首先下面对齐,结尾的扼要进行最下面的页面对齐</p><p>使用walk返回的值是一个地址,还需要*pte才是最后的值,返回的是物理地址.然后在使用    *pte &#x3D; PA2PTE(pa) | perm | PTE_V;填入值</p><hr><p>用户地址基础知识</p><p><img src="https://blog.rayzhang.top/2022/07/22/mit-6.s081-lab-pgtbl/user-addr-space.png" alt="img"></p><p>构建第一个用户程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对用户程序分配pagetable,epc,sp,状态,重点看alloc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line">  p-&gt;state = USED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查找 空闲的来进行分配</p><p>看用户页表的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a user page table for a given process,</span></span><br><span class="line"><span class="comment">// with no user memory, but with trampoline pages.</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty page table.</span></span><br><span class="line">  pagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line">  <span class="comment">// at the highest user virtual address.</span></span><br><span class="line">  <span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line">  <span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保留两个空间一个是trapframe(陷入的时候用的),然后放入到页表里面</p><h3 id="3-2实现系统调用的加速"><a href="#3-2实现系统调用的加速" class="headerlink" title="3.2实现系统调用的加速"></a>3.2实现系统调用的加速</h3><h4 id="要求和提示"><a href="#要求和提示" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在这个部分中，我们要通过调整页表的映射来实现对特定的系统调用的加速。</p><p>在部分操作系统（例如 Linux 中），会使用用户空间和内核空间之间的一块只读区域用来进行数据共享，以此来达到加速特定的系统调用的目的，这样就消除了与内核交互产生的开销。在本部分中，我们将实现对 <code>getpid</code> 系统调用的优化。</p><p>当一个进程被创建时，我们需要将一个只读的内存页映射到 <code>USYSCALL</code> 上，其中 <code>USYSCALL</code> 是一个虚拟内存地址，见 <code>kernel/memlayout.h</code>。在该内存页上我们需要存储一个叫 <code>struct usyscall</code> 的结构体，见 <code>kernel/memlayout.h</code>，然后将其初始化使其存储当前进程的 PID。下面是 <code>memlayout.h</code> 的节选部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#define USYSCALL (TRAPFRAME - PGSIZE)</span><br><span class="line">struct usyscall &#123;</span><br><span class="line">  int pid;  // Process ID</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个 Lab 中，系统在用户空间部分已经提供了 <code>ugetpid()</code>，并会自动使用 <code>USYSCALL</code> 的映射，<code>ugetpid</code> 函数就是我们测试时的函数，<strong>为了使得他工作正常我们需要完成相关修改</strong>。这段见 <code>user/ulib.c</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">#ifdef LAB_PGTBL</span><br><span class="line">int</span><br><span class="line">ugetpid(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct usyscall *u = (struct usyscall *)USYSCALL;</span><br><span class="line">  return u-&gt;pid;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>相关提示：</p><ul><li>可以在 <code>kernel/proc.c</code> 下的 <code>proc_pagetable</code> 中处理内存映射问题。</li><li>注意处理访问标志位使得该内存页对用户空间来说是只读的。</li><li>了解 <code>mappages()</code> 的使用方法会很有帮助。</li><li>不要忘记在 <code>allocproc()</code> 中分配和初始化内存页。</li><li>确保在 <code>freeproc()</code> 中正确地释放了内存页。</li></ul><blockquote><p>大致的意识就是要求我们使用用户空间和内核空间之间的一块只读区域用来进行数据共享，以此来达到加速特定的系统调用的目的，这样就消除了与内核交互产生的开销。</p></blockquote><p><img src="https://blog.rayzhang.top/2022/07/22/mit-6.s081-lab-pgtbl/usyscall.png" alt="img"></p><blockquote><p>要求我们在usyspage这个里面进行设置我们的信息都存放在这个空间里面</p></blockquote><p>根据我们上面的基础知识,我们知道页表初始化**,实在proc_pagetable(p);**这个函数里面,我们在这里进行映射usys这个地址到页表.</p><p>和trapoframe一样的流程,分配之后,然后才是分配页表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a usyscall page</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;usyspage = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">      freeproc(p);</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Init the usyscall page</span></span><br><span class="line">  p-&gt;usyspage-&gt;pid = p-&gt;pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//页表函数</span></span><br><span class="line"><span class="comment">// map the usyscall page</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">              (uint64)(p-&gt;usyspage), PTE_R | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line">按照trapframe释放方法</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;usyspage) </span><br><span class="line">    kfree((<span class="type">void</span> *)p-&gt;usyspage);</span><br><span class="line">  p-&gt;usyspage = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p-&gt;pagetable) proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br></pre></td></tr></table></figure><p>注意到释放过程,调用页表,那么页表项,我们也要释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="3-3实现页表打印"><a href="#3-3实现页表打印" class="headerlink" title="3.3实现页表打印"></a>3.3实现页表打印</h3><h4 id="要求和提示-1"><a href="#要求和提示-1" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在本部分中，我们需要将 RISC-V 的页表可视化，也就是实现一个页表内容的打印功能，作为后续调试的辅助工具。</p><p>我们需要定义一个叫做 <code>vmprint()</code> 的函数，这个函数应当传入一个类型为 <code>pagetable_t</code> 的参数，也是页表的指针，然后将页表的全部有效信息打印出来。题目要求在 <code>kernel/exec.c</code> 下的 <code>exec()</code> 中，在最后的 <code>return argc</code> 前加入一行（疯狂暗示，喂到嘴巴里）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">if(p-&gt;pid==1) vmprint(p-&gt;pagetable);</span><br></pre></td></tr></table></figure><p>来实现对第一个进程的页表的打印。</p><p>题目中给出了示例，当第一个进程刚完成 <code>exec()</code> 执行了 <code>/init</code> 时的页表状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">page table <span class="number">0x0000000087f6e000</span></span><br><span class="line"> .<span class="number">.0</span>: pte <span class="number">0x0000000021fda801</span> pa <span class="number">0x0000000087f6a000</span></span><br><span class="line"> .. .<span class="number">.0</span>: pte <span class="number">0x0000000021fda401</span> pa <span class="number">0x0000000087f69000</span></span><br><span class="line"> .. .. .<span class="number">.0</span>: pte <span class="number">0x0000000021fdac1f</span> pa <span class="number">0x0000000087f6b000</span></span><br><span class="line"> .. .. .<span class="number">.1</span>: pte <span class="number">0x0000000021fda00f</span> pa <span class="number">0x0000000087f68000</span></span><br><span class="line"> .. .. .<span class="number">.2</span>: pte <span class="number">0x0000000021fd9c1f</span> pa <span class="number">0x0000000087f67000</span></span><br><span class="line"> .<span class="number">.255</span>: pte <span class="number">0x0000000021fdb401</span> pa <span class="number">0x0000000087f6d000</span></span><br></pre></td></tr></table></figure><p>相关提示：</p><ul><li>可以把 <code>vmprint()</code> 放在 <code>kernel/vm.c</code> 里面</li><li>记得使用 <code>kernel/riscv.h</code> 最后添加的宏定义，包括但不限于 <code>PTE2PA</code> 等</li><li>强烈建议参考 <code>vm.c</code> 文件中的 <code>freewalk</code> 函数（疯狂暗示，喂嘴巴里了）</li><li>记得在 <code>kernel/defs.h</code> 中定义 <code>vmprint</code> 函数，以便在 <code>exec.c</code> 中成功调用</li><li>在 <code>printf</code> 中使用 <code>%p</code> 来打印完整的 16 进制 64 位地址和 PTE 信息</li></ul><p><img src="https://blog.rayzhang.top/2022/07/22/mit-6.s081-lab-pgtbl/pgtbl-3-level.png" alt="img"></p><p>这个很明显就是递归的效果,我们参考freewalk,首先得到page,之后根据二级页表得到页表项,再继续递归</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pgtblprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="comment">// if PTE is valid</span></span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; depth; t++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if this PTE points to a lower-level page table</span></span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// start with new child PTE addr</span></span><br><span class="line">        <span class="type">pagetable_t</span> child = (<span class="type">pagetable_t</span>)PTE2PA(pte);</span><br><span class="line">        pgtblprint(child, depth + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  pgtblprint(pagetable, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4查询内存页访问情况"><a href="#3-4查询内存页访问情况" class="headerlink" title="3.4查询内存页访问情况"></a>3.4查询内存页访问情况</h3><h4 id="要求和提示-2"><a href="#要求和提示-2" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>一些垃圾回收器可以根据内存页被访问情况的信息来进行工作。</p><p>在本部分中，我们将主要考虑为 xv6 实现一个新的功能，也就是检测用户空间的内存访问情况，并将信息返回给用户空间。我们需要通过检查 RISC-V 页表中的 <code>A</code> 标识位来实现，RISC-V 硬件每当尝试解决 TLB 未命中问题时，访问内存页的时候就会在页表中将对应 PTE 的标志位置为有效。</p><p>我们的目标是实现一个叫做 <code>pgaccess</code> 的系统调用，以此来查看哪些内存页被访问过了。这个系统调用需要传入三个参数，第一个参数是开始的要查看的用户空间内存页地址，第二个参数是需要查看的内存页数量，最后传入的是一个用户地址空间，好让我们将结果写到用户地址空间，结果以 bitmask 的形式存储，每一位和各个内存页一一对应，第一个内存页对应最小的比特位。</p><p>相关提示：</p><ul><li>考虑在 <code>kernel/sysproc.c</code> 下实现 <code>sys_pgaccess()</code> 系统调用主要功能。</li><li>需要使用 <code>argaddr()</code> 和 <code>argint()</code> 来获取系统调用传入的参数，这一块可以详见上次的 <a href="https://blog.rayzhang.top/2022/07/05/mit-6.s081-lab-syscall/">Lab syscall: System calls</a>。</li><li>由于我们需要将结果返回给用户态的地址，因此有必要使用内核态中的临时缓冲区进行结果的处理，然后使用 <code>copyout()</code> 函数将结果复制到用户态，这段也可见 Lab Syscall 中相关内容。</li><li>可以设置扫描的内存页数上限。</li><li>在 <code>kernel/vm.c</code> 下的 <code>walk()</code> 函数会对找到正确的 PTE 很有帮助。</li><li>需要在 <code>kernel/riscv.h</code> 中额外定义一下 <code>PTE_A</code>，也就是访问标记的比特位。（不敢相信他们居然原来没有加）</li><li>确保在扫描内存页结束后将标志位 <code>PTE_A</code> 清零，不然下次扫描这个页的时候你看到标志位就乱了，不知道有没有被访问过了。</li><li>在调试页表的时候可以使用 <code>vmprint()</code>，活学活用了属于是。</li></ul><p><img src="https://blog.rayzhang.top/2022/07/22/mit-6.s081-lab-pgtbl/pte.png" alt="img"></p><p>数，第一个参数是开始的要查看的用户空间内存页地址，第二个参数是需要查看的内存页数量，最后传入的是一个用户地址空间，好让我们将结果写到用户地址空间，结果以 bitmask 的形式存储，</p><p>参照这个图,我们自己来进行设置access</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>可以参照这个代码块</p><ol><li>首先arg获得参数</li><li>然后是指读取条目数</li><li>之后就是对地址来求pte,看pte之后来进行清楚</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 va;</span><br><span class="line">  <span class="type">int</span> page_nums;</span><br><span class="line">  uint64 out_addr;</span><br><span class="line">  <span class="comment">// get syscall params</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;va) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">1</span>, &amp;page_nums) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">2</span>, &amp;out_addr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// check if the page numbers to scan is valid</span></span><br><span class="line">  <span class="keyword">if</span>(page_nums &lt; <span class="number">0</span> || page_nums &gt; <span class="number">64</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uint64 bitmask = <span class="number">0</span>;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; page_nums; i++) &#123;</span><br><span class="line">    <span class="comment">// check if va is out of range</span></span><br><span class="line">    <span class="keyword">if</span>(va &gt;= MAXVA) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get pte addr by va</span></span><br><span class="line">    pte = walk(p-&gt;pagetable, va, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!pte) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check if accessed</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_A) &#123;</span><br><span class="line">      bitmask |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">      <span class="comment">// clear the bit afterwards</span></span><br><span class="line">      *pte ^= PTE_A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// move va to next mem page</span></span><br><span class="line">    va += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// copy bitmask to user space</span></span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, out_addr, (<span class="type">char</span> *)&amp;bitmask, <span class="keyword">sizeof</span>(bitmask)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-5总结"><a href="#3-5总结" class="headerlink" title="3.5总结"></a>3.5总结</h3><p>终于填完所有的坑了,重点就是包含xv6的启动过程,首先kvinit(lock),之后就是kvm.内核启动,包括空间分配还有内核启动时候页表的操作,着重的讲解是如何使用pte来得到物理地址,使用walk可以得到当前va的pte地址,通过指针可以得到值,然后使用maparg来进行映射</p><ol><li>页表简介</li><li>内核态简介</li><li>用户空间简介</li></ol><h2 id="4-lab-trap"><a href="#4-lab-trap" class="headerlink" title="4.lab trap"></a>4.lab trap</h2><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h3 id="4-1回答问题"><a href="#4-1回答问题" class="headerlink" title="4.1回答问题"></a>4.1回答问题</h3><p>Read the code in call.asm for the functions <code>g</code>, <code>f</code>, and <code>main</code>. The instruction manual for RISC-V is on the <a href="https://pdos.csail.mit.edu/6.S081/2020/reference.html">reference page</a>. Here are some questions that you should answer (store the answers in a file answers-traps.txt):</p><blockquote><p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</p></blockquote><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816327874591681632783414.png"></p><p>a2</p><blockquote><p>Where is the call to function <code>f</code> in the assembly code for <code>main</code>? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</p></blockquote><p>显的可以看到在 <code>0x26</code> 位置，程序直接将 <code>12</code> 写入了 <code>a1</code> 寄存器的位置（也就是第二参数 <code>f(8)+1</code> 的位置），在处理完所有的寄存器参数后直接就调用了 <code>printf</code>。那只有一种解释，就是编译器直接计算出了 <code>f(8)+1</code> 的结果是 <code>12</code>，主函数中并没直接调用这两个函数</p><blockquote><p> At what address is the function <code>printf</code> located?</p></blockquote><p>根据提示他在628，我们直接收地址628</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816337731131681633772533.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816338091161681633808486.png"></p><blockquote><p>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</p></blockquote><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816340951881681634095159.png"></p><p><img src="https://blog.rayzhang.top/2022/09/27/mit-6.s081-lab-traps/jalr.png" alt="img"></p><p>34是pc地址，后面的是指令，手册的pc+4，就是34+4&#x3D;38是ra</p><blockquote><p>Run the following code.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">printf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br><span class="line">     </span><br></pre></td></tr></table></figure><p>What is the output? <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set to in order to yield the same output? Would you need to change to a different value?<code>i``57616</code></p><p><a href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p></blockquote><p>57616十六进制是e110</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16816344351111681634434489.png"></p><p>下一个是小段对齐（就是最开始第一位是末尾2个字节，最后的才是开始）</p><p><img src="https://blog.rayzhang.top/2022/09/27/mit-6.s081-lab-traps/hello-world.jpeg" alt="img"></p><blockquote><p>In the following code, what is going to be printed after ? (note: the answer is not a specific value.) Why does this happen? <code>&#39;y=&#39;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;x=%d y=%d&quot;, 3);</span><br></pre></td></tr></table></figure></blockquote><p>a2寄存器没有值，随便产生</p><h3 id="4-2函数调用栈打印"><a href="#4-2函数调用栈打印" class="headerlink" title="4.2函数调用栈打印"></a>4.2函数调用栈打印</h3><h4 id="要求和提示-3"><a href="#要求和提示-3" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>我们在代码调试的过程中为了定位错误的位置，经常需要使用到函数的调用栈打印。当错误发生时，会打印出一系列之前的函数调用信息。</p><p>在这里要求我们需要在 <code>kernel/printf.c</code> 下实现函数 <code>backtrace()</code>，并在 <code>sys_sleep</code> 中插入对此函数的一个调用。当我们在终端中调用 <code>bttest</code> 测试时，该命令会调起 <code>sleep</code> 系统调用，从而触发打印，运行 <code>bttest</code> 时打印结果示例为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">backtrace:</span><br><span class="line">0x0000000080002cda</span><br><span class="line">0x0000000080002bb6</span><br><span class="line">0x0000000080002898</span><br></pre></td></tr></table></figure><p>在 <code>bttest</code> 退出了 QEMU 之后，在终端下，我们也可以使用 <code>addr2line</code> 命令来将指令地址转化为具体的代码位置，例如我们使用指令 <code>addr2line -e kernel/kernel</code>：</p><p>我们的目标是从顶部开始遍历各个栈帧，并将<strong>各个栈帧中保存的返回地址</strong>打印出来。（讲道理感觉做个 <code>-4</code> 打印调用函数的地址可能会更直观一点，但是他说是就是吧）</p><p>相关提示：</p><ul><li><p>需要在 <code>kernel/defs.h</code> 中添加 <code>backtrace</code> 的声明，使得我们可以在 <code>sys_sleep</code> 下调用 <code>backtrace</code>。</p></li><li><p>GCC 编译器将当前执行的函数的栈帧指针 frame pointer 存储在 <code>s0</code> 寄存器中，为此我们需要在 <code>kernel/riscv.h</code> 下加入代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">static inline uint64</span><br><span class="line">r_fp()</span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  asm volatile(&quot;mv %0, s0&quot; : &quot;=r&quot; (x) );</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以方便我们在 <code>backtrace</code> 中调用来读取栈帧的底部地址。</p><blockquote><p>P.S. <code>sp</code> 和 <code>fp</code> 是典型的堆栈寄存器，用来标注当前栈帧的底部和顶部地址，由于我们在描述的时候对顶部和底部往往有自己的理解，因为栈地址是向下增长的，这里还是放一张图会比较好：</p><p><a href="https://blog.rayzhang.top/2022/09/27/mit-6.s081-lab-traps/stack-registers.png"><img src="https://blog.rayzhang.top/2022/09/27/mit-6.s081-lab-traps/stack-registers.png" alt="img"></a></p></blockquote></li><li><p>由刚才贴出的图可见，注意到当前函数的返回地址和当前的 <code>fp</code> 存在一个 <code>-8</code> 的地址偏移量，上一个栈帧的 <code>fp</code> 保存位置和当前的 <code>fp</code> 存在一个 <code>-16</code> 的偏移量。</p></li><li><p>在 xv6 中，操作系统内核会为每个栈分配一个页面的空间，并地址对齐。因此我们可以使用 <code>PGROUNDDOWN(fp)</code> 和 <code>PGROUNDUP(fp)</code> 来寻找栈所在页面的顶部和底部地址，<code>PGROUNDDOWN</code> 和 <code>PGROUNDUP</code> 的定义可以看下 <code>kernel/riscv.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>函数调用栈的实现,我们可以通过这个图可以看到每一个栈的大小是不固定,因为参数可能不一样,但是返回地址,还有上一个节点的地址是ra,和上一个fp是固定的,都是当前的fp-8,还有fp-16,得到这两个的值</p><ol><li>因此我们只需要进行递归地道道当前fp,是不是最上面的地址(pgup(fp))(这是第一个fp),就代表结束</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span> &#123; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  uint64 fp = r_fp();</span><br><span class="line">  <span class="keyword">while</span> (fp != PGROUNDUP(fp)) &#123; <span class="comment">// until get to stack bottom</span></span><br><span class="line">      <span class="comment">// get return addr in current stack frame</span></span><br><span class="line">      uint64 ra = *(uint64 *)(fp - <span class="number">8</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, ra);</span><br><span class="line">      <span class="comment">// go to prev stack frame</span></span><br><span class="line">      fp = *(uint64 *)(fp - <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3实现定时器"><a href="#4-3实现定时器" class="headerlink" title="4.3实现定时器"></a>4.3实现定时器</h3><h4 id="要求和提示-4"><a href="#要求和提示-4" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在本部分中，我们将为 xv6 添加一个新的功能，使得当一个进程使用 CPU 时间的时候周期性的发出警告。这种功能对于想要限制它们占用多少 CPU 时间的计算型进程，或者对于想要计算但又想采取一些定期行动的进程，可能是很有用的。更广泛地说，我们将实现一个原始形式的用户级中断 &#x2F; 故障处理程序；例如，我们可以使用类似的东西来处理应用程序中的页面故障。我们需要通过 <code>alarmtest</code> 来完成该部分。</p><p>我们需要在 xv6 中添加一个新的系统调用 <code>sigalarm(interval, handler)</code>，例如当程序调用 <code>sigalarm(n, fn)</code> 的时候，那么接下来程序每消耗 <code>n</code> 个 ticks 的 CPU 时间后，内核应该调用 <code>fn</code>。当 <code>fn</code> 成功返回时，程序应当继续不受影响的运行，这部分由需要添加的系统调用 <code>sigreturn</code> 负责完成。如果应用程序调用 <code>sigalarm(0, 0)</code>，内核应该停止产生周期性的调用。</p><blockquote><p>P.S. 在 xv6 中，tick 是一个相当随意的时间单位，由硬件定时器产生中断的频率决定。</p></blockquote><p><code>alarmtest</code> 的相关代码在 <code>user/alarmtest.c</code> 中可见，为了使得其能够被正确识别，我们需要将其加入到 Makefile 中，如果对这块已经有点不记得的小伙伴可以看看 Lab Utils，可能可以记起来。</p><p>由于 <code>alarmtest</code> 文件中使用了两个我们待实现的系统调用 <code>sigalarm</code> 和 <code>sigreturn</code>，务必将系统调用正确添加，记不得的小伙伴可以再去看看 Lab Syscall… 后面也会继续提</p><p>在 <code>alarmtest</code> 中在 <code>test0</code> 调用了 <code>sigalarm(2, periodic)</code>，要求内核每隔 2 个 ticks 强制调用 <code>periodic()</code>，然后尝试自旋一段时间。我们可以在 <code>user/alarmtest.asm</code> 中看到 <code>alarmtest</code> 的汇编代码，这可能对调试很有帮助。</p><p>正确运行 <code>alarmtest</code> 和 <code>usertests</code> 的示例结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">$ alarmtest</span><br><span class="line">test0 start</span><br><span class="line">........alarm!</span><br><span class="line">test0 passed</span><br><span class="line">test1 start</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">test1 passed</span><br><span class="line">test2 start</span><br><span class="line">................alarm!</span><br><span class="line">test2 passed</span><br><span class="line">$ usertests</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>这块内容分为两部分完成，我们首先实现 <code>test0</code>，再实现 <code>test1</code> 和 <code>test2</code>。</p><p>对于 <code>test0</code> 而言，其功能是测试 handler 函数是否被正确执行了，首先我们需要修改内核代码使得内核可以跳转到用户空间中的 <code>periodic</code> 函数，从而打印出 <code>&quot;alarm!&quot;</code>。我们在这里暂时不考虑打印之后怎么处理，如果你在打印出 <code>&quot;alarm!&quot;</code> 程序直接 crash 也是完全正常的。以下是关于 <code>test0</code> 的相关提示：</p><ul><li><p>请将 <code>alarmtest.c</code> 加入 Makefile 中，使得其能够被正常编译。</p></li><li><p>两个系统调用需要在 <code>user/user.h</code> 中声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">int sigalarm(int ticks, void (*handler)());</span><br><span class="line">int sigreturn(void);</span><br></pre></td></tr></table></figure></li><li><p>你需要更新 <code>user/usys.pl</code>，<code>kernel/syscall.h</code> 和 <code>kernel/syscall.c</code> 来使得 <code>alarmtest</code> 可以正确的触发 <code>sigslarm</code> 和 <code>sigreturn</code> 系统调用。这块不记得的可以看看 Lab Syscall。</p></li><li><p><code>test0</code> 中对 <code>sys_sigreturn</code> 暂时没有要求，可以返回 <code>0</code> 完事。</p></li><li><p>你的 <code>sys_sigalarm()</code> 需要在 <code>kernel/proc.h</code> 下的 <code>proc</code> 结构体中开辟新的空间额外存储间隔时间和 handler 函数的指针。</p></li><li><p>你需要跟踪从最后一次调用直到下一次调用，过去了（或者说还剩下）多少时间，因此我们也需要在 <code>proc</code> 结构体中开辟额外的空间来实现。初始化 <code>proc</code> 结构体参数的方法详见 <code>kernel/proc.c</code> 下的 <code>allocproc()</code>。</p></li><li><p>每一次 tick 周期，硬件始终都会强制中断，这块的逻辑代码由 <code>kernel/trap.c</code> 下的 <code>usertrap()</code> 实现。</p></li><li><p>在 <code>usertrap()</code> 下，如果我们要控制硬件定时器中断发生时的行为，例如修改 <code>proc</code> 中存储的时间参数，我们只需要关注如下代码下的改动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">if(which_dev == 2)</span><br></pre></td></tr></table></figure></li><li><p>请当进程有一个未完成的定时器时才可调用 handler 函数。注意到 handler 函数的地址可能是 <code>0</code>，例如在 <code>user/alarmtest.asm</code> 中，<code>periodic</code> 位于地址 <code>0</code>。</p></li><li><p>请修改 <code>usertrap()</code> 使得当进程的定时间隔过期时，用户进程可以执行 handler 函数。另外请思考，当在 RISC-V 上的陷阱返回到用户空间时，是什么决定了接下来用户空间代码开始执行的位置？</p></li><li><p>为了方便使用 GDB 观察陷阱的运行，我们可以让 QEMU 只使用一个 CPU，例如运行如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">make CPUS=1 qemu-gdb</span><br></pre></td></tr></table></figure></li><li><p>在本阶段中，只要 <code>alarmtest</code> 成功打印出 <code>&quot;alarm!.&quot;</code> 即为成功</p></li></ul><p>对于 <code>test1</code> 和 <code>test2</code> 而言，其功能主要是测试被中断的代码接下来是否能够继续运行。为了确保程序接下来能够继续正确的运行，我们需要在 handler 函数执行完毕时，返回至被定时器中断的代码位置，同时保证寄存器内容被正确的存储并恢复了。最后我们需要在每次计时结束后重置计时器的计数器，使得 handler 函数能不断的被周期调用。</p><p>我们假定如下的设计：用户空间的 handler 函数在结束时需要调用 <code>sigreturn</code> 系统调用，参考 <code>user/alarmtest.c</code> 的 <code>periodic</code> 函数。这意味着我们需要在 <code>usertrap</code> 和 <code>sys_sigreturn</code> 中进行修改，使得用户空间进程可以正确的继续执行下去。如下为关于 <code>test1</code> 和 <code>test2</code> 的相关提示：</p><ul><li>为了保证被中断程序的正确运行，你需要保存和恢复寄存器。请思考一下，哪些寄存器需要你进行存储和恢复呢？</li><li>在 <code>usertrap</code> 中需要向 <code>proc</code> 结构体中保存一些状态信息，以方便 <code>sigreturn</code> 正确返回到原先的代码位置。</li><li>禁止可重入的调用 handler 函数，在 handler 函数没有返回之前，内核不应当再次调起。关于这块的测试将在 <code>test2</code> 中有所体现。</li></ul><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><img src="https://blog.rayzhang.top/2022/09/27/mit-6.s081-lab-traps/alarm.png" alt="img"></p><p>陷入流程:</p><ol><li>首先是调用systemcall,我们首先设置handler,还有时间</li><li>之后就是始终的定时中断</li><li>我们首先可以在dev&#x3D;2这个地方捕捉到中断信号,我们需要把当前运行pc设置成handler来进行处理,如果当时间满了的情况下</li><li>之后,这个中断结束,但是可能会被其他程序抢走,所以这个程序的trapframe也需要保存下来</li></ol><p>让我们梳理一下题意</p><ol><li>首先完成用户态到内核态陷入,之前的已经写过,跳过</li><li>需要我们在proc的结构体里面添加处理函数handler</li><li>距离下一次调用的时间也需要进行设置</li><li>然后userttrap下面的dev就是定时中断锁需要进行的操作</li><li>现在我们来回顾一下陷入流程</li></ol><hr><p><strong>完成sys_sigalarm</strong></p><p>添加下列参数到proc里面</p><p> p-&gt;alarm_interval &#x3D; ticks;<br>  p-&gt;alarm_handler &#x3D; handler;<br>  p-&gt;alarm_ticks_left &#x3D; ticks;</p><p>主要就是获取参数,然后设置到proc里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">uint64 sys_sigalarm(void) &#123; </span><br><span class="line">  int n;</span><br><span class="line">  uint64 fn;</span><br><span class="line">  if(argint(0, &amp;n) &lt; 0) &#123;</span><br><span class="line">      return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  if(argaddr(1, &amp;fn) &lt; 0) &#123;</span><br><span class="line">      return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  return sigalarm(n, (void(*)())(fn));</span><br><span class="line">&#125;</span><br><span class="line">int sigalarm(int ticks, void (*handler)()) &#123; </span><br><span class="line">  struct proc *p = myproc();</span><br><span class="line">  p-&gt;alarm_interval = ticks;</span><br><span class="line">  p-&gt;alarm_handler = handler;</span><br><span class="line">  p-&gt;alarm_ticks_left = ticks;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完成trap陷入操作</strong></p><p>每一次中断,我们都会让时间减少,而且还要看是不是已经运行了</p><p>所以需要lock参数,我们需要备份trapframe,按照之前的样子,所以还需要</p><p>backtrap,还有lock</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;alarm_interval) &#123; <span class="comment">// if alarm is enalbled</span></span><br><span class="line">      <span class="keyword">if</span>(--p-&gt;alarm_ticks_left &lt;= <span class="number">0</span>) &#123; <span class="comment">// if ticks expired, trigger the handler func</span></span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;alarm_handler_lock) &#123; <span class="comment">// if the handler func is not running</span></span><br><span class="line">          <span class="comment">// save the current trapframe</span></span><br><span class="line">          *p-&gt;alarm_backup = *p-&gt;trapframe;</span><br><span class="line">          <span class="comment">// modify return address</span></span><br><span class="line">          p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarm_handler;</span><br><span class="line">          <span class="comment">// set reentrant lock</span></span><br><span class="line">          p-&gt;alarm_handler_lock = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><hr><p><strong>恢复操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">()</span> &#123; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// restore trapframe</span></span><br><span class="line">  *p-&gt;trapframe = *p-&gt;alarm_backup;</span><br><span class="line">  <span class="comment">// release reentrant lock</span></span><br><span class="line">  p-&gt;alarm_handler_lock = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4总结"><a href="#4-4总结" class="headerlink" title="4.4总结"></a>4.4总结</h3><p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MKFsfImgYCtnwA1d2hO%2F-MKHxleUqYy-y0mrS48w%2Fimage.png?alt=media&token=ab7c66bc-cf61-4af4-90fd-1fefc96c7b5f" alt="img"></p><p>总体流程</p><ol><li>首先调用ecall</li><li>之后是uservec(内核执行的第一个程序,trampoline是一部分,保存页表)</li><li>然后才是转到c语言的usertrap,开始查看是什么类型的原因到内核态(trap,interupt还是page fault)</li><li>陷入之后是system call,调用实际的底层函数</li></ol><p>ecall作用详解:</p><ol><li><p>第一，ecall将代码从user mode改到supervisor mode。</p></li><li><p>第二，ecall将程序计数器的值保存在了SEPC寄存器。我们可以通过打印程序计数器看到这里的效果，</p></li><li><p>ecall跳转到stvec</p></li></ol><p>在trampoline page详解:</p><ol><li>修改vec的代码</li><li>保存寄存器等其他信息trapframe</li></ol><p>主要就是保存你用户的页表</p><p>usertrap详解:</p><p>找到是什么类型,来进行对应出路i</p><p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MLhY-FzqA_AFTTcuD6U%2F-MLjZNai3dy2h5fFhLXf%2Fimage.png?alt=media&token=f1e670c2-97f6-471a-a0f1-76dace363806" alt="img"></p><p>sertrap函数的最后调用了usertrapret函数，来设置好我之前说过的，在返回到用户空间之前内核要做的工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存相关的内核信息到trapframe,然后再次进入到trampoline,进行恢复用户的页表</p><p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MLhY-FzqA_AFTTcuD6U%2F-MLjbaxkbJ9sBUszhiaX%2Fimage.png?alt=media&token=fefe6012-0e8b-4f4d-b044-c25b62d5f0fd" alt="img"></p><p>接下来的几行填入了trapframe的内容，这些内容对于执行trampoline代码非常有用。这里的代码就是：</p><p>- </p><p>  存储了kernel page table的指针</p><p>- </p><p>  存储了当前用户进程的kernel stack</p><p>- </p><p>  存储了usertrap函数的指针，这样trampoline代码才能跳转到这个函数（注，详见6.5中 <em>ld t0 (16)a0</em> 指令）</p><p>- </p><p>  从tp寄存器中读取当前的CPU核编号，并存储在trapframe中，这样trampoline代码才能恢复这个数字，因为用户代码可能会修改这个数字</p><p>实际上，我们会在汇编代码trampoline中完成page table的切换，并且也只能在trampoline中完成切换，因为只有trampoline中代码是同时在用户和内核空间中映射</p><p><img src="https://img2023.cnblogs.com/blog/1942408/202303/1942408-20230301194532035-432919191.png" alt="img"></p><h2 id="5-cow"><a href="#5-cow" class="headerlink" title="5.cow"></a>5.cow</h2><p>写时候分配,大致意识fork的时候,不进行分配,使用与父亲的一起共享的内存,当这篇内存要写入的时候,出发page fault,在进行分配,分配主要包括,给内存释放权限,还有重新进行开辟一个新空间</p><p><img src="https://blog.rayzhang.top/2022/10/01/mit-6.s081-lab-cow/cow.png" alt="img"></p><h3 id="5-1实现-COW-下的-fork"><a href="#5-1实现-COW-下的-fork" class="headerlink" title="5.1实现 COW 下的 fork"></a>5.1实现 COW 下的 <code>fork</code></h3><h4 id="要求和提示-5"><a href="#要求和提示-5" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在本部分中，我们的任务是在 xv6 操作系统中实现一个写时复制的 <code>fork</code>。完成的代码需要通过 <code>cowtest</code> 和 <code>usertests</code> 测试。<code>cowtest</code> 中的相关测试样例详见 <code>user/cowtest.c</code>。</p><p>例如，如果我们对 xv6 操作系统一开始什么都没做修改，就直接执行 <code>cowtest</code>，我们会得到如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">$ cowtest</span><br><span class="line">simple: fork() failed</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><p>这是因为在 <code>simple</code> 测试样例中，它分配了超过一半的可用物理内存空间，随后调用 <code>fork</code>。在没有实现 COW 的 xv6 下，操作系统会采取 eager 策略，立即为子进程创建对应用户空间并着手复制，这会直接导致物理内存空间的耗尽。</p><p>为了实现 COW 我们要在以下几处完成修改：</p><ul><li>修改 <code>kernel/vm.c</code> 下的 <code>uvmcopy()</code> 函数，我们需要共享父进程和子进程的用户空间，而非重新分配新的内存。此外，我们还需要将子进程和父进程的 PTE 置为只读，以触发缺页中断 page fault。</li><li>修改 <code>kernel/trap.c</code> 下的 <code>usertrap()</code> 函数，使得内核可以正确的判断出发生了缺页中断 page fault。一旦内核识别出在一个 COW 内存页上发生了缺页中断，就需要使用 <code>kalloc()</code> 开辟新的内存页，并将原内存页的数据拷贝到新的内存页上，并设置新的映射关系，将 PTE 下的可读 <code>PTE_W</code> 置位。</li><li>我们需要确保当该物理页面最后的 PTE 引用 ref count 清零了才可将其进行释放。当 <code>kernel/kalloc.c</code> 下的 <code>kalloc()</code> 分配该内存页时我们就将其 ref count 设置为 <code>1</code>，每当有 <code>fork</code> 操作使得子进程共享该内存页时我们就将 ref count 加一，同理每当一个进程将对应映射关系从其页表中删除时，我们就要将 ref count 减一。只有当 ref count 清零的时候我们才可以将当前内存页使用 <code>kernel/kalloc.c</code> 下的 <code>kfree()</code> 放置在空闲列表中。我们可以把这些计数的 ref count 放在一个固定大小的整数数组中，例如我们可以使用页面的物理地址除以 <code>4096</code> 来索引数组，然后给数组一个等同于 <code>kalloc.c</code> 中 <code>kinit()</code> 放置在空闲列表中页面的最高物理地址的元素数。</li><li>不要忘记修改 <code>kernel/vm.c</code> 下的 <code>copyout()</code>，来适应 COW 的内存页，因为可能有用户空间下的内存页暂未被分配，原先的 <code>copyout</code> 也会触发 page fault。</li></ul><p>相关提示：</p><ul><li><p>我们很有可能需要标记当前的 PTE 为 COW 内存页映射，因此我们可以使用 RSW（reserved for software）标识位来实现：</p><p><a href="https://blog.rayzhang.top/2022/10/01/mit-6.s081-lab-cow/rsw-bits.png"><img src="https://blog.rayzhang.top/2022/10/01/mit-6.s081-lab-cow/rsw-bits.png" alt="img"></a></p></li><li><p>一些有用的宏和定义可以方便处理 PTE 的相关标识位，这些代码在 <code>kernel/riscv.h</code> 的最后可以找到。</p></li><li><p>如果 COW 下的缺页中断产生了，但是也没有足够的物理内存空间，那么进程应当被杀死。</p></li></ul><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>提示已经给了很多信息,我们把提示在进行翻译一遍</p><p>这个rsw标记需要我们自己手动来做</p><p><img src="https://blog.rayzhang.top/2022/10/01/mit-6.s081-lab-cow/rsw-bits.png" alt="img"></p><ol><li>首先修改uvmcopy,不是分配,二十把这个新地址还是映射到同一个物理地址,之前的map函数,同时设置不能写,符号</li><li>然后修改trap,因为会出发page_fault,这样我们需要解开原来的映射,然后进行kalloc分配,新的还要加入写入权限**(注意,解开原来映射的时候,会消灭原始内存,因此需要引用计数)**</li><li>之后就是应用计数的相关设置</li><li>然后设置copy的配置</li></ol><blockquote><p>们可以把这些计数的 ref count 放在一个固定大小的整数数组中，例如我们可以使用页面的物理地址除以 <code>4096</code> 来索引数组，然后给数组一个等同于 <code>kalloc.c</code> 中 <code>kinit()</code> 放置在空闲列表中页面的最高物理地址的元素数。</p></blockquote><p>设置页面数组,来统计每一个页面使用的次数,当然还是要进行枷锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> refcount_arr[(PHYSTOP - KERNBASE) / PGSIZE];</span><br><span class="line">&#125; refcount;</span><br></pre></td></tr></table></figure><p>刚开始就是初始化,维1此使用,之后就是设置++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">refcount_add</span><span class="params">(uint64 va, <span class="type">int</span> add)</span> &#123; </span><br><span class="line">  <span class="type">int</span> index = (va - KERNBASE) / PGSIZE;</span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  <span class="type">int</span> res = refcount.refcount_arr[index];</span><br><span class="line">  res += add;</span><br><span class="line">  refcount.refcount_arr[index] = res;</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">refcount_set</span><span class="params">(uint64 va, <span class="type">int</span> ref)</span> &#123; </span><br><span class="line">  <span class="type">int</span> index = (va - KERNBASE) / PGSIZE; </span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  refcount.refcount_arr[index] = ref;</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就是freerange来开始设置</p><p>,因为他调用了kfree</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int refcount_add(uint64 va, int add) &#123; </span><br><span class="line">  int index = (va - KERNBASE) / PGSIZE;</span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  int res = refcount.refcount_arr[index];</span><br><span class="line">  res += add;</span><br><span class="line">  refcount.refcount_arr[index] = res;</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void refcount_set(uint64 va, int ref) &#123; </span><br><span class="line">  int index = (va - KERNBASE) / PGSIZE; </span><br><span class="line">  acquire(&amp;refcount.lock);</span><br><span class="line">  refcount.refcount_arr[index] = ref;</span><br><span class="line">  release(&amp;refcount.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是设置uvmcopy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define PTE_V (1L &lt;&lt; 0) // valid</span><br><span class="line">#define PTE_R (1L &lt;&lt; 1)</span><br><span class="line">#define PTE_W (1L &lt;&lt; 2)</span><br><span class="line">#define PTE_X (1L &lt;&lt; 3)</span><br><span class="line">#define PTE_U (1L &lt;&lt; 4) // 1 -&gt; user can access</span><br><span class="line">#define PTE_COW (1L &lt;&lt; 8) // 1 -&gt; set as cow page</span><br></pre></td></tr></table></figure><p>设置维rsw,并且只能读取,还有进行映射地址,还有应用加一</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    <span class="keyword">if</span> (*pte &amp; PTE_W) &#123; <span class="comment">// if the page is writable</span></span><br><span class="line">        *pte ^= PTE_W; <span class="comment">// disable write flag</span></span><br><span class="line">        *pte |= PTE_COW; <span class="comment">//setup COW flag</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map pagetable to same physical addr in the new processs</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)pa, PTE_FLAGS(*pte)) != <span class="number">0</span>)&#123;</span><br><span class="line">      uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// increace ref for page share</span></span><br><span class="line">    refcount_add(pa, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在这里对这个物理页面进行加1此使用</p><p><img src="https://blog.rayzhang.top/2022/10/01/mit-6.s081-lab-cow/scause.png" alt="img"></p><p>通过这个我们知道13还有15是page fault原因,我们新建一个copycow来进行解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">else if (r_scause() == 15) &#123;</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    if(copycow(p-&gt;pagetable, va) &lt; 0) &#123;</span><br><span class="line">      p-&gt;killed = 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>copycow,才是真实的</p><p>分配代码</p><ol><li>检查pte的标识</li><li>接触原始映射</li><li>然后kalloc</li><li>copy内容</li><li>之后在世新的映射,和之前原来的uvmcopy差不多</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy cow page,</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure, -2 on invalid va</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copycow</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> (va &gt;= MAXVA) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;va cannot be greater than MAXVA: %p\n&quot;</span>, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  uint64 mem;</span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line">  <span class="type">pte_t</span> *pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  uint64 pa = PTE2PA(*pte);</span><br><span class="line">  uint flags = PTE_FLAGS(*pte);</span><br><span class="line">  <span class="keyword">if</span> (!(*pte &amp; PTE_COW))&#123; <span class="comment">// check if page is COW page</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Not a COW page. Invalid va: %p\n&quot;</span>, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(mem = (uint64)kalloc()))&#123; <span class="comment">// kalloc new page</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Failed to allocate physical page.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  memmove((<span class="type">void</span> *)mem, (<span class="type">void</span> *)pa, PGSIZE); <span class="comment">//copy to new page</span></span><br><span class="line">  flags ^= PTE_COW | PTE_W; <span class="comment">// setup write flag, disable COW flag</span></span><br><span class="line">  uvmunmap(pagetable, va, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// cancel original pagetable map which caused page fault</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(pagetable, va, PGSIZE, mem, flags) != <span class="number">0</span>) &#123; <span class="comment">// remap va to new page</span></span><br><span class="line">    kfree((<span class="type">void</span>*)mem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了kalloc,还有kfree,会对这个页面进行初始化维1,然后减少一次,知道这个页面还有用,才不会清楚</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(refcount_add((uint64)pa,<span class="number">-1</span>,<span class="number">0</span>)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 还有引用直接推出</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r) </span><br><span class="line">    refcount_set((uint64)r, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Free the page of physical memory pointed at by v,</span><br><span class="line">// which normally should have been returned by a</span><br><span class="line">// call to kalloc().  (The exception is when</span><br><span class="line">// initializing the allocator; see kinit above.)</span><br><span class="line">void</span><br><span class="line">kfree(void *pa)</span><br><span class="line">&#123;</span><br><span class="line">  struct run *r;</span><br><span class="line"></span><br><span class="line">  if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(&quot;kfree&quot;);</span><br><span class="line">  </span><br><span class="line">  if (refcount_add((uint64)pa, -1) &gt; 0) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Fill with junk to catch dangling refs.</span><br><span class="line">  memset(pa, 1, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改 <code>copyout</code> 函数</strong></p><p>这点也在刚才的提示中贴心的点出<strong>来了，由于我们的 COW 页面是只读状态，那么在 <code>kernel/vm.c</code> 下的 <code>copyout</code> 函数需要进行修改。因为这个函数负责的是将一些数据从内核态复制到用户态，按照原先 xv6 的设置，<code>copyout</code> 是不可能预见到内存空间中的内存页只读的。</strong></p><p>修改的办法也说不上很难，在我们通过 walk 页表取得 PTE 后先不着急转化成物理地址，而是先看一下这个 PTE 的 COW 标识位，如果有标识位那直接使用刚才的 <code>copycow</code> 函数，一通操作，复制到新页面修改，映射到新的物理地址映射，再继续接下来的操作：</p><ol><li>首先得到pte</li><li>看pte有没有rsw,悠久调用cow来进行分配</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pte_t *pte = walk(pagetable, va0, 0);</span><br><span class="line">    if(!pte) &#123;</span><br><span class="line">      printf(&quot;Failed to get pa from pgtbl. va: %p\n&quot;, va0);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(*pte &amp; PTE_cow)&#123;</span><br><span class="line">      if(copycow(pagetable, va0) &lt; 0)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from kernel to user.</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dstva &gt;= MAXVA)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;dstva cannot be greater than MAXVA: %p\n&quot;</span>, dstva);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    <span class="type">pte_t</span> *pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!pte) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Failed to get pa from pgtbl. va: %p\n&quot;</span>, va0);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_COW)&#123;</span><br><span class="line">      <span class="keyword">if</span>(copycow(pagetable, va0) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总体来说，这一个是抄的别人写的博客。大致的原理，就是不分配内存，通过cow来分配，但是细节太麻烦了。</p><h2 id="6-thread"><a href="#6-thread" class="headerlink" title="6.thread"></a>6.thread</h2><h3 id="用户线程切换"><a href="#用户线程切换" class="headerlink" title="用户线程切换"></a>用户线程切换</h3><h4 id="要求和提示-6"><a href="#要求和提示-6" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在本部分中我们将设计并实现用户级别下的线程上下文切换。开始前可以阅读 <code>user/uthread.c</code> 和 <code>uthread_switch.S</code> 下的代码，这两个文件实现了线程切换的大致框架和简单的功能测试代码，我们需要补全剩余部分。</p><p>注意到我们需要想办法创造线程并在线程切换的过程中尝试保存 &#x2F; 恢复寄存器，事后如果功能实现，可以在 xv6 下运行 <code>uthread</code>，正确运行示例如下（三个线程的顺序可能会有出入）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">$ uthread</span><br><span class="line">thread_a started</span><br><span class="line">thread_b started</span><br><span class="line">thread_c started</span><br><span class="line">thread_c 0</span><br><span class="line">thread_a 0</span><br><span class="line">thread_b 0</span><br><span class="line">thread_c 1</span><br><span class="line">thread_a 1</span><br><span class="line">thread_b 1</span><br><span class="line">...</span><br><span class="line">thread_c 99</span><br><span class="line">thread_a 99</span><br><span class="line">thread_b 99</span><br><span class="line">thread_c: exit after 100</span><br><span class="line">thread_a: exit after 100</span><br><span class="line">thread_b: exit after 100</span><br><span class="line">thread_schedule: no runnable threads</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>终端上的输出来自三个测试线程，每个线程都会进入一个循环，在循环中打印一行随后让出 CPU 给其他线程。但是由于现在我们还没有加入实现上下文切换的代码，我们是看不到输出的。</p><p>我们需要向 <code>user/uthread.c</code> 下的 <code>thread_create()</code> 和 <code>thread_schedule()</code> 中，以及 <code>user/uthread_switch.S</code> 下的 <code>thread_switch</code> 加入代码，从名字里看得出来，我们需要实现线程的创建和切换功能…</p><p>我们有两个目标需要实现，一个是我们需要确保当 <code>thread_schedule()</code> 第一次运行一个给定的线程时，该线程在自己的堆栈中执行 <code>thread_create()</code> 中给定的函数参数；另外一个是，确保 <code>thread_switch</code> 保存被切换走的线程寄存器，并恢复被切换到的线程寄存器，随后返回到切换过来的线程的指令中最后离开的位置。</p><p>我们需要决定在哪里存储 &#x2F; 恢复寄存器，尝试修改结构体 <code>struct thread</code> 会是一个很好的主意。此外，我们需要在 <code>thread_switch</code> 中加入调用 <code>thread_schedule</code>（这玩意儿只有汇编代码），可以在调用时传入我们想要的任何参数，只要能从线程 <code>t</code> 切换到 <code>next_thread</code>。</p><p>相关提示：</p><ul><li>在 <code>thread_switch</code> 中我们只需要保存和恢复 callee-save 寄存器。</li><li>我们可以参考编译后根据 <code>uthread.c</code> 生成的 <code>user/uthread.asm</code> 汇编代码，以方便调试。</li><li>为了测试代码，使用 <code>riscv64-linux-gnu-gdb</code> 单步浏览 <code>thread_switch</code> 可能会有帮助。相关的 GDB 调试技巧，已经在 Lecture 5 介绍过了，也可以再去熟悉下。</li></ul><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>写这一个代码就是为了让我们更深入的了解，线程是如何进行切换。</p><p><img src="https://pic2.zhimg.com/v2-b732485b8ee0ccae1cc989d7d426959d_b.jpg" alt="img"></p><p>基础知识：线程切换</p><ol><li>shell通过中断进入内核态</li><li>执行yield操作，进行让位</li><li>使用swtch算法找到一个合适的</li><li>最后使用usertrapret进行返回</li></ol><p>因为要和寄存器直接打交道，所以 xv6 选择汇编来完成，而不是 C 。相比于 C ，汇编更适合操纵寄存器，使用swtch来进行保存</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Context switch</span><br><span class="line">#</span><br><span class="line">#   void swtch(struct context *old, struct context *new);</span><br><span class="line"># </span><br><span class="line"># Save current registers in old. Load from new. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">        sd ra, 0(a0)</span><br><span class="line">        sd sp, 8(a0)</span><br><span class="line">        sd s0, 16(a0)</span><br><span class="line">        ...</span><br><span class="line">        sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, 0(a1)</span><br><span class="line">        ld sp, 8(a1)</span><br><span class="line">        ld s0, 16(a1)</span><br><span class="line">        ...</span><br><span class="line">        ld s11, 104(a1)</span><br><span class="line"></span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>保存当前的上下文，之后就是调度</p><p>理解了上面知识，我们知道我们这一届需要做什么了。我们就是自己模仿swtch操作，因为进程信息只有内核态可以看见，所以我们需要把这个信息传入到外面的线程数组，直接用数组来进行调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct thread_context &#123;</span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  // callee-saved</span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line">struct thread &#123;</span><br><span class="line">  char       stack[STACK_SIZE]; /* the thread&#x27;s stack */</span><br><span class="line">  int        state;             /* FREE, RUNNING, RUNNABLE */</span><br><span class="line">  struct thread_context context; /* thread context to save/restore reg */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后的调度程序直接抄汇编的swtch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">         * save the old thread&#x27;s registers,</span><br><span class="line">         * restore the new thread&#x27;s registers.</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">/* YOUR CODE HERE */</span><br><span class="line">    sd ra, 0(a0)</span><br><span class="line">    sd sp, 8(a0)</span><br><span class="line">    sd s0, 16(a0)</span><br><span class="line">    sd s1, 24(a0)</span><br><span class="line">    sd s2, 32(a0)</span><br><span class="line">    sd s3, 40(a0)</span><br><span class="line">    sd s4, 48(a0)</span><br><span class="line">    sd s5, 56(a0)</span><br><span class="line">    sd s6, 64(a0)</span><br><span class="line">    sd s7, 72(a0)</span><br><span class="line">    sd s8, 80(a0)</span><br><span class="line">    sd s9, 88(a0)</span><br><span class="line">    sd s10, 96(a0)</span><br><span class="line">    sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">    ld ra, 0(a1)</span><br><span class="line">    ld sp, 8(a1)</span><br><span class="line">    ld s0, 16(a1)</span><br><span class="line">    ld s1, 24(a1)</span><br><span class="line">    ld s2, 32(a1)</span><br><span class="line">    ld s3, 40(a1)</span><br><span class="line">    ld s4, 48(a1)</span><br><span class="line">    ld s5, 56(a1)</span><br><span class="line">    ld s6, 64(a1)</span><br><span class="line">    ld s7, 72(a1)</span><br><span class="line">    ld s8, 80(a1)</span><br><span class="line">    ld s9, 88(a1)</span><br><span class="line">    ld s10, 96(a1)</span><br><span class="line">    ld s11, 104(a1)</span><br><span class="line">ret    /* return to ra */</span><br></pre></td></tr></table></figure><p>实现Switch操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void </span><br><span class="line">thread_schedule(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct thread *t, *next_thread;</span><br><span class="line"></span><br><span class="line">  /* Find another runnable thread. */</span><br><span class="line">  next_thread = 0;</span><br><span class="line">  t = current_thread + 1;</span><br><span class="line">  for(int i = 0; i &lt; MAX_THREAD; i++)&#123;</span><br><span class="line">    if(t &gt;= all_thread + MAX_THREAD)</span><br><span class="line">      t = all_thread;</span><br><span class="line">    if(t-&gt;state == RUNNABLE) &#123;</span><br><span class="line">      next_thread = t;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    t = t + 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (next_thread == 0) &#123;</span><br><span class="line">    printf(&quot;thread_schedule: no runnable threads\n&quot;);</span><br><span class="line">    exit(-1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (current_thread != next_thread) &#123;         /* switch threads?  */</span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    /* YOUR CODE HERE</span><br><span class="line">     * Invoke thread_switch to switch from t to next_thread:</span><br><span class="line">     * thread_switch(??, ??);</span><br><span class="line">     */</span><br><span class="line">    thread_switch((uint64)&amp;t-&gt;context, (uint64)&amp;next_thread-&gt;context);</span><br><span class="line">  &#125; else</span><br><span class="line">    next_thread = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><h4 id="要求和提示-7"><a href="#要求和提示-7" class="headerlink" title="要求和提示"></a>要求和提示</h4><p><strong>注意：本部分实验需要在有多核心处理器的 Linux&#x2F;macOS 电脑中完成，而不是在 xv6&#x2F;QEMU 下完成。</strong></p><p>在本部分实验中，我们将使用多线程编程和锁来实现一个 HashTable 哈希表。在本次作业中我们将使用 UNIX 下的 <code>pthread</code> 库函数，关于 <code>pthreads</code> 的更多用法，可以查询 man 手册，终端上输入 <code>man pthreads</code> 即可，也可查询相关网页。</p><p>文件 <code>notxv6/ph.c</code> 中实现了一个仅在单线程下可行的哈希表，但是在多线程下运行就会产生错误。我们在主目录下运行 <code>make ph</code>，随后向可执行文件中传入线程数量作为参数，例如单线程执行<code>./ph 1</code> 即可。示例如下：</p><p><code>ph</code> 程序中主要尝试运行两项测试，首先它通过 <code>put()</code> 尝试向哈希表中加入大量的 key，并打印出平均每秒钟执行 <code>put</code> 的数量，随后它尝试使用 <code>get()</code> 从哈希表中将 key 取出，并打印出哈希表中的 key 的数量。但是很显然目前由于没有对多线程去做额外的实现，部分的 <code>put</code> 操作丢失了，如下是程序未修改的情况下两个线程执行 <code>ph</code> 的结果，我们看到线程 <code>put()</code> 操作丢失了一些 key：</p><p>虽然使用两个线程使得哈希表插入的平均速度翻倍，但是带来了严重的数据丢失问题，这就是个很严重的问题需要我们解决。请仔细阅读 <code>notxv6/ph.c</code>，尤其是文件下的 <code>put()</code> 和 <code>insert()</code> 函数。</p><p>两个线程同时执行 <code>put()</code> 导致 key 丢失的原因是什么？请将作业答案保存在主目录下 <code>answers-thread.txt</code> 下。</p><p>为了确保相关时间的有序执行，我们需要在 <code>put()</code> 和 <code>get()</code> 中引入加锁和解锁机制。相关的 <code>pthread</code> 函数调用有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">pthread_mutex_t lock;            // declare a lock</span><br><span class="line">pthread_mutex_init(&amp;lock, NULL); // initialize the lock</span><br><span class="line">pthread_mutex_lock(&amp;lock);       // acquire lock</span><br><span class="line">pthread_mutex_unlock(&amp;lock);     // release lock</span><br></pre></td></tr></table></figure><p>记得不要忘记调用 <code>pthread_mutex_init()</code>。在这部分操作结束后，你应该可以顺利通过 <code>ph_safe</code> 测试，即不会有 key 丢失的状况存在。</p><p>接下来，我们尝试对哈希表的速度进行优化，在操作中有部分 <code>put()</code> 对内存的操作并无重叠部分，也许不需要一把很大的锁来保护哈希表（疯狂暗示减小锁的粒度），我们需要对 <code>ph.c</code> 做出额外的变动进而加速 <code>put()</code> 操作（提示：可以对每个哈希桶 bucket 各设置一把锁）。在这部分操作结束后，我们将通过 <code>ph_fast</code> 测试，该测试要求两个线程产生的 <code>put()</code> 速率是一个线程的 1.25 倍。</p><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><blockquote><ol><li>优化成多线程</li><li>资源共享（需要加锁）</li><li>只有在oput的时候才需要上锁</li><li>注意到这里分块了bucket，所以每一个bucket都要上锁</li><li>每次对于一个bucket进行操作的时候，上锁put</li></ol></blockquote><p>struct entry {</p><p> int key;</p><p> int value;</p><p> struct entry *next;</p><p>};</p><p>struct entry *table[NBUCKET];</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct entry &#123;</span><br><span class="line">  int key;</span><br><span class="line">  int value;</span><br><span class="line">  struct entry *next;</span><br><span class="line">&#125;;</span><br><span class="line">struct entry *table[NBUCKET];</span><br><span class="line"></span><br><span class="line">static </span><br><span class="line">void put(int key, int value)</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  int i = key % NBUCKET;</span><br><span class="line">  // 对每一个bucket上锁</span><br><span class="line">   pthread_mutex_lock(&amp;locks[i]);</span><br><span class="line">  // is the key already present?</span><br><span class="line">  struct entry *e = 0;</span><br><span class="line">  for (e = table[i]; e != 0; e = e-&gt;next) &#123;</span><br><span class="line">    if (e-&gt;key == key)</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  if(e)&#123;</span><br><span class="line">    // update the existing key.</span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // the new is new.</span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  // release</span><br><span class="line">    pthread_mutex_unlock(&amp;locks[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现同步屏障"><a href="#实现同步屏障" class="headerlink" title="实现同步屏障"></a>实现同步屏障</h3><h4 id="要求和提示-8"><a href="#要求和提示-8" class="headerlink" title="要求和提示"></a>要求和提示</h4><p><strong>注意：本部分实验需要在有多核心处理器的 Linux&#x2F;macOS 电脑中完成，而不是在 xv6&#x2F;QEMU 下完成。</strong></p><p>在这个部分中，我们需要实现一个同步屏障。也就是程序中的一个位置，所有参与的线程都需要等待直到所有其他线程都到达这个位置。我们将使用 <code>pthread</code> 提供的条件变量，他的机制类似于 xv6 中的 <code>sleep</code> 和 <code>wakeup</code>，我们将使用到下面这两个调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);  // go to sleep on cond, releasing lock mutex, acquiring upon wake up</span><br><span class="line">pthread_cond_broadcast(&amp;cond);     // wake up every thread sleeping on cond</span><br></pre></td></tr></table></figure><p>其中，<code>pthread_cond_wait</code> 在被调用时释放了 <code>mutex</code>，并在返回前重新获取了 <code>mutex</code>。</p><p>在 <code>notxv6/barrier.c</code> 下存在一个没有实现好的同步屏障，如果在没有修改的情况下运行，运行就会报错：</p><p><a href="https://blog.rayzhang.top/2022/10/07/mit-6.s081-lab-thread/barrier-err.png"><img src="https://blog.rayzhang.top/2022/10/07/mit-6.s081-lab-thread/barrier-err.png" alt="img"></a></p><p>其中我们给 <code>barrier</code> 传入的第二个参数表示的是需要在同步屏障上进行同步的线程数量。每个线程都在执行一个循环，在每个循环中线程会调用 <code>barrier()</code> 然后随机睡眠若干微秒。刚才未修改的代码导致断言被触发，是因为一个线程在另一个线程到达同步屏障前就离开了。我们希望每个线程都在 <code>barrier()</code> 位置阻塞，直到 <code>nthreads</code> 个线程都调用过了 <code>barrier()</code>。</p><p>在 <code>notxv6/barrier.c</code> 中，<code>barrier_init()</code> 已经被给出，结构体 <code>struct barrier</code> 已经定义，仅供参考。我们只需要实现 <code>barrier()</code> 相关功能，以此来确保不会报错。</p><p>注意两个较难实现的点：</p><ul><li>我们需要处理一连串的 <code>barrier()</code> 调用，我们把这个叫做一轮。<code>bstate.round</code> 中记录了轮数，因此每当所有线程到达内存屏障的时候我们就需要将计数加一。</li><li>小心处理 <code>bstate.nthread</code>，尤其这种情形：一个线程离开了同步屏障，其他线程还没反应过来，就进入了下一轮循环，然后又遇到了同步屏障，直接对计数加一。上一轮和下一轮的计数要分清楚。</li></ul><blockquote><p>打字已实施，只有人气了，才会对论述进行+1，不齐就是阻塞。只有齐了才全部唤醒，操作也要上锁</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static void </span><br><span class="line">barrier()</span><br><span class="line">&#123;</span><br><span class="line">  // YOUR CODE HERE</span><br><span class="line">  //</span><br><span class="line">  // Block until all threads have called barrier() and</span><br><span class="line">  // then increment bstate.round.</span><br><span class="line">  //</span><br><span class="line">  </span><br><span class="line">  // protect nthread counter</span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  if (++bstate.nthread &lt; nthread) &#123;</span><br><span class="line">    // sleep if not all threads have reached the barrier</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // clear bstate.nthread</span><br><span class="line">    bstate.nthread = 0;</span><br><span class="line">    // imcrement on round count</span><br><span class="line">    bstate.round++;</span><br><span class="line">    // wake up all other threads</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>今天的实验还是比较简单，都是直接按照的讲授的内容锁撰写的。只需要明lock还有调度相关原理即可，基本可以实现。</p><h2 id="7-lock"><a href="#7-lock" class="headerlink" title="7.lock"></a>7.lock</h2><h3 id="内存分配器加速"><a href="#内存分配器加速" class="headerlink" title="内存分配器加速"></a>内存分配器加速</h3><h4 id="要求和提示-9"><a href="#要求和提示-9" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在 <code>user/kalloctest.c</code> 下我们实现了一个测试，在这个测试中针对 xv6 的内存分配器进行了重点测试，使用了三个进程大量的对地址空间进行增加和缩小，导致大量对 <code>kalloc</code> 和 <code>kfree</code> 的调用，其中 <code>kalloc</code> 和 <code>kfree</code> 在执行时均需要获取锁 <code>kmem.lock</code>。在这里我们使用 <code>kalloctest</code> 打印了由于另一进程已经持有了锁而在尝试自旋获取的次数，在这里使用<code>#fetch-and-add</code> 打印进行表示。需要指出的是，自旋的次数只能作为锁冲突的一种粗略的衡量。如果我们还没有对当前的 Lab 做出修改，我们执行 <code>kalloctest</code> 会得到如下类似的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">$ kalloctest</span><br><span class="line">start test1</span><br><span class="line">test1 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: #fetch-and-add 83375 #acquire() 433015</span><br><span class="line">lock: bcache: #fetch-and-add 0 #acquire() 1260</span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: kmem: #fetch-and-add 83375 #acquire() 433015</span><br><span class="line">lock: proc: #fetch-and-add 23737 #acquire() 130718</span><br><span class="line">lock: virtio_disk: #fetch-and-add 11159 #acquire() 114</span><br><span class="line">lock: proc: #fetch-and-add 5937 #acquire() 130786</span><br><span class="line">lock: proc: #fetch-and-add 4080 #acquire() 130786</span><br><span class="line">tot= 83375</span><br><span class="line">test1 FAIL</span><br></pre></td></tr></table></figure><p>可以看到 <code>acquire</code> 针对每一个锁，打印出了当前锁的调用次数（<code>#acquire()</code> 后），以及为了获取锁失败而产生的自旋次数（<code>#fetch-and-add()</code> 后）。<code>kalloctest</code> 通过调用系统调用，要求内核为 <code>kmem</code> 和 <code>bcache</code> 打印相关的计数信息，以及 5 个竞争最激烈的锁。如果发生了锁竞争，那么自旋的次数就会很大。由于在这部分实验中，我们比较关心 <code>kmem</code> 和 <code>bcache</code> 两个锁的性能，系统调用最后会返回这两个锁上发生的自旋次数的总和。</p><p>需要注意到的是，为了完成当前的 Lab，我们需要使用一台多核心独立无负载的机器。如果使用的机器上面有其他的工作负载，<code>kalloctest</code> 打印出的计数次数就会失去意义。</p><p>现在让我们来关注代码，在 <code>kalloctest</code> 中产生大量锁冲突的根本原因是 <code>kalloc()</code> 只有一个空闲列表。为了尽可能的规避锁冲突，我们需要重新设计内存分配器来避免一个唯一的锁和空闲列表。有一个很简单的想法，我们在每个 CPU 核心中都维护一个空闲列表，每个空闲列表有自己的锁。这样下来，在不同 CPU 下的内存分配和释放就可以并行运行，因为每个 CPU 都操作的是不同的空闲列表。这个想法实现下来最大的困难是，如何处理如下情形，一个 CPU 的空闲列表已经空了，但是另一个 CPU 仍然有空闲的内存。为了处理这样的情形，我们的 CPU 需要从别的 CPU 的空闲列表中 “偷出” 一部分空闲内存。这种 “偷窃内存” 也有可能引入锁冲突，但是希望这样会少频繁一些。</p><p>我们需要做的事情总结下来就是为每个 CPU 维护空闲列表，并当空闲列表空时从其他 CPU 处 “偷取” 空余内存。也就是说，我们需要为我们的每一个列表的锁都调用 <code>initlock</code>，并将名字设置为 <code>kmem</code> 开头。我们需要运行 <code>kalloctest</code> 来查看我们的实现是否减少了锁的竞争，此外为了确保实现没有问题我们还能正确分配所有的内存，我们需要运行 <code>usertests sbrkmuch</code> 测试。我们需要通过 <code>test1</code> 和 <code>test2</code> 测试，测试的相关输出示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">$ kalloctest</span><br><span class="line">start test1</span><br><span class="line">test1 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: #fetch-and-add 0 #acquire() 42843</span><br><span class="line">lock: kmem: #fetch-and-add 0 #acquire() 198674</span><br><span class="line">lock: kmem: #fetch-and-add 0 #acquire() 191534</span><br><span class="line">lock: bcache: #fetch-and-add 0 #acquire() 1242</span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: proc: #fetch-and-add 43861 #acquire() 117281</span><br><span class="line">lock: virtio_disk: #fetch-and-add 5347 #acquire() 114</span><br><span class="line">lock: proc: #fetch-and-add 4856 #acquire() 117312</span><br><span class="line">lock: proc: #fetch-and-add 4168 #acquire() 117316</span><br><span class="line">lock: proc: #fetch-and-add 2797 #acquire() 117266</span><br><span class="line">tot= 0</span><br><span class="line">test1 OK</span><br><span class="line">start test2</span><br><span class="line">total free number of pages: 32499 (out of 32768)</span><br><span class="line">.....</span><br><span class="line">test2 OK</span><br><span class="line">$ usertests sbrkmuch</span><br><span class="line">usertests starting</span><br><span class="line">test sbrkmuch: OK</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$ usertests</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>相关提示：</p><ul><li>我们可以使用 <code>kernel/param.h</code> 下的 <code>NCPU</code> 常量表示 CPU 数量。</li><li>使用 <code>freerange</code> 为当前运行 <code>freerange</code> 的 CPU 提供所有空余内存。</li><li>函数 <code>cpuid</code> 可以返回当前的 CPU 核心编号，但是只有在中断处于关闭状态时调用才是安全的，我们需要使用 <code>push_off()</code> 和 <code>pop_off()</code> 来控制中断的关和开。</li><li>可以看看在 <code>kernel/sprintf.c</code> 下是怎么实现格式化字符串的。当然，我们将空闲列表锁的名称设置为 <code>kmem</code> 也是完全可以的</li></ul><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><blockquote><p>1.，我们在每个 CPU 核心中都维护一个空闲列表，每个空闲列表有自己的锁。这样下来，在不同 CPU 下的内存分配和释放就可以并行运行，因为每个 CPU 都操作的是不同的空闲列表。</p><p>2.一个 CPU 的空闲列表已经空了，但是另一个 CPU 仍然有空闲的内存。为了处理这样的情形，我们的 CPU 需要从别的 CPU 的空闲列表中 “偷出” 一部分空闲内存。这种 “偷窃内存” 也有可能引入锁冲突，但是希望这样会少频繁一些。</p></blockquote><p>根据题意我们锁需要做的就是</p><ol><li>对每一个cpu都进行设置kmem</li><li>使用 <code>freerange</code> 为当前运行 <code>freerange</code> 的 CPU 提供所有空余内存。</li><li>如果当前cpu不够就进行偷取其他的，同事要跳过当前cpu</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem[NCPU];</span><br></pre></td></tr></table></figure><p>首先是设置cpu个数，然后初始化锁，还有刚开始，吧所有线程分给0号，之后在进行偷取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kinit()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// initlock(&amp;kmem.lock, &quot;kmem&quot;);</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">    initlock(&amp;kmem[i].lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据之前我们讲到的有，首先需要freerange，吧这个内存放到当前的cpu，需要重新写一个程序，因为kfree这个函数被多个其他函数调用。我们需要修改这个kfree—cpu，按照kfree的写法修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">freerange(void *pa_start, void *pa_end)</span><br><span class="line">&#123;</span><br><span class="line">  char *p;</span><br><span class="line">  p = (char*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  // 获取当前cpu，当前直接全部吃掉</span><br><span class="line">  push_off();</span><br><span class="line">  int cpu = cpuid();</span><br><span class="line">  pop_off();</span><br><span class="line"></span><br><span class="line">  for(; p + PGSIZE &lt;= (char*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree_cpu(cpu,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void kfree(void *pa) &#123; </span><br><span class="line">  push_off();</span><br><span class="line">  int cpu = cpuid();</span><br><span class="line">  pop_off();</span><br><span class="line">  kfree_cpu(cpu,pa);</span><br><span class="line">&#125;</span><br><span class="line">// Free the page of physical memory pointed at by v,</span><br><span class="line">// which normally should have been returned by a</span><br><span class="line">// call to kalloc().  (The exception is when</span><br><span class="line">// initializing the allocator; see kinit above.)</span><br><span class="line">void</span><br><span class="line">kfree_cpu(int cpu,void *pa)</span><br><span class="line">&#123;</span><br><span class="line">  struct run *r;</span><br><span class="line"></span><br><span class="line">  if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(&quot;kfree&quot;);</span><br><span class="line"></span><br><span class="line">  // Fill with junk to catch dangling refs.</span><br><span class="line">  memset(pa, 1, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line">  // huoqu dangqian de cpu</span><br><span class="line">  // 需要终端</span><br><span class="line">  acquire(&amp;kmem[cpu].lock);</span><br><span class="line">  r-&gt;next = kmem[cpu].freelist;</span><br><span class="line">  kmem[cpu].freelist = r;</span><br><span class="line">  release(&amp;kmem[cpu].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是kalloc的实现，主要就是实现偷取，进行遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  <span class="comment">// 获取当前线程</span></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="type">int</span> cpu = cpuid();</span><br><span class="line">  pop_off();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem[cpu].lock);</span><br><span class="line">  r = kmem[cpu].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    kmem[cpu].freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem[cpu].lock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 借鉴别人的一些</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* code */</span></span><br><span class="line">      <span class="keyword">if</span> (i==cpu)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      acquire(&amp;kmem[i].lock);</span><br><span class="line">      r = kmem[i].freelist;</span><br><span class="line">      <span class="comment">// 开始stolen</span></span><br><span class="line">      <span class="keyword">if</span> (r)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">         kmem[i].freelist = r-&gt;next;</span><br><span class="line">          release(&amp;kmem[i].lock);</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;kmem[i].lock);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">      release(&amp;kmem[cpu].lock);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="磁盘缓存加速"><a href="#磁盘缓存加速" class="headerlink" title="磁盘缓存加速"></a>磁盘缓存加速</h3><h4 id="要求和提示-10"><a href="#要求和提示-10" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在本部分中实验与上半部分互相独立，如果愿意也可以先做这部分，前部分结果并不会影响当前部分的完成。</p><p>当多个进程尝试大量的使用文件系统时，锁 <code>bcache.lock</code> 就会产生大量的冲突，这个锁的功能就是在 <code>kernel/bio.c</code> 中保护磁盘块缓存。我们的测试程序 <code>bcachetest</code> 会创建多个进程，并不断的读取不同的文件来触发锁 <code>bcache.lock</code> 上的冲突，在我们还没有完成 Lab 前，<code>bcachetest</code> 输出类似如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">$ bcachetest</span><br><span class="line">start test0</span><br><span class="line">test0 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: #fetch-and-add 0 #acquire() 33035</span><br><span class="line">lock: bcache: #fetch-and-add 16142 #acquire() 65978</span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: virtio_disk: #fetch-and-add 162870 #acquire() 1188</span><br><span class="line">lock: proc: #fetch-and-add 51936 #acquire() 73732</span><br><span class="line">lock: bcache: #fetch-and-add 16142 #acquire() 65978</span><br><span class="line">lock: uart: #fetch-and-add 7505 #acquire() 117</span><br><span class="line">lock: proc: #fetch-and-add 6937 #acquire() 73420</span><br><span class="line">tot= 16142</span><br><span class="line">test0: FAIL</span><br><span class="line">start test1</span><br><span class="line">test1 OK</span><br></pre></td></tr></table></figure><p>具体输出的数字可能有所差异，但是肯定可以看到 <code>bcache</code> 锁由于不断 <code>acquire</code> 产生的自旋尝试次数会变得很高。在 <code>kernel/bio.c</code> 中，我们可以看到 <code>bcache.lock</code> 保护了缓存块列表，包括每个块中的引用数 <code>b-&gt;refcnt</code> 以及缓存块的信息（<code>b-&gt;dev</code> 和 <code>b-&gt;blockno</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  struct buf buf[NBUF];</span><br><span class="line"></span><br><span class="line">  // Linked list of all buffers, through prev/next.</span><br><span class="line">  // Sorted by how recently the buffer was used.</span><br><span class="line">  // head.next is most recent, head.prev is least.</span><br><span class="line">  struct buf head;</span><br><span class="line">&#125; bcache;</span><br><span class="line"></span><br><span class="line">struct buf &#123;</span><br><span class="line">  int valid;   // has data been read from disk?</span><br><span class="line">  int disk;    // does disk &quot;own&quot; buf?</span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  struct sleeplock lock;</span><br><span class="line">  uint refcnt;</span><br><span class="line">  struct buf *prev; // LRU cache list</span><br><span class="line">  struct buf *next;</span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们的目标是修改缓存块使得在 <code>bcachetest</code> 测试中，由于对尝试锁 <code>acquire</code> 产生的自旋次数尽可能的少且接近零。理想状态下，块缓存中涉及所有锁的尝试自旋次数之和应该为 <code>0</code>，但是总和小于 <code>500</code> 也是可以接受的。我们需要修改 <code>bget</code> 和 <code>brelse</code>，使得 <code>bcache</code> 中的涉及不同缓存块的查找和释放时更不容易在锁上发生冲突（例如，不需要所有操作都等待 <code>bcache.lock</code>）。同时，我们需要确保每个磁盘块只会有一份缓存。</p><p>当完成时，我们的输出示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line"></span><br><span class="line">$ bcachetest</span><br><span class="line">start test0</span><br><span class="line">test0 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: #fetch-and-add 0 #acquire() 32954</span><br><span class="line">lock: kmem: #fetch-and-add 0 #acquire() 75</span><br><span class="line">lock: kmem: #fetch-and-add 0 #acquire() 73</span><br><span class="line">lock: bcache: #fetch-and-add 0 #acquire() 85</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 4159</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 2118</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 4274</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 4326</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 6334</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 6321</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 6704</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 6696</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 7757</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 6199</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 4136</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 4136</span><br><span class="line">lock: bcache.bucket: #fetch-and-add 0 #acquire() 2123</span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: virtio_disk: #fetch-and-add 158235 #acquire() 1193</span><br><span class="line">lock: proc: #fetch-and-add 117563 #acquire() 3708493</span><br><span class="line">lock: proc: #fetch-and-add 65921 #acquire() 3710254</span><br><span class="line">lock: proc: #fetch-and-add 44090 #acquire() 3708607</span><br><span class="line">lock: proc: #fetch-and-add 43252 #acquire() 3708521</span><br><span class="line">tot= 128</span><br><span class="line">test0: OK</span><br><span class="line">start test1</span><br><span class="line">test1 OK</span><br><span class="line">$ usertests</span><br><span class="line">  ...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>在 <code>initlock</code> 中，我们需要给我们创建的每个锁一个名字，以 <code>bcache</code> 开头，。</p><p>相比刚才的 <code>kalloc</code> 内存分配，这里处理减少对于缓存块的竞争问题更加棘手，因为 <code>bcache</code> 缓冲区是在进程、CPU 之间共享的。对于 <code>kalloc</code> 来说，我们可以为每个 CPU 安排一个空闲列表来解决，在这里却是行不通的。我们需要使用一个哈希表来查询块编号，并给每一个 bucket 桶设置一把锁。</p><p>这些情况下，如果发生锁冲突我们认定是可以接受的：</p><ul><li>当两个进程同时操作相同的块编号时，在 <code>bcachetest</code> 中的 <code>test0</code> 我们不会这样测试。</li><li>当两个进程同时没有命中缓存，并需要寻找一块没有被使用的缓存块进行替换时。我们在 <code>bcachetest</code> 中的 <code>test0</code> 下也不会这样测试。</li><li>当两个进程操作的块编号在你用来划分区块和锁的方案中发生冲突时；例如，两个进程给定的块编号映射到了同一个哈希表的 bucket 桶中。这是完全有可能的，<code>bcachetest</code> 中的 <code>test0</code> 有可能会这样做，这完全取决于我们的设计，但我们应该尝试调整方案的细节以避免冲突（例如，改变哈希表的大小）。</li></ul><p>和 <code>test0</code> 相比之下，<code>test1</code> 中将测试操作更多不同的块编号，并大量使用文件系统的代码路径。</p><p>相关提示：</p><ul><li>请阅读 xv6 教材 PDF 中关于块缓存的描述（见 8.1~8.3 节）</li><li>为哈希表设置固定数量的桶是可以的，可以不去动态调整哈希表的大小。另外可以使用质数数量的桶（例如 13）来减少散列冲突。</li><li>在哈希表中搜索块编号，如果没有命中我们再重新分配条目，这两个操作需要是原子的。</li><li>我们需要删除所有缓存块列表（<code>bcache.head</code> 等），改为使用缓冲区的最后时间（即使用 <code>kernel/trap.c</code> 下的 <code>ticks</code> 来记录时间戳）。这样修改后，<code>brelse</code> 就不需要获取 <code>bcache</code> 锁，<code>bget</code> 也可以根据时间戳选择最久没有使用的块。</li><li>在 <code>bget</code> 中序列化地进行驱逐是可行的（即 <code>bget</code> 中选择缓存块的部分，当查找缓存未命中时可以选择一个缓存块重新使用）。</li><li>我们的答案在一些情形下需要使用两把锁；例如，在驱逐缓存块期间，我们可能需要持有 <code>bcache</code> 和哈希表 bucket 下的锁。请确保不会发生死锁。</li><li>当我们尝试替换一个缓存块，我们可能需要将一个缓冲块从一个桶 bucket 转移到另一个桶 bucket。我们可能会遇到棘手的问题，也就是新的块可能哈希到与旧的块相同的桶，务必注意不要发生死锁。</li><li>一些调试小技巧：实现 bucket 锁的时候，可以先在 <code>bget</code> 的开始和结束位置留下全局的 <code>bcache.lock</code> 的加锁解锁。当我们尝试解决了竞争问题，尝试运行测试的时候再去掉全局锁，处理并发问题。我们也可以使用 <code>make CPUS=1 qemu</code> 来使用单独一个核心来进行测试。</li></ul><h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><blockquote><ul><li>哈希表设置固定数量的桶是可以的，可以不去动态调整哈希表的大小。另外可以使用质数数量的桶（例如 13）来减少散列冲突。</li><li>希表中搜索块编号，如果没有命中我们再重新分配条目，这两个操作需要是原子的</li></ul></blockquote><p>这一节需要我们对磁盘有一定的了解</p><p><img src="https://pica.zhimg.com/v2-395ac352730e6573b0e71d02e177205a_720w.jpg?source=d16d100b" alt="「实验记录」MIT 6.S081 Lab8 locks"></p><p>文件的基本构造，首先最下面进行操作 的是disk，之后我们通过对bcache进行操作，然后写入disk，logging是负责记录操作的日子，为了房子电脑停电crash，inode则是每一个虚拟dev对应的数据结构，通过对pathname我们来得到文件夹dinode</p><p>现在我们来看buf cache的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk?</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf?</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出则是一个双向链表，则是实现lru来进行构造的，buf数组是所有的缓存区文件，head是为了好进行lru才构造的。我们现在的目的是制作多个head，发散到不同的头上面，然后来进行删除</p><p>根据上面的提示，我们把这一整个链表分成多个段，使用13座为三列值，三列函数，使用dev+blockno，来得到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// struct spinlock lock;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">hashtable</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lks</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">&#125; bcache;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置hash函数，用于get得到对应的bucket</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (dev + blockno) % NBUCKET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的底层操作还是在hashtable，每一个hashtable都是单独的一个双向链表，我们还是在单独的双向链表进行操作，但是初始化，吧所有的节点还是挂到0号，之后和上面一样进行偷取</p><p>首先还是进行lock初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="comment">// 初始化所有的锁</span></span><br><span class="line">  <span class="comment">// initlock(&amp;bcache.lock, &quot;bcache&quot;);</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">    initlock(&amp;bcache.lks[i], <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">    <span class="comment">// 对bucket来进行</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">    bcache.hashtable[i].prev = &amp;bcache.hashtable[i];</span><br><span class="line">    bcache.hashtable[i].next = &amp;bcache.hashtable[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对每一个buf，进行设置为单独的节点，不是数组</span></span><br><span class="line">  <span class="comment">// Create linked list of buffers</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 一次性分配给0号bucket</span></span><br><span class="line">  <span class="comment">/* code */</span></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.buf; b &lt; bcache.buf + NBUF; b++)</span><br><span class="line">  &#123;</span><br><span class="line">    b-&gt;next = bcache.hashtable[<span class="number">0</span>].next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.hashtable[<span class="number">0</span>];</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化每一个buf的</span></span><br><span class="line">    <span class="comment">// 头插法</span></span><br><span class="line">    bcache.hashtable[<span class="number">0</span>].next-&gt;prev = b;</span><br><span class="line">    bcache.hashtable[<span class="number">0</span>].next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是什么时候更新会见戳，当我们这个这个数据结构引用次数是0的时候，就需要进行更新了，之前是直接自己进行lru算法实现，现在我们只需要吧这个变成当前时间就可以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line">  <span class="comment">// 通过buf获取bucket</span></span><br><span class="line">  <span class="type">int</span> index = hash(b-&gt;dev, b-&gt;blockno);</span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lks[index]);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="comment">// 不需要进行移动了，更新时间就行</span></span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// no one is waiting for it.</span></span><br><span class="line">    <span class="comment">// b-&gt;next-&gt;prev = b-&gt;prev;</span></span><br><span class="line">    <span class="comment">// b-&gt;prev-&gt;next = b-&gt;next;</span></span><br><span class="line">    <span class="comment">// b-&gt;next = bcache.hashtable[index].next;</span></span><br><span class="line">    <span class="comment">// b-&gt;prev = &amp;bcache.hashtable[index];</span></span><br><span class="line">    <span class="comment">// bcache.hashtable[index].next-&gt;prev = b;</span></span><br><span class="line">    <span class="comment">// bcache.hashtable[index].next = b;</span></span><br><span class="line">    <span class="comment">// 最左边的是要进行删除的</span></span><br><span class="line"></span><br><span class="line">    acquire(&amp;tickslock);</span><br><span class="line">    b-&gt;timestamp = ticks;</span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新时间</span></span><br><span class="line"></span><br><span class="line">  release(&amp;bcache.lks[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> id = myhash(b-&gt;blockno);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lks[id]);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  release(&amp;bcache.lks[id]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bunpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> id = myhash(b-&gt;blockno);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lks[id]);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  release(&amp;bcache.lks[id]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后就是如何进行偷取，bget的任务就是根据给定dev还有blockno来进行得到所需要的buf。下面是2中解决</p><p>我们是首先根据他的id，来算出他是哪一个bucket里面的，之后对这个bucket来进行遍历，看这个buf存不存在。不存在，就是用lru策略，使用时间戳来进行换出。如果是没有空闲节点，那就需要进行偷取，遍历其他bucket，然后找到空闲的，之后修改这个空闲的dev还有no来进行偷取</p><ol><li>获取当前的bucket</li><li>查看有没有他</li><li>没有就查看有没有空闲节点，使用lru换出</li><li>也没有，就使用lru偷取别人的</li></ol><p>1.查找bucket，看有没有缓存可以使用的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">truct buf *b;</span><br><span class="line">  <span class="type">int</span> index = hash(dev, blockno);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lks[index]);</span><br><span class="line">  <span class="comment">// 锁index的bucket</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过head查找不是数组</span></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.hashtable[index].next; b != &amp;bcache.hashtable[index]; b = b-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)</span><br><span class="line">    &#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.lks[index]);</span><br><span class="line">      <span class="comment">// 自旋转锁</span></span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>2.没有，就从自己的空闲使用lru</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not cached.</span></span><br><span class="line"> <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line"> <span class="comment">// 这里是直接使用时间戳</span></span><br><span class="line"> <span class="comment">// todo: 修改</span></span><br><span class="line"> <span class="comment">// 还是和之前一样，开始查找，没有就开始偷取</span></span><br><span class="line"> <span class="comment">//  使用时间戳来进行比较</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">victm</span> =</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"> acquire(&amp;tickslock);</span><br><span class="line"> uint minticks = ticks;</span><br><span class="line"> release(&amp;tickslock);</span><br><span class="line"> <span class="comment">// 找到最小的，进行替换</span></span><br><span class="line"> <span class="keyword">for</span> (b = bcache.hashtable[index].next; b != &amp;bcache.hashtable[index]; b = b-&gt;next)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">/* code */</span></span><br><span class="line">   <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span> &amp;&amp; b-&gt;timestamp &lt;=minticks)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">/* code */</span></span><br><span class="line">     victm = b;</span><br><span class="line">     minticks = b-&gt;timestamp;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>还是没找到，就偷取别人，找到就break’</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!victm)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 找不到就开始偷取</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* code */</span></span><br><span class="line">      <span class="comment">// 从不同的bucket的查找</span></span><br><span class="line">      <span class="keyword">if</span> (i == index)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// huoqu lock</span></span><br><span class="line">      acquire(&amp;bcache.lks[i]);</span><br><span class="line">      <span class="comment">// 接着查找</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      复制上面的代码</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      acquire(&amp;tickslock);</span><br><span class="line">      minticks = ticks;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 找到最小的，进行替换</span></span><br><span class="line">      <span class="keyword">for</span> (b = bcache.hashtable[i].next; b != &amp;bcache.hashtable[i]; b = b-&gt;next)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span> &amp;&amp; b-&gt;timestamp &lt;= minticks)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* code */</span></span><br><span class="line">          victm = b;</span><br><span class="line">          minticks = b-&gt;timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       release(&amp;bcache.lks[i]);</span><br><span class="line">      <span class="keyword">if</span> (victm)</span><br><span class="line">      &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 开锁</span></span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后就是如果找到了，就进行初始化，更换dev，还有block，还有ref，同事还有进行打开和释放链表，双向链表得到操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (victm)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* code */</span></span><br><span class="line">      <span class="comment">// 找到就进行break</span></span><br><span class="line">      <span class="comment">// 吧他翘出来，放到inde</span></span><br><span class="line">      b=victm;</span><br><span class="line">      b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">      b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化这个锁信息</span></span><br><span class="line">      <span class="comment">// 更新</span></span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 放入到index 头插法</span></span><br><span class="line">      b-&gt;next = bcache.hashtable[index].next;</span><br><span class="line">      bcache.hashtable[index].next-&gt;prev = b;</span><br><span class="line">      bcache.hashtable[index].next = victm;</span><br><span class="line">      b-&gt;prev = &amp;bcache.hashtable[index];</span><br><span class="line"></span><br><span class="line">  acquiresleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  release(&amp;bcache.lks[index]);</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是全部操作的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf *</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="type">int</span> index = hash(dev, blockno);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lks[index]);</span><br><span class="line">  <span class="comment">// 锁index的bucket</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过head查找不是数组</span></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.hashtable[index].next; b != &amp;bcache.hashtable[index]; b = b-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)</span><br><span class="line">    &#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.lks[index]);</span><br><span class="line">      <span class="comment">// 自旋转锁</span></span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="comment">// 这里是直接使用时间戳</span></span><br><span class="line">  <span class="comment">// todo: 修改</span></span><br><span class="line">  <span class="comment">// 还是和之前一样，开始查找，没有就开始偷取</span></span><br><span class="line">  <span class="comment">//  使用时间戳来进行比较</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">victm</span> =</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  uint minticks = ticks;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="comment">// 找到最小的，进行替换</span></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.hashtable[index].next; b != &amp;bcache.hashtable[index]; b = b-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">    <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span> &amp;&amp; b-&gt;timestamp &lt;=minticks)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* code */</span></span><br><span class="line">      victm = b;</span><br><span class="line">      minticks = b-&gt;timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!victm)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 找不到就开始偷取</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* code */</span></span><br><span class="line">      <span class="comment">// 从不同的bucket的查找</span></span><br><span class="line">      <span class="keyword">if</span> (i == index)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// huoqu lock</span></span><br><span class="line">      acquire(&amp;bcache.lks[i]);</span><br><span class="line">      <span class="comment">// 接着查找</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      复制上面的代码</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      acquire(&amp;tickslock);</span><br><span class="line">      minticks = ticks;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 找到最小的，进行替换</span></span><br><span class="line">      <span class="keyword">for</span> (b = bcache.hashtable[i].next; b != &amp;bcache.hashtable[i]; b = b-&gt;next)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span> &amp;&amp; b-&gt;timestamp &lt;= minticks)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* code */</span></span><br><span class="line">          victm = b;</span><br><span class="line">          minticks = b-&gt;timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       release(&amp;bcache.lks[i]);</span><br><span class="line">      <span class="keyword">if</span> (victm)</span><br><span class="line">      &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 开锁</span></span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> (victm)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">/* code */</span></span><br><span class="line">        <span class="comment">// 找到就进行break</span></span><br><span class="line">        <span class="comment">// 吧他翘出来，放到inde</span></span><br><span class="line">        b=victm;</span><br><span class="line">        b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">        b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化这个锁信息</span></span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        b-&gt;blockno = blockno;</span><br><span class="line">        b-&gt;dev = dev;</span><br><span class="line">        b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">        b-&gt;valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放入到index 头插法</span></span><br><span class="line">        b-&gt;next = bcache.hashtable[index].next;</span><br><span class="line">        bcache.hashtable[index].next-&gt;prev = b;</span><br><span class="line">        bcache.hashtable[index].next = victm;</span><br><span class="line">        b-&gt;prev = &amp;bcache.hashtable[index];</span><br><span class="line"></span><br><span class="line">    acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">  </span><br><span class="line">    release(&amp;bcache.lks[index]);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;bcache.lks[index]);</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>第一个内存分配的题目是送分题目，基本上只要看懂题目就知道如何理解。第二个这个也是参考别人的实现，有的是没使用单链表，这个博主的思路和之前代码基本一样比较好理解，就对这个博主的代码进行了参考。</p><h2 id="8-fs"><a href="#8-fs" class="headerlink" title="8.fs"></a>8.fs</h2><h3 id="大文件实现"><a href="#大文件实现" class="headerlink" title="大文件实现"></a>大文件实现</h3><h4 id="要求和提示-11"><a href="#要求和提示-11" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在这个部分中，我们将为 xv6 提高其文件系统所能支持的最大文件大小。当前 xv6 所支持的最大文件大小被限制在 268 个块，也就是 <code>268*BSIZE</code> 个字节（在 xv6 中 <code>BSIZE</code> 块内存大小为 1024）。这个限制的原因来自在 xv6 的 inode 中，存储有 12 个 “直接” 块编号和一个 “间接” 块编号，在 “间接” 块编号指向的块中又可以存储 256 个块编号。因此，一个文件最多可以对应 12+256&#x3D;26812+256&#x3D;26812+256&#x3D;268 个块。</p><p>这是在 PDF 中图 8.3，很好的表示了这一结构：</p><p><img src="https://blog.rayzhang.top/2022/10/19/mit-6.s081-lab-fs/inode.png" alt="img"></p><p>在这部分作业中，我们将使用 <code>bigfile</code> 进行测试能创建的最大文件，如果我们暂时还没有对当前 xv6 修改，我们会获得这样的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">$ bigfile</span><br><span class="line">..</span><br><span class="line">wrote 268 blocks</span><br><span class="line">bigfile: file is too s</span><br></pre></td></tr></table></figure><h4 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h4><p>这一个题目是408考了很多次的题目，直接看提示就可以写的。首先设置最大的文件块长度，是直接+一级+二级，二级索引是一级*一级。之后把地址进行变成addr+2，0 -addr-1是直接，addr是一级，addr+1下标代表的是二级。同事inode还有dinode也要更新，之后就是进行分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT + NINDIRECT * NINDIRECT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>分配，是在一级之后来进行二级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inode content</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The content (data) associated with each inode is stored</span></span><br><span class="line"><span class="comment">// in blocks on the disk. The first NDIRECT block numbers</span></span><br><span class="line"><span class="comment">// are listed in ip-&gt;addrs[].  The next NINDIRECT blocks are</span></span><br><span class="line"><span class="comment">// listed in block ip-&gt;addrs[NDIRECT].</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the disk block address of the nth block in inode ip.</span></span><br><span class="line"><span class="comment">// If there is no such block, bmap allocates one.</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NINDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT * NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load doubly-indirect block, allocating if necessary</span></span><br><span class="line">    <span class="type">int</span> index = bn / NINDIRECT; <span class="comment">// Determine which indirect block</span></span><br><span class="line">    <span class="type">int</span> offset = bn % NINDIRECT; <span class="comment">// Determine offset of the data block in the indirect block</span></span><br><span class="line">    <span class="comment">// Create the doubly-indirect block if not exists</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT + <span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT + <span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the indirect block if not exists</span></span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[index]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[index] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the data block if not exists</span></span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[offset]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[offset] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>)</span><br><span class="line">      </span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>删除也是一样的操作，首先获取地址，然后对这个网页在进行遍历，之后再次进行删除，直接抄袭一级索引就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Truncate inode (discard contents).</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j, k;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>, *<span class="title">ibp</span>;</span></span><br><span class="line">  uint *a, *b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Locate doubly-indirect block</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT + <span class="number">1</span>])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class="number">1</span>]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="comment">// Traverse indirect blocks</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])&#123;</span><br><span class="line">        ibp = bread(ip-&gt;dev, a[j]);</span><br><span class="line">        b = (uint*)ibp-&gt;data;</span><br><span class="line">        <span class="comment">// Traverse data blocks</span></span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; NINDIRECT; k++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(b[k])</span><br><span class="line">            bfree(ip-&gt;dev, b[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(ibp);</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class="number">1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="符号链接实现"><a href="#符号链接实现" class="headerlink" title="符号链接实现"></a>符号链接实现</h3><h4 id="要求和提示-12"><a href="#要求和提示-12" class="headerlink" title="要求和提示"></a>要求和提示</h4><p>在这一部分中，我们将为 xv6 添加符号链接（软链接）功能。符号链接通过路径名指向一个被链接的文件；当一个符号链接被打开时，内核会跟踪符号链接访问对应的文件。符号链接类似于硬链接，但是硬链接只仅限于指向同一磁盘的文件，而符号链接可以跨越磁盘。虽然 xv6 不支持多设备，但是实现这个系统调用是一个很好的练习，可以帮助我们了解路径名查询的工作原理。</p><p>我们的目标是实现系统调用 <code>symlink(char *target, char *path)</code>，他将在指定路径上创建一个新的符号链接，指向由目标命名的文件。想了解更多用法，我们可以查看 <code>symlink</code> 的 man 页面。为了测试 <code>symlink</code> 系统调用，我们需要向主目录下 <code>Makefile</code> 文件中加入 <code>symlinktest</code>（添加系统调用的基操，忘记了的话去重温下 Lab Syscall）。成功的 <code>symlinktest</code> 运行结果示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">$ symlinktest</span><br><span class="line">Start: test symlinks</span><br><span class="line">test symlinks: ok</span><br><span class="line">Start: test concurrent symlinks</span><br><span class="line">test concurrent symlinks: ok</span><br><span class="line">$ usertests</span><br><span class="line">...</span><br><span class="line">ALL TESTS PASSED</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><p>相关提示：</p><ul><li>首先，为 <code>symlink</code> 创建一个新的系统调用编号，在 <code>user/usys.pl</code> 和 <code>user/user.h</code> 中添加条目，并在 <code>kernel/sysfile.c</code> 中实现 <code>sys_symlink</code>。（不记得的强烈建议重新去看一下 Lab Syscall）</li><li>向 <code>kernel/stat.h</code> 中添加一个新的文件类型 <code>T_SYMLINK</code>，以表示符号链接。</li><li>我们需要在 <code>kernel/fcntl.h</code> 中添加一个新的标志 <code>O_NOFOLLOW</code>，我们可以与 <code>open</code> 系统调用一起使用。请注意，传递给 <code>open</code> 的标志是按照位检测的，所以新标志不应当与现有的标志位重叠。在添加标志位之后，只要我们将 <code>symlinktest</code> 加入到 Makefile 中，<code>user/symlinktest.c</code> 就可以顺利通过编译。</li><li>我们将实现 <code>symlink(target, path)</code> 系统调用，在指定目录下创建一个指向目标的新符号链接。需要注意的是，系统调用的成功并不需要目标的存在。因此，我们需要选择一个地方来存储符号链接的目标路径（例如，在 inode 下的数据块中）。最后 <code>symlink</code> 应当返回一个整数，代表成功（0）或者失败（-1），类似于 <code>link</code> 和 <code>unlink</code>。</li><li>我们需要修改 <code>open</code> 系统调用，以处理路径指向符号链接的情况。如果该文件不存在，<code>open</code> 系统调用需要返回失败。当一个进程在打开标志中指定 <code>O_NOFOLLOW</code> 标志位时，<code>open</code> 应当打开链接（但不跟踪符号链接）。</li><li>如果被链接的文件也是一个符号链接，我们必须递归地跟踪他，直到到达一个非链接文件。如果链接形成了一个循环，我们需要返回一个错误代码。我们也可以提前设定一个阈值（例如 10），当链接的深度到达阈值就返回错误代码来近似地处理这个问题。</li><li>其他系统调用（例如 <code>link</code> 和 <code>unlink</code>）则不能跟踪符号链接，这些系统调用只能操作符号链接本身。</li><li>在这个 Lab 中，我们不需要处理指向文件夹的符号链接。</li></ul><h4 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h4><ol><li>首先是设置symlin，这个之前就讲了很多就不在讲了</li><li>之后添加文件类型</li><li>然后对symlink进行实现，得到两个str</li><li>通过create来进行穿件文件类型，之后就是写入targetpath到这个inode里面</li><li>之后对open操作，进行修改，加入判断是不是软连接，然后次数要不要进行递归</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="type">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="comment">// Get params from user space</span></span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, target, MAXPATH)) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="comment">// Create inode of the symlink</span></span><br><span class="line">  <span class="keyword">if</span>((ip = create(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Save the target path to the first data block</span></span><br><span class="line">  <span class="keyword">if</span>(writei(ip, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, n) != n) &#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ip-&gt;type == T_SYMLINK &amp;&amp; !(omode &amp; O_NOFOLLOW))&#123;</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Follow the symlink recursively</span></span><br><span class="line">    <span class="keyword">while</span>(ip-&gt;type == T_SYMLINK)&#123;</span><br><span class="line">      <span class="comment">// Return failure if max recursive depth exceeded</span></span><br><span class="line">      <span class="keyword">if</span>(++depth == MAX_SYMLINK_DEPTH)&#123;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Else read new target path from current symlink inode</span></span><br><span class="line">      <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)path, <span class="number">0</span>, MAXPATH) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="comment">// Check if target is valid</span></span><br><span class="line">      <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// target not exist</span></span><br><span class="line">      &#125;</span><br><span class="line">      ilock(ip);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>终于写完大部分的6.s081，从4月份开始写，一直拖到现在，才填完坑。羞愧。中间一个月去复习软考了。</p><p>本身自己是非科班跨考408的，对于操作系统还有计算机组成都只停留在背诵还有做题阶段。对原理却是什么都不知道。</p><p>当第一次写第一个作业的时候，我连如何使用ide来辅助编写代码都不会。文件是make文件，我之前之后使用集成IDE来进行一键编译调试，但是第一次我都不知道如何进行调试代码，看着视频里的教授使用gdb调试代码。我都不知道这到底是怎么实现的。</p><p>我只好从网上搜索vscode调试6.s081.但是大多数人都知识给了一个一个task还有一个launch.json没有解释是为什么可以调试成功。然后直接复制粘贴进行运行，按住f5来进行调试，再加上前面的题目我几乎都没有自己思考的过程，于是5月份我就准备软考，没有接着写了。</p><p>6月份，考完之后，我有重新开始把这之前了题目在做一遍。同时，我具体进行了研究一下，vscode的两个json文件到底是干什么。首先第一个task，顾名思义就是你自己想要进行的任务操作，例如编译就可以是gcc a.c -o a.out直接进行简化，相当于配置好了手动输入的麻烦。接下来的launch.json才是重点</p><p>，我们可以设置gdb来进行调试，调试的文件是kernel（因为操作系统最开始初始化的文件就是kernel，首先进行内存加载</p><p>，之后设置远程调用gdb，这个是作业里面教授设置的，然后就可以按住f5来进行调试。相当于真正的启动程序。注意还需要我们手动输入make qemu-gdb在命令行。这个任务正好可以被我之前讲解的task来解决，我们只要在task新加一个任务输入 make就行。到这里才真正明白是如何进行调试gdb的。</p><p>之后差不多到了那种全忘了的境界，然后去上考场，重新写入题目，可能也是因为软考也复习了一下操作系统吧，做起题目来，比之前好多了，之前没有理解的视频也逐渐就豁然开朗的感觉，重新做会题目前4个，就感觉很快。后面的文件部分，就做的比较慢一点，可能是当初也没复习好文件。</p><p>总的来说xv6这个操作系统还是让我对内，存加载，页表操作，陷入内核态，进程切换，这些概念有实打实的认识。不想之前学408只知道什么调度算法，什么直接相连，全相连这种概念性的东西对整个操作系统如何启动，如何使用系统调用，程序如何中断，为什么要换页，出现page falut，还有如何进行线程切换都有了一个打字的了解，可能果断时间就会网络吧。所以记录一下。</p><p>最后感谢，网络上这些大佬的题解，不然，我几乎就就有可能放弃了，有些 题目都是参考大佬的题解才实现的。</p><p><a href="https://blog.rayzhang.top/">Ray’s Blog - Welcome to my space btw~ (rayzhang.top)</a></p><p><a href="https://www.zhihu.com/people/wan2njupt/posts">(54 封私信 &#x2F; 81 条消息) 士全 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-S081&quot;&gt;&lt;a href=&quot;#6-S081&quot; class=&quot;headerlink&quot; title=&quot;6.S081&quot;&gt;&lt;/a&gt;6.S081&lt;/h1&gt;&lt;p&gt;这是mit的公开课，使用xv6来自己实现一个小的操作系统。&lt;/p&gt;
&lt;h2 id=&quot;0-预备环节&quot;&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="公开课" scheme="http://yoursite.com/tags/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>深度学习代码小结</title>
    <link href="http://yoursite.com/2023/03/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2023/03/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E5%B0%8F%E7%BB%93/</id>
    <published>2023-03-16T12:03:58.000Z</published>
    <updated>2023-03-16T13:42:37.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-预备知识"><a href="#0-预备知识" class="headerlink" title="0.预备知识"></a>0.预备知识</h1><p>收先我们知道，一般大型公司都有一台机器才能够外网访问，其他机器都只能访问内网，我们把进行外网访问的机器称为跳板机，他的作用就是，我们通过这个机器来远程俩连接到内网的跳板机，然后再这个跳板机上进行连接到真正的内网机器。我们可以使用端口转发，ssh -N来进行转发内网得到机器端口到本地的机器端口，可以转发内网机器node5的端口准发到我自己的windows的 10086端口，字样，我们如果需要连接到内网的机器node5，就不需要通过跳板机连接。<strong>注意，如果需要使用之恩重方案，一般都需要把自己的公钥上传到跳板机还有内网机器上的authority——key’才可以，等待我们自己的机器进行重亲就可以</strong>。以后我们只需要下面代码就可以连接node5机器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 1008600 root@localhost</span><br></pre></td></tr></table></figure><p>本文是首先讲解的是如何进行远程连接，所以作为预备知识。目前远程连接主要是是使用以下两种方案，一种是vscode的 remote ssh还有一种是使用jetbrain 的gateway。下面介绍这两种方案：</p><p>1.vscode进行连接.我们只需要在上面我们已近做好的内网转发上面，进行新建一个vscode远程连接，输入我们 远程连接的上述代码，然后选择我们需要的项目目录就可以了。此时，我们还需要进行设置python解释器，我们一般都是使用自己的虚拟环境，我们我们找到自己虚拟环境所在的vene包里面，然后进行选择到python，就可以了，</p><p>主要优点：连接消耗的内存就比较少，但是代码补全还有debug能力不如gateway。一般我们可以直接在vscode进行修改，然后直接在windterm里面来进行执行代码，使用screen</p><p>2.使用gateway，这个就是jetbrain推出的远程pycharm，可以这么理解，相当于，我们前端只是进行修改 代码，但是真正的操作都是在服务器的后端服务器上，只不过，这个gateway也还是需要授权才可以使用的，我使用的是教育邮箱，所以可以进行使用。</p><p>优点：和我们之前在自己电脑使用pycharm一样，但是由于使用的是远程连接，会造成服务器不稳定，偶尔出现多次断链的情况，也会出现卡死服务器cpu的情况。但是一般都是比较正常（推荐使用gateway）</p><h1 id="1-datasets方面"><a href="#1-datasets方面" class="headerlink" title="1.datasets方面"></a>1.datasets方面</h1><p>深度学习的第一步就是学习如何写数据集,对于深度学习现在已经变成搭积木的游戏,我们只需要根据之前的官网文件,来对我们的自定义我们的数据集，我们只有知道我们的输入输出后，才可以定制自己的模型。由于我们的是分类模型，所以我们的输入是图片的tensor，输出是图片的类型，使用数字就可以。</p><p>对于这个数据集获取器，我们可以使用继承nn的datasets来实现，需要我们写的只有三个函数，一个init，一个len，还有一个getitem。</p><p>下面是通用得到实现方法：</p><blockquote><p>在此之前我们自己制作一个通用的csv，奇艺列是图片的地址，第二列就是属性值，我们的dataset就只需要从csv来读取图片还有表示，就可以了，主要使用load——csv来进行读取csv</p></blockquote><ol><li>首先写init，需要传入的参数有，resize，mode，path，三个是图片的大小，当前是什么模式，还有一个是csv存在的地址，之后我们就进行切割数据集，使用6:2:2来进行切分，主要思路，就是把从loadcsv得到完整的列表，然后进行切分</li><li>之后就是getitem，我们只需要按照给定的idx，返回对应的图片还有属性值就可以，一般transform可以在外面写好，也可以在dataset你写好，使用transform来进行组合所需要的操作，然后对图片来进行执行就可以了，最后返回图片还有属性值</li><li>返回len只需要返回图片列表长度就可以</li></ol><p>这是最简单的dataset，我们只需要想明白我们需要的输入还有输出到底是什么就可以了，然后重点就是如何得到这个csv表格，我们可以使用os还有glob这些包来进行对文件夹操作，然后放入到csv里面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.resize = resize</span><br><span class="line">    self.mode = mode</span><br><span class="line">    self.cur_images ,self.syn_images,self.labels = self.load_csv(<span class="string">&#x27;./p2p.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#划分训练集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&quot;train&quot;</span>:</span><br><span class="line">        self.cur_images = self.cur_images[:<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.cur_images))]</span><br><span class="line">        self.syn_images = self.syn_images[:<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.syn_images))]</span><br><span class="line">        self.labels = self.labels[:<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.labels))]</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">&#x27;val&#x27;</span>:  <span class="comment"># 20% = 60%-&gt;80%</span></span><br><span class="line">        self.cur_images = self.cur_images[<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.cur_images)):<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.cur_images))]</span><br><span class="line">        self.syn_images = self.syn_images[<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.syn_images)):<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.syn_images))]</span><br><span class="line">        self.labels = self.labels[<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.labels)):<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.labels))]</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">&#x27;test&#x27;</span>:  <span class="comment"># 20% = 80%-&gt;9999%</span></span><br><span class="line">        self.cur_images = self.cur_images[<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.cur_images)):<span class="built_in">int</span>(<span class="number">0.99999</span> * <span class="built_in">len</span>(self.cur_images))]</span><br><span class="line">        self.syn_images = self.syn_images[<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.syn_images)):<span class="built_in">int</span>(<span class="number">0.99999</span> * <span class="built_in">len</span>(self.syn_images))]</span><br><span class="line">        self.labels = self.labels[<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.labels)):<span class="built_in">int</span>(<span class="number">0.99999</span> * <span class="built_in">len</span>(self.labels))]</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">         <span class="keyword">def</span> <span class="title function_">load_csv</span>(<span class="params">self, data_csv</span>):</span><br><span class="line">    cur_img = []</span><br><span class="line">    syn_img = []</span><br><span class="line">    labels = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(data_csv, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        reader = csv.reader(f)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">            old, new, label = row</span><br><span class="line">            label = <span class="built_in">int</span>(label)</span><br><span class="line">            cur_img.append(old)</span><br><span class="line">            syn_img.append(new)</span><br><span class="line">            labels.append(label)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(syn_img) == <span class="built_in">len</span>(cur_img)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(labels) == <span class="built_in">len</span>(syn_img)</span><br><span class="line">    <span class="keyword">return</span> cur_img, syn_img, labels</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(self.labels)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">    img, syn_image,label = self.cur_images[idx],self.syn_images[idx], self.labels[idx]</span><br><span class="line"></span><br><span class="line">    tf_cnn = transforms.Compose([</span><br><span class="line">        <span class="keyword">lambda</span> x:Image.<span class="built_in">open</span>(x).convert(<span class="string">&#x27;RGB&#x27;</span>),  <span class="comment"># string path= &gt; image data</span></span><br><span class="line">        transforms.Resize((<span class="built_in">int</span>(self.resize*<span class="number">1.25</span>), <span class="built_in">int</span>(self.resize*<span class="number">1.25</span>))),</span><br><span class="line">        transforms.RandomRotation(<span class="number">15</span>),</span><br><span class="line">        transforms.CenterCrop(self.resize),</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],</span><br><span class="line">                             std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    ])</span><br><span class="line">    tf_swin = transforms.Compose([</span><br><span class="line">        <span class="keyword">lambda</span> x: Image.<span class="built_in">open</span>(x).convert(<span class="string">&#x27;RGB&#x27;</span>),  <span class="comment"># string path= &gt; image data</span></span><br><span class="line">        transforms.Resize((<span class="built_in">int</span>(<span class="number">256</span>), <span class="built_in">int</span>(<span class="number">256</span>))),</span><br><span class="line"></span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],</span><br><span class="line">                             std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    ])</span><br><span class="line">    img = tf_cnn(img)</span><br><span class="line">    syn_image1 = tf_cnn(syn_image)</span><br><span class="line">    syn_swin = tf_swin(syn_image)</span><br><span class="line">    label = torch.tensor(label)</span><br><span class="line">    <span class="keyword">return</span> img,syn_image1,syn_swin,label</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h1 id="2-模型方面"><a href="#2-模型方面" class="headerlink" title="2.模型方面"></a>2.模型方面</h1><p>模型方面，我改的比较少，只能说还是需要两个，一个是forward函数，一个init来进行初始化，我们在init进行设置所需要的cnn，fc层，设计模型架构，然后再forward里面来进行传入图片，吧图片在上面的架构走一次，我们就得到模型所产生的结果了。这个地方改的不是很多，需要日后来讲解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def forward(self, x_old, x_new):</span><br><span class="line">    x_old = self.old_features(x_old)</span><br><span class="line">    x_new = self.new_features(x_new)</span><br><span class="line">    x = x_old + x_new</span><br><span class="line">    heads = []</span><br><span class="line">    for i in range(self.num_head):</span><br><span class="line">        heads.append(getattr(self, &quot;cat_head%d&quot; % i)(x))</span><br><span class="line"></span><br><span class="line">    heads = torch.stack(heads).permute([1, 0, 2])</span><br><span class="line">    if heads.size(1) &gt; 1:</span><br><span class="line">        heads = F.log_softmax(heads, dim=1)</span><br><span class="line"></span><br><span class="line">    out = self.fc(heads.sum(dim=1))</span><br><span class="line">    out = self.bn(out)</span><br><span class="line"></span><br><span class="line">    return out, x, heads</span><br></pre></td></tr></table></figure><h1 id="3-train方面"><a href="#3-train方面" class="headerlink" title="3.train方面"></a>3.train方面</h1><p>train方面这个代码是需要我自己来进行重构的，耦合比较严重。</p><h2 id="3-1参数解析"><a href="#3-1参数解析" class="headerlink" title="3.1参数解析"></a>3.1参数解析</h2><p>首先就是设置相关的参数使用argparser来进行设置，一般我都是直接抄之前的代码，资格不需要自己修改，可以直接看绵绵这个，这个就是我们在服务器你启动代码所需在后面进行添加的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_args_parser</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(<span class="string">&#x27;MAE pre-training&#x27;</span>, add_help=<span class="literal">False</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--batch_size&#x27;</span>, default=<span class="number">200</span>, <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Batch size per GPU (effective batch size is batch_size * accum_iter * # gpus&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, default=<span class="number">200</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--accum_iter&#x27;</span>, default=<span class="number">1</span>, <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Accumulate gradient iterations (for increasing the effective batch size under memory &#x27;</span></span><br><span class="line">                             <span class="string">&#x27;constraints)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Model parameters</span></span><br><span class="line">    <span class="comment"># parser.add_argument(&#x27;--model&#x27;, default=&#x27;mae_vit_large_patch16&#x27;, type=str, metavar=&#x27;MODEL&#x27;,</span></span><br><span class="line">    <span class="comment">#                     help=&#x27;Name of model to train&#x27;)</span></span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--input_size&#x27;</span>, default=<span class="number">224</span>, <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;images input size&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Optimizer parameters</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--weight_decay&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.0001</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;weight decay (default: 0.05)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--lr&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.0001</span>, metavar=<span class="string">&#x27;LR&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;learning rate (absolute lr)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--warmup_epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">40</span>, metavar=<span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;epochs to warmup LR&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Dataset parameters</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--root_path&#x27;</span>, default=<span class="string">&#x27;/home/tonnn/.nas/weijia/datasets/face_dataset/Oulu_CASIA_NIR_VIS/NI&#x27;</span>,</span><br><span class="line">                        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;dataset path&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--output_dir&#x27;</span>, default=<span class="string">&#x27;./output_dir&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;path where to save, empty for no saving&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--pth_path&#x27;</span>, default=<span class="string">&#x27;./checkpoint/image1k/accuracy_loss_change_train_2.pth&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;path where to save, empty for no saving&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--log_dir&#x27;</span>, default=<span class="string">&#x27;./output_dir&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;path where to tensorboard log&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义的模型加载</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--seed&#x27;</span>, default=<span class="number">3407</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--resume&#x27;</span>, default=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;resume from checkpoint&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--start_epoch&#x27;</span>, default=<span class="number">77</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, metavar=<span class="string">&#x27;N&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;start epoch&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--num_workers&#x27;</span>, default=<span class="number">8</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--pin_memory&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;Pin CPU memory in DataLoader for more efficient (sometimes) transfer to GPU.&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--no_pin_mem&#x27;</span>, action=<span class="string">&#x27;store_false&#x27;</span>, dest=<span class="string">&#x27;pin_mem&#x27;</span>)</span><br><span class="line">    parser.set_defaults(pin_mem=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># distributed training parameters</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--world_size&#x27;</span>, default=<span class="number">1</span>, <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;number of distributed processes&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--local_rank&#x27;</span>, default=-<span class="number">1</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--dist_on_itp&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--dist_url&#x27;</span>, default=<span class="string">&#x27;env://&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;url used to set up distributed training&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parser</span><br></pre></td></tr></table></figure><p>上面就是需要的参数，我们可以对着上面来修改epoch还有学习率等其他内容，还有resume等，来进行加载</p><h2 id="3-2构建数据集"><a href="#3-2构建数据集" class="headerlink" title="3.2构建数据集"></a>3.2构建数据集</h2><p>我们使用函数来进行抽取构建数据集这个操作，这样，我们以后更换数据集，只需要更改build’datasest就可以了，方法还是和之前一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_datasets</span>(<span class="params">mode, args</span>):</span><br><span class="line">    dataset = FaceEmotionRecognize(args.root_path, args.input_size, mode)</span><br><span class="line">    <span class="keyword">return</span> dataset</span><br></pre></td></tr></table></figure><p>上面那个face可以换成其他任意的dataset</p><h2 id="3-3分布式训练"><a href="#3-3分布式训练" class="headerlink" title="3.3分布式训练"></a>3.3分布式训练</h2><p>我们首先是需要把os的enviroment环境设置为0,1表示是在两个显卡上进行训练，之后我们还需要使用dataparallel还有cuda，来把模型传入到显卡上面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">os.environ[<span class="string">&#x27;CUDA_VISIBLE_DEVICES&#x27;</span>] = <span class="string">&#x27;0,1&#x27;</span></span><br><span class="line">model_swin = nn.DataParallel(model_swin)</span><br><span class="line">model_swin = model_swin.cuda()</span><br></pre></td></tr></table></figure><h2 id="3-3main函数的构建"><a href="#3-3main函数的构建" class="headerlink" title="3.3main函数的构建"></a>3.3main函数的构建</h2><p>main函数主要写的是整体流程，我们首先是是来进行构建数据集还有dataloader，对于train，我们一般使用shuffle，对于val，我们一般是使用不进行shuffle的。</p><p>之后就是进行构建模型，这一步，下一步就是进行设置loss函数我们一般使用交叉熵就可以了，然后之后就是使用优化器来优化模型，一般使用adam还有sgd，<strong>注意我们需要把模型的参数全部传入到优化器上面才可以（对于想cyclegan’这种，需要联合有何的参数，我们使用uitertools来进行连接两个模型的参数，到这个尤其来进行优化</strong></p><p>之后就是来进行构建tensorboard，我们需要来构建tensorboard所在文件目录，之后就是设置log，还有度量值，这个我们直接使用util来进行设置（不用自己写）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   os.makedirs(args.log_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">        log_writer = SummaryWriter(log_dir=args.log_dir)</span><br><span class="line">        loss_scaler = NativeScaler()</span><br><span class="line"><span class="comment">#加载模型</span></span><br><span class="line">misc.load_model(args=args, model_without_ddp=model, optimizer=optimizer, loss_scaler=loss_scaler)</span><br></pre></td></tr></table></figure><p>下一步就是加载模型，也是使用何开明写好的直接进行加载，我们只需要传入模型，优化器，还有记录的scaler</p><p>这一步是我直接把模型进行保存了，然后直接使用load就可以加载出模型，之后我们还是需要把模型移动到显卡上面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pth_path = <span class="string">&#x27;./checkpoint/swin2_base/accuracy_loss_change_train_11cnn.pth&#x27;</span></span><br><span class="line">   <span class="comment"># pth_path = args.pth_path</span></span><br><span class="line">   <span class="comment"># model = resnet18(pretrained=False)</span></span><br><span class="line">   model_cnn = torch.load(pth_path)</span><br></pre></td></tr></table></figure><p>对于加载好的模型，我们想修改值的话，可以修改最后一层的圈连接层，对于前面的层数我们全部保留，最后一层的fc，我们来使用linear来进行修改就可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model_conv = convnext_tiny(pretrained=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># print(model_conv.head.fc.in_features)</span></span><br><span class="line">    <span class="comment"># exit()</span></span><br><span class="line">    model_conv_ftrs = model_conv.head.fc.in_features</span><br><span class="line">    model_conv.head.fc = nn.Linear(model_conv_ftrs,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>之后就是开始for epoch，首先我们进入到验证阶段</p><ol><li>我们第一步就是设置模型为eval模式，</li><li>然后进入到验证阶段，传入的是数据集，还有模型</li><li>返回的就是记录的misc，之后我们对记录的值，传入到log里面，让他写入到tensorboard里面</li></ol><p>之后我们就是进行train模式，对于train模式，我们首先就是把model的train来进行打开</p><ol><li>传入大还是模型，数据集，还有loss，优化器，log直接在train里面记录到tensor里面</li></ol><h3 id="3-3-1验证阶段代码"><a href="#3-3-1验证阶段代码" class="headerlink" title="3.3.1验证阶段代码"></a>3.3.1验证阶段代码</h3><p>这一步，我们需要设置为torch nograd才可以进行操作，下面是需要学习的，使用装饰器进行让代码处于在nograd状态下，使用misc来进行记录，接下来就是开始进行评估，得到图像还有属性，传入到显卡上面，使用model来得到结果，之后就是使用soft来得到最大的值（这个就是可能的属性），然后就是top1，top5的计算这个直接使用timm的库可以计算。</p><p>之后就是记录在tensorboard里面，记录loss还有acc1还有acc5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line">   metric_logger = misc.MetricLogger(delimiter=<span class="string">&quot; &quot;</span>)</span><br><span class="line">   header = <span class="string">&quot;Test:&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 转入到评测模式</span></span><br><span class="line">   model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> batch <span class="keyword">in</span> metric_logger.log_every(data_loader, <span class="number">10</span>, header):</span><br><span class="line">       images = batch[<span class="number">0</span>]</span><br><span class="line">       target = batch[-<span class="number">1</span>]</span><br><span class="line">       images = images.to(device, non_blocking=<span class="literal">True</span>)</span><br><span class="line">       target = target.to(device, non_blocking=<span class="literal">True</span>)</span><br><span class="line">       <span class="comment"># 计算loss，统计得分</span></span><br><span class="line">       <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">           output = model(images)</span><br><span class="line">           loss = criterion(output, target)</span><br><span class="line"></span><br><span class="line">       output = torch.nn.functional.softmax(output, dim=<span class="number">1</span>)</span><br><span class="line">       acc1, acc5 = accuracy(output, target, topk=(<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">       batch_size = images.shape[<span class="number">0</span>]</span><br><span class="line">       <span class="comment"># 写下在tensorboard</span></span><br><span class="line">       metric_logger.update(loss=loss.item())</span><br><span class="line">       metric_logger.meters[<span class="string">&#x27;acc1&#x27;</span>].update(acc1.item(), n=batch_size)</span><br><span class="line">       metric_logger.meters[<span class="string">&#x27;acc5&#x27;</span>].update(acc5.item(), n=batch_size)</span><br><span class="line">       </span><br><span class="line">        metric_logger.synchronize_between_processes()</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">f&#x27;acc1:<span class="subst">&#123;metric_logger.acc1&#125;</span>, acc5:<span class="subst">&#123;metric_logger.acc5&#125;</span>&#x27;</span>)</span><br><span class="line">   <span class="comment"># return &#123;k: meter.global_avg for k, meter in metric_logger.items()&#125;</span></span><br><span class="line">   <span class="keyword">return</span> &#123;k: meter.global_avg <span class="keyword">for</span> k, meter <span class="keyword">in</span> metric_logger.meters.items()&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>返回的是misc记录的</p><h3 id="3-3-2训练函数代码"><a href="#3-3-2训练函数代码" class="headerlink" title="3.3.2训练函数代码"></a>3.3.2训练函数代码</h3><p>首先是和之前一样的，把图片还有属性传入到显卡上面，之后使用模型来进行预测，然后设置优化器，之后就是计算交叉熵，迭代次数一般是在batch开始来进行zero_grad，这个修改的我有点看不懂，应该是在求loss的时候就进行更新。</p><p>最后一步就是log来进行就misc</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16789737524861678973751741.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_one_epoch</span>(<span class="params">model: torch.nn.Module, criterion: torch.nn.Module,</span></span><br><span class="line"><span class="params">                    data_loader: Iterable, optimizer: torch.optim.Optimizer,</span></span><br><span class="line"><span class="params">                    device: torch.device, epoch: <span class="built_in">int</span>, loss_scaler, max_norm: <span class="built_in">float</span> = <span class="number">0</span>, log_writer=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                    args=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> log_writer <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;log_dir <span class="subst">&#123;log_writer.log_dir&#125;</span>&#x27;</span>)</span><br><span class="line">    model.train(<span class="literal">True</span>)</span><br><span class="line">    print_feq = <span class="number">2</span></span><br><span class="line">    accum_iter = args.accum_iter</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> data_iter_step, (samples, targets) <span class="keyword">in</span> <span class="built_in">enumerate</span>(data_loader):</span><br><span class="line">        samples = samples.to(device, non_blocking=<span class="literal">True</span>)</span><br><span class="line">        targets = targets.to(device, non_blocking=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        output = model(samples)</span><br><span class="line"></span><br><span class="line">        warmup_lr = args.lr</span><br><span class="line">        optimizer.param_groups[<span class="number">0</span>][<span class="string">&quot;lr&quot;</span>] = warmup_lr</span><br><span class="line"></span><br><span class="line">        loss = criterion(output, targets)</span><br><span class="line">        loss /= accum_iter</span><br><span class="line"></span><br><span class="line">        loss_scaler(loss, optimizer, clip_grad=max_norm,</span><br><span class="line">                    parameters=model.parameters(), create_graph=<span class="literal">False</span>,</span><br><span class="line">                    update_grad=(data_iter_step + <span class="number">1</span>) % accum_iter == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        loss_val = loss.item()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 完成一次epoch就进行置为，走</span></span><br><span class="line">        <span class="keyword">if</span> (data_iter_step + <span class="number">1</span>) % accum_iter == <span class="number">0</span>:</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> math.isfinite(loss_val):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;loss is <span class="subst">&#123;loss_val&#125;</span> &amp; stop training&quot;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> log_writer <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> (data_iter_step + <span class="number">1</span>) % accum_iter == <span class="number">0</span>:</span><br><span class="line">            epoch_1000x = <span class="built_in">int</span>((data_iter_step / <span class="built_in">len</span>(data_loader) + epoch) * <span class="number">1000</span>)</span><br><span class="line">            log_writer.add_scalar(<span class="string">&quot;loss&quot;</span>, loss, epoch_1000x)</span><br><span class="line">            log_writer.add_scalar(<span class="string">&quot;lr&quot;</span>, warmup_lr, epoch_1000x)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Epoch:<span class="subst">&#123;epoch&#125;</span>,loss:<span class="subst">&#123;loss&#125;</span>,step:<span class="subst">&#123;data_iter_step&#125;</span>,lr:<span class="subst">&#123;warmup_lr&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # gather the stats from all processes</span></span><br><span class="line">    <span class="comment"># log_writer.synchronize_between_processes()</span></span><br><span class="line">    <span class="comment"># print(&quot;Averaged stats:&quot;, log_writer)</span></span><br><span class="line">    <span class="comment"># return &#123;k: meter.global_avg for k, meter in log_writer.meters.items()&#125;</span></span><br></pre></td></tr></table></figure><p>上面的代码逻辑，可以多次复用不同的模型</p><p>如果要保存模型，使用save就可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.output_dir:</span><br><span class="line">                   <span class="built_in">print</span>(<span class="string">&quot;saving checkpoints....&quot;</span>)</span><br><span class="line">                   misc.save_model(</span><br><span class="line">                       args=args, model=model, model_without_ddp=model,</span><br><span class="line">                       optimizer=optimizer, epoch=epoch, loss_scaler=loss_scaler</span><br><span class="line">                   )</span><br></pre></td></tr></table></figure><h1 id="4-test阶段"><a href="#4-test阶段" class="headerlink" title="4.test阶段"></a>4.test阶段</h1><p>我们可以直接仿照val阶段来进行计算，就可以，变成eval，数据放到test里面，然后使用模型来进行计算</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-预备知识&quot;&gt;&lt;a href=&quot;#0-预备知识&quot; class=&quot;headerlink&quot; title=&quot;0.预备知识&quot;&gt;&lt;/a&gt;0.预备知识&lt;/h1&gt;&lt;p&gt;收先我们知道，一般大型公司都有一台机器才能够外网访问，其他机器都只能访问内网，我们把进行外网访问的机器称为跳</summary>
      
    
    
    
    
    <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="pytorch" scheme="http://yoursite.com/tags/pytorch/"/>
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>jvm小结</title>
    <link href="http://yoursite.com/2023/03/03/jvm%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2023/03/03/jvm%E5%B0%8F%E7%BB%93/</id>
    <published>2023-03-03T09:11:40.000Z</published>
    <updated>2023-03-05T08:19:37.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-类文件结构详解"><a href="#1-类文件结构详解" class="headerlink" title="1.类文件结构详解"></a>1.类文件结构详解</h1><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktop%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88.png"></p><p>JVM只认识class文件所有的虚拟机都只支持字节码。在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。而且JVM虚拟机</p><p>可以说<code>.class</code>文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</p><p>所以 jvm是跨语言的平台。</p><h2 id="1-2class类文件的结构"><a href="#1-2class类文件的结构" class="headerlink" title="1.2class类文件的结构"></a>1.2class类文件的结构</h2><p>主要包括魔数，class的版本号，常量池，访问标志，当前值，字段表，方法表，睡醒吧IAO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; //Class 文件的标志</span><br><span class="line">    u2             minor_version;//Class 的小版本号</span><br><span class="line">    u2             major_version;//Class 的大版本号</span><br><span class="line">    u2             constant_pool_count;//常量池的数量</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];//常量池</span><br><span class="line">    u2             access_flags;//Class 的访问标记</span><br><span class="line">    u2             this_class;//当前类</span><br><span class="line">    u2             super_class;//父类</span><br><span class="line">    u2             interfaces_count;//接口</span><br><span class="line">    u2             interfaces[interfaces_count];//一个类可以实现多个接口</span><br><span class="line">    u2             fields_count;//Class 文件的字段属性</span><br><span class="line">    field_info     fields[fields_count];//一个类可以有多个字段</span><br><span class="line">    u2             methods_count;//Class 文件的方法数量</span><br><span class="line">    method_info    methods[methods_count];//一个类可以有个多个方法</span><br><span class="line">    u2             attributes_count;//此类的属性表中的属性数</span><br><span class="line">    attribute_info attributes[attributes_count];//属性表集合</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-2-1魔数"><a href="#1-2-1魔数" class="headerlink" title="1.2.1魔数"></a>1.2.1魔数</h3><p>魔数就是进行判断验证，这个文件是不是能被jvm接受的</p><h3 id="1-2-2版本号"><a href="#1-2-2版本号" class="headerlink" title="1.2.2版本号"></a>1.2.2版本号</h3><p>首先是小版本号，接着就是大版本号</p><h3 id="1-2-3常量池"><a href="#1-2-3常量池" class="headerlink" title="1.2.3常量池"></a>1.2.3常量池</h3><p>常量池从1开始，到n-1。</p><p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16780000496321678000048909.png"></p><p>1个word是tag，然后看不同的类型。不同的属性，有name还有length。以utf8位例子，首先是tage，接着2个word是length之后就是这些长度的byte。</p><h3 id="1-2-4访问标志-Access-Flags"><a href="#1-2-4访问标志-Access-Flags" class="headerlink" title="1.2.4访问标志(Access Flags)"></a>1.2.4访问标志(Access Flags)</h3><p>这个就是来进行判断方法是不是抽象类还是公开类，或者是函数是不是抽象的，这个只需要把正确的表示，进行想或</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png"></p><h3 id="1-2-5-当前类（This-Class）、父类（Super-Class）、接口（Interfaces）索引集合"><a href="#1-2-5-当前类（This-Class）、父类（Super-Class）、接口（Interfaces）索引集合" class="headerlink" title="1.2.5 当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合"></a>1.2.5 当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合</h3><p>顺序的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;//当前类</span><br><span class="line">u2             super_class;//父类</span><br><span class="line">u2             interfaces_count;//接口</span><br><span class="line">u2             interfaces[interfaces_count];//一个类可以实现多个接口</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p><p>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中</p><hr><h3 id="1-2-6字段表"><a href="#1-2-6字段表" class="headerlink" title="1.2.6字段表"></a>1.2.6字段表</h3><p>描述的接口生命的变量。然后看他是不静态变量，类变量还是final修饰的</p><p><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</p><p><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；（ 从常量池检查到）</p><p><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；</p><p><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</p><p><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</p><h3 id="1-2-7方法表"><a href="#1-2-7方法表" class="headerlink" title="1.2.7方法表"></a>1.2.7方法表</h3><p>和字段表一样 ，不过这个就是在方法上面了，还是访问表示，名称索引，描述</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png"></p><h3 id="1-2-8属性表"><a href="#1-2-8属性表" class="headerlink" title="1.2.8属性表"></a>1.2.8属性表</h3><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p><hr><h2 id="1-3虚拟机类加载机制"><a href="#1-3虚拟机类加载机制" class="headerlink" title="1.3虚拟机类加载机制"></a>1.3虚拟机类加载机制</h2><p>首先记住加载流程</p><p>加载-linking-初始化-使用</p><h3 id="1-3-1加载"><a href="#1-3-1加载" class="headerlink" title="1.3.1加载"></a>1.3.1加载</h3><p>加载就是把磁盘上的内容存到内存上去</p><p>主动加载（包括new，invoke，静态变量，使用静态方法）</p><p>被动加载：初次之外都是被动</p><h3 id="1-3-2加载过程"><a href="#1-3-2加载过程" class="headerlink" title="1.3.2加载过程"></a>1.3.2加载过程</h3><p>通过类的路径来获得类文件class，讲这个二进制转化俄日运行内存里面的数据结构，最后在内存生成一个对象，作为入口</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li></ol><h3 id="1-3-3链接-验证"><a href="#1-3-3链接-验证" class="headerlink" title="1.3.3链接-验证"></a>1.3.3链接-验证</h3><p>验证代码文件是不是满足class文件的标准，还有语法验证，语义验证（本来是int类型，却是用long的方法），最后一个是符号验证（通常来讲，就是是不是访问了被进制的类，protect对象子类的）</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5.png"></p><h3 id="1-3-4准备"><a href="#1-3-4准备" class="headerlink" title="1.3.4准备"></a>1.3.4准备</h3><p>准备阶段就是进行填入初始值，质包括被static修饰的变量，初始化为全0</p><p><strong>比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。（初始化为0，之后才是进行赋值）</strong></p><p><strong>敞常量就是原始状态</strong></p><p><strong>特殊情况：比如给 value 变量加上了 final 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</strong></p><h3 id="1-3-5解析"><a href="#1-3-5解析" class="headerlink" title="1.3.5解析"></a>1.3.5解析</h3><p>进行减符号引用，转化为内存地址</p><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作<strong>主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符</strong> 7 类符号引用进行。</p><p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><p>**符号引用（如类的全限定名）解析为直接引用（类在实际内存中的地址） **</p><hr><h3 id="1-3-6类初始化"><a href="#1-3-6类初始化" class="headerlink" title="1.3.6类初始化"></a>1.3.6类初始化</h3><p>就是执行clinit方法</p><p>在这个阶段把之前的static变量进行赋值，这个时候才会UI变成113，不是一开始就是113</p><p>有静态方法就是由clint</p><h3 id="1-3-7常用的类加载器"><a href="#1-3-7常用的类加载器" class="headerlink" title="1.3.7常用的类加载器"></a>1.3.7常用的类加载器</h3><p>一个最开始的bootstrap，一个ext，一个app，最低那个曾就是开始的bootstrap</p><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li><li><strong>AppClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><p>自定义只需要实现loadclass，找到这个全限定的地址的二进制</p><h3 id="1-3-8双亲委派"><a href="#1-3-8双亲委派" class="headerlink" title="1.3.8双亲委派"></a>1.3.8双亲委派</h3><p>就是递归寻找，首先智商往下到达最顶层bootstrap，之后才是ext，最后才是app，看他的父类能不能处理，不能就自己进行加载</p><p>除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，很明显需要继承 <code>ClassLoader</code>。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-类文件结构详解&quot;&gt;&lt;a href=&quot;#1-类文件结构详解&quot; class=&quot;headerlink&quot; title=&quot;1.类文件结构详解&quot;&gt;&lt;/a&gt;1.类文件结构详解&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-be</summary>
      
    
    
    
    
    <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>resnet基础模型</title>
    <link href="http://yoursite.com/2023/02/17/resnet%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2023/02/17/resnet%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B/</id>
    <published>2023-02-17T09:09:49.000Z</published>
    <updated>2023-02-18T08:13:51.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据集搭建"><a href="#1-数据集搭建" class="headerlink" title="1.数据集搭建"></a>1.数据集搭建</h1><p>使用经典的csv读取数据，然后再进行构建自己的dataset的时候，通过csv ，直接获得图片地址，使用pil来读取图像，使用int强转label（label本来是是string，通过构建字典dict来得到的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">    img, label = self.images[idx], self.labels[idx]</span><br><span class="line">    <span class="comment"># 返回图像,下面的std是来自imagenet</span></span><br><span class="line">    tf = transforms.Compose([</span><br><span class="line">        <span class="keyword">lambda</span> x: Image.<span class="built_in">open</span>(x).convert(<span class="string">&#x27;RGB&#x27;</span>),  <span class="comment"># string path= &gt; image data</span></span><br><span class="line">        transforms.Resize((<span class="built_in">int</span>(self.resize * <span class="number">1.25</span>), <span class="built_in">int</span>(self.resize * <span class="number">1.25</span>))),</span><br><span class="line">        transforms.RandomRotation(<span class="number">15</span>),</span><br><span class="line">        transforms.CenterCrop(self.resize),</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],</span><br><span class="line">                             std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    img = tf(img)</span><br><span class="line">    label = torch.tensor(label)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img, label</span><br></pre></td></tr></table></figure><p>直接读取所有的文件，构建csv</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_csv</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构建csv，返回当前路径的图片的属性</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    file_name = <span class="string">&#x27;./label.csv&#x27;</span></span><br><span class="line">    type_dir = glob.glob(os.path.join(self.root, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">        writer = csv.writer(csvfile)</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">type</span> <span class="keyword">in</span> type_dir:</span><br><span class="line">            person_dir = glob.glob(os.path.join(<span class="built_in">type</span>, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">            <span class="keyword">for</span> person <span class="keyword">in</span> person_dir:</span><br><span class="line">                emotion_dir = glob.glob(os.path.join(person, <span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">                <span class="keyword">for</span> emotion <span class="keyword">in</span> emotion_dir:</span><br><span class="line">                    label = emotion.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">                    img_dir = glob.glob(os.path.join(emotion, <span class="string">&#x27;*.jpeg&#x27;</span>))</span><br><span class="line">                    <span class="keyword">for</span> img <span class="keyword">in</span> img_dir:</span><br><span class="line">                        writer.writerow([img, label])</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;writting one person&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;process ok&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>、</p><p>之后就是进行分割数据集，train，val，test&#x3D;6:2：2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, path, resize, mode</span>):</span><br><span class="line">    <span class="built_in">super</span>(NIREmotionDatasets, self).__init__()</span><br><span class="line">    <span class="comment"># 进行自定义标签</span></span><br><span class="line">    self.class_dir = &#123;<span class="string">&quot;Anger&quot;</span>: <span class="number">0</span>, <span class="string">&quot;Disgust&quot;</span>: <span class="number">1</span>, <span class="string">&quot;Fear&quot;</span>: <span class="number">2</span>, <span class="string">&quot;Happiness&quot;</span>: <span class="number">3</span>, <span class="string">&quot;Sadness&quot;</span>: <span class="number">4</span>, <span class="string">&quot;Surprise&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">    self.root = path</span><br><span class="line">    self.resize = resize</span><br><span class="line">    self.images, self.labels = self.load_csv(<span class="string">&#x27;./label.csv&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&quot;train&quot;</span>:</span><br><span class="line">        self.images = self.images[:<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.images))]</span><br><span class="line">        self.labels = self.labels[:<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.labels))]</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">&#x27;val&#x27;</span>:  <span class="comment"># 20% = 60%-&gt;80%</span></span><br><span class="line">        self.images = self.images[<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.images)):<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.images))]</span><br><span class="line">        self.labels = self.labels[<span class="built_in">int</span>(<span class="number">0.6</span> * <span class="built_in">len</span>(self.labels)):<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.labels))]</span><br><span class="line">    <span class="keyword">elif</span> mode == <span class="string">&#x27;test&#x27;</span>:  <span class="comment"># 20% = 80%-&gt;9999%</span></span><br><span class="line">        self.images = self.images[<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.images)):<span class="built_in">int</span>(<span class="number">0.99999</span> * <span class="built_in">len</span>(self.images))]</span><br><span class="line">        self.labels = self.labels[<span class="built_in">int</span>(<span class="number">0.8</span> * <span class="built_in">len</span>(self.labels)):<span class="built_in">int</span>(<span class="number">0.99999</span> * <span class="built_in">len</span>(self.labels))]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-train模板"><a href="#2-train模板" class="headerlink" title="2.train模板"></a>2.train模板</h1><p>因为resnet在timm库里直接由，我们直接进行调用</p><p>构建代码步骤</p><ol><li>构建argparse，直接复制粘贴</li><li>构建dataloader，传入我们的datasets，然后进行shuttle，设置batch</li><li>进行设置crition，adam还有model，模型直接进行调用，然后传入之前的pth，使用load</li><li>设置model的最后一层为class层数 ，进行修改后放入device</li><li>之后就是for语句了，在epoch里面</li><li>首先是进行验证，验证，是计算正确率（这个就是，accurate的计算方法</li><li>之后就是train，train需要设置为train模式，然后这个是计算loss的</li><li>上面的常规就是zerograd，然后计算pred，pred与y计算loss，之后，loss进行反串，优化器进行更新</li><li>一轮后更新学习率lr</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">best_acc = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(args.input_size)</span><br><span class="line">    datasets_train = build_datasets(<span class="string">&#x27;train&#x27;</span>, args)</span><br><span class="line">    datasets_val = build_datasets(<span class="string">&#x27;test&#x27;</span>, args)</span><br><span class="line">    emotion_idx = datasets_train.class_dir</span><br><span class="line">    train_loader = torch.utils.data.DataLoader(datasets_train, batch_size=args.batch_size, shuffle=<span class="literal">True</span>,</span><br><span class="line">                                               num_workers=args.num_workers)</span><br><span class="line">    val_loader = torch.utils.data.DataLoader(datasets_val, batch_size=args.batch_size, shuffle=<span class="literal">True</span>,</span><br><span class="line">                                             num_workers=args.num_workers)</span><br><span class="line">    model_resnet = resnet18(pretrained=<span class="literal">True</span>)</span><br><span class="line">    checkpoint = torch.load(<span class="string">&#x27;/home/tonnn/.nas/weijia/work/fer/baseline/resnet_base/resnet18_msceleb .pth&#x27;</span>)</span><br><span class="line">    model_resnet.load_state_dict(checkpoint[<span class="string">&#x27;state_dict&#x27;</span>], strict=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    model = nn.Sequential(*<span class="built_in">list</span>(model_resnet.children())[:-<span class="number">1</span>],</span><br><span class="line">                          Flatten(),</span><br><span class="line">                          nn.Linear(<span class="number">512</span>, <span class="number">6</span>)</span><br><span class="line">                          ).to(device)</span><br><span class="line">    val_num = <span class="built_in">len</span>(val_loader)</span><br><span class="line">    train_num = <span class="built_in">len</span>(train_loader)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;using &#123;&#125; images for training, &#123;&#125; images for validation.&quot;</span>.<span class="built_in">format</span>(train_num, val_num))</span><br><span class="line"></span><br><span class="line">    params = <span class="built_in">list</span>(model.parameters())</span><br><span class="line">    optimizer = torch.optim.SGD(params, lr=args.lr, weight_decay=<span class="number">1e-4</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line">    scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=<span class="number">10</span>, gamma=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    criteon = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练start</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(args.epochs):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch <span class="subst">&#123;epoch&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;length of dataloader_train is <span class="subst">&#123;<span class="built_in">len</span>(train_loader)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        acc = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Evaluating...&quot;</span>)</span><br><span class="line"></span><br><span class="line">            model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                <span class="keyword">for</span> x, y <span class="keyword">in</span> val_loader:</span><br><span class="line">                    x, y = x.to(device), y.to(device)</span><br><span class="line">                    logits = model(x)</span><br><span class="line">                    pred = logits.argmax(dim=<span class="number">1</span>)</span><br><span class="line">                    <span class="comment"># 找出最大值作为答案</span></span><br><span class="line">                    acc += torch.eq(pred, y.to(device)).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">            val_acc = acc / <span class="built_in">len</span>(val_loader)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;[epoch %d]  val_accuracy: %.3f&#x27;</span> %</span><br><span class="line">                  (epoch + <span class="number">1</span>,  val_acc))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> val_acc &gt; best_acc:</span><br><span class="line">                best_acc = val_acc</span><br><span class="line">                torch.save(model.state_dict(), <span class="string">&#x27;accuracy_loss_change_train_50.mdl&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        model.train()</span><br><span class="line">        <span class="keyword">for</span> step,(x,y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">            x, y = x.to(device), y.to(device)</span><br><span class="line">            logits = model(x)</span><br><span class="line">            loss = criteon(logits,y)</span><br><span class="line"></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">        scheduler.step()</span><br><span class="line">        <span class="comment"># 更新 lr</span></span><br></pre></td></tr></table></figure><h1 id="3-进行预测test还有读取pth继续进行训练"><a href="#3-进行预测test还有读取pth继续进行训练" class="headerlink" title="3.进行预测test还有读取pth继续进行训练"></a>3.进行预测test还有读取pth继续进行训练</h1><p>预测函数predict，我们新建一个文件，然后还是要把预测的图片路径传入进来，然后就是进行加载模型，载入权重，之后使用nograd来进行计算，最后还需要id到属性的字典来进行映射</p><ol><li>使用dataset读取图片传入到dataloader</li><li>设置enviroment来进行多卡推理</li><li>设置模型，进行加载权重，使用模型的load’函数进行加载</li><li>最后就是with nograd’，进行推理，推理的时候，数据也要传到cuda上面</li><li>然后找到最大的索引，之后通过反向查询，得到他的名称</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">os.environ[<span class="string">&#x27;CUDA_VISIBLE_DEVICES&#x27;</span>] = <span class="string">&#x27;0,1&#x27;</span></span><br><span class="line"></span><br><span class="line">   device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">   test_datasets = build_datasets(<span class="string">&quot;test&quot;</span>, get_args_parser().parse_args())</span><br><span class="line"></span><br><span class="line">   test_loader = torch.utils.data.DataLoader(</span><br><span class="line">       test_datasets, batch_size=args.batch_size, shuffle=<span class="literal">False</span>,</span><br><span class="line">       num_workers=args.num_workers)</span><br><span class="line"></span><br><span class="line">   class_idx = test_datasets.class_dir</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 加载模型</span></span><br><span class="line">   pth_path = <span class="string">&#x27;accuracy_loss_change_train_50.mdl&#x27;</span></span><br><span class="line">   model = resnet18()</span><br><span class="line">   model = nn.Sequential(*<span class="built_in">list</span>(model.children())[:-<span class="number">1</span>],</span><br><span class="line">                         Flatten(),</span><br><span class="line">                         nn.Linear(<span class="number">512</span>, <span class="number">6</span>)</span><br><span class="line">                         ).to(device)</span><br><span class="line">   model.load_state_dict(torch.load(pth_path))</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;loaded from ckpt!&#x27;</span>)</span><br><span class="line">   model = nn.DataParallel(model)</span><br><span class="line">   model = model.cuda()</span><br><span class="line">   model.<span class="built_in">eval</span>()</span><br><span class="line">   acc = <span class="number">0</span></span><br><span class="line">   ans = []</span><br><span class="line">   <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">       <span class="keyword">for</span> x, y <span class="keyword">in</span> test_loader:</span><br><span class="line">           x, y = x.cuda(), y.cuda()</span><br><span class="line">           logits = model(x)</span><br><span class="line">           pred = logits.argmax(dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> x1 <span class="keyword">in</span> pred:</span><br><span class="line">               ans.append(find(class_idx, <span class="built_in">int</span>(x1)))</span><br><span class="line">           <span class="comment"># 找出最大值作为答案</span></span><br><span class="line">           acc += torch.eq(pred, y.to(device)).<span class="built_in">sum</span>().<span class="built_in">float</span>().item()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继续训练和之前的predict一样，看args的startt是不是0，不是0，就进行加载权重</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if args.start_epoch !=0:</span><br><span class="line">      model.load_state_dict = torch.load(&#x27;accuracy_loss_change_train_1003.mdl&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-pytorch多卡运行，读取还有保存权重"><a href="#4-pytorch多卡运行，读取还有保存权重" class="headerlink" title="4.pytorch多卡运行，读取还有保存权重"></a>4.pytorch多卡运行，读取还有保存权重</h1><p>多卡运行，上面已经有操作了</p><ol><li>首先设置os的黄精为0,1</li><li>然后加载到dataparallel上面</li><li>之后模型移动到cuda</li><li>然后在训练和预测的时候数据移动到cuda</li></ol><p>和上面没有什么差别，支部够要移动一下，普通是移动到device</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">criteon = nn.CrossEntropyLoss()</span><br><span class="line">   <span class="comment"># if args.start_epoch !=0:</span></span><br><span class="line">   <span class="comment">#     model.load_state_dict = torch.load(&#x27;accuracy_loss_change_train_1003.mdl&#x27;)</span></span><br><span class="line">   <span class="comment">#     # model.load_state_dict(torch.load(&#x27;accuracy_loss_change_train_3.mdl&#x27;))</span></span><br><span class="line"></span><br><span class="line">   model = nn.DataParallel(model)</span><br><span class="line">   model = model.cuda()</span><br><span class="line">   <span class="comment"># 训练start</span></span><br><span class="line">   <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,args.epochs):</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">f&#x27;Epoch <span class="subst">&#123;epoch&#125;</span>&#x27;</span>)</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">f&#x27;length of dataloader_train is <span class="subst">&#123;<span class="built_in">len</span>(train_loader.dataset)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">       acc = <span class="number">0.0</span></span><br><span class="line">       <span class="keyword">if</span> epoch % <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&quot;Evaluating...&quot;</span>)</span><br><span class="line"></span><br><span class="line">           model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">           <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">               <span class="keyword">for</span> x, y <span class="keyword">in</span> val_loader:</span><br><span class="line">                   x, y = x.cuda(), y.cuda()</span><br><span class="line">                   logits = model(x)</span><br><span class="line">                   pred = logits.argmax(dim=<span class="number">1</span>)</span><br><span class="line">                   <span class="comment"># 找出最大值作为答案</span></span><br><span class="line">                   acc += torch.eq(pred, y.cuda()).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">           val_acc = acc / <span class="built_in">len</span>(val_loader.dataset)</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&#x27;[epoch %d]  val_accuracy: %.3f&#x27;</span> %</span><br><span class="line">                 (epoch + <span class="number">1</span>,  val_acc))</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> val_acc &gt; best_acc:</span><br><span class="line">               best_acc = val_acc</span><br><span class="line">               file_name = <span class="string">&#x27;/home/tonnn/.nas/weijia/work/fer/baseline/resnet_base/checkpoint/accuracy_loss_change_train_&#x27;</span>+<span class="built_in">str</span>(epoch)+<span class="string">&#x27;.pth&#x27;</span></span><br><span class="line">               torch.save(model.state_dict(), file_name)</span><br><span class="line"></span><br><span class="line">       model.train()</span><br><span class="line">       <span class="keyword">for</span> step,(x,y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">           x, y = x.cuda(), y.cuda()</span><br><span class="line">           logits = model(x)</span><br><span class="line">           loss = criteon(logits,y)</span><br><span class="line"></span><br><span class="line">           optimizer.zero_grad()</span><br><span class="line">           loss.backward()</span><br><span class="line">           optimizer.step()</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">r&quot;train epoch[&#123;&#125;/&#123;&#125;] loss:&#123;:.3f&#125;&quot;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>,</span><br><span class="line">                                                                    args.epochs,</span><br><span class="line">                                                                    loss.item()))</span><br><span class="line"></span><br><span class="line">       scheduler.step()</span><br><span class="line">       <span class="comment"># 更新 lr</span></span><br></pre></td></tr></table></figure><h1 id="附录：mtcnn进行裁剪"><a href="#附录：mtcnn进行裁剪" class="headerlink" title="附录：mtcnn进行裁剪"></a>附录：mtcnn进行裁剪</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-数据集搭建&quot;&gt;&lt;a href=&quot;#1-数据集搭建&quot; class=&quot;headerlink&quot; title=&quot;1.数据集搭建&quot;&gt;&lt;/a&gt;1.数据集搭建&lt;/h1&gt;&lt;p&gt;使用经典的csv读取数据，然后再进行构建自己的dataset的时候，通过csv ，直接获得图片地址，</summary>
      
    
    
    
    
    <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>面试课程</title>
    <link href="http://yoursite.com/2023/02/08/%E9%9D%A2%E8%AF%95%E8%AF%BE%E7%A8%8B/"/>
    <id>http://yoursite.com/2023/02/08/%E9%9D%A2%E8%AF%95%E8%AF%BE%E7%A8%8B/</id>
    <published>2023-02-08T07:24:32.000Z</published>
    <updated>2023-02-09T07:13:46.431Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="9dcb89ccee295b69f4c252edda7c05460bcd8d47ae7c55bd1906fcf343debf75">0e35b6246a8c35a575b2c91dc60e01c14936a1b25ba8b7fdecb9775ac57febeb7ab6fa87a67189256a663b22fd6a5cb9008c5704e28f35a942d681419b692cf6017da28a2c55f7473bd26acfc0e9b21205ddd1b6a10df005059b1ada6efc6b85a9942a0a858e13c21dcde45164fa84115e152015d916b2c6b43206016fb434ecfda9bc766a7e017d70730fbdc570f2656d358898ddb2e4a42eb02a7803419e6b5dc83a58eaef0f6f7b6a461ed20a7195f14458b40f2111bc8ef118b52bdfc2f71ad4605dbcb08ceccac013abebcee863a1feb5e45774ace4520f70fe06792d0373ec1edffc776057b001406336f00e3b2269ab61735be1bd2dbda90be22eec8358c6eafdcdddfc3f7d8360035e3a717ee36d47884784f43c229651b37c45dd51a4cbab18397d625eaa7df623f6c9b832c434b43bf4ba20146bfadd7f69ab281082db8e9dd8f1ad426ace8beaf67ca504d7ead710b509e3cb826d27b5747234ab0055d223ac762f644a06ea44921a36ab77af87c814158cbeb6d591d317b1e80c2c85b64b9ee3c91d7d3e5e89d82ebd322eb3a545d59750169a95bbdbcddddf0a60da03b4dc59f439250d7025e8638b7b930f4a0da5d532976fc98a44c63193f216746b48ffcbbc162cc99886a884f61fc1dde19982d835b729d20854fd7bc17db72bb0ca3421414d0b5a1aef9cc96b5764ab04900f02583a4eb5cfdaa2e06998d50db7e71335d1ab39f1eb1284c4cace9574bfcadc3fa068e1b8ce9bbf419331784675368eb5fe5d41b438f5b0139b0c8763444fc1fac7227f5b067d8a46d26f975e2ece4ee74fdc3f54256ba0d2e20ffdf8792b3a2127c55016231bc2d0f7bbfe5d1ee0525b4e5aa83ad06c587d32a0b39bb90eedf321bdf82b8d467ec3848463b8ba831a4ee5a5a6bd540c6ca06a62f0f11e8ac29ec4a30f7aa0fba053500f4e83099a97ab6c2010029c8fb8ccfb81f226eea15f9d6576fa6f875819bb94cd442c31def19f94076498271b6472d10eb1a0848476ef4b4b59b995ca3dd1a2bff01b1572ac245d3ef843af344c39d129108fa0e7357d0d25fcf5ebb2585affc48b2dabef10a0875fe9e82da7ed7270eb8ae51744fd467a4624183aa645477a9240efe972c9fc210184965ee22ea14c888f610c09a85459488265676186d06dea966545e0dc8b53b99bab0a146a7fb69e6327c6d85fffeba4e77b306839616ffd5e7e04e31f9871a191b7ed8c5133fdaf9865c3d63ca8f6e57f7b6e290ebbabbe5a48b2cf42b0373d4d9cee72e92c2f697b932f5b323b7bdfe073f242b0601c28da7f39636502c7adb0d092269f3f9f7ab9e89b9fe82cd596cfffba0d4308f152a17e3e0235ad220efbb648f7f94a438d203112b11163487ef3a4da97b2a46e5a6a5b96a7f246d1ccbe0b55f2a784f56664dad55fcacc7f3d64a7226e17b45e10d008d07fbf3a4e3e03c7208aa3560e2b62c33c7e861429ec7485a46086e277f4c37afd92ce435c79e837f7385b248263fab95b5f92f5012623b60e6a8a20b35741113a874ef63d0e334a53765ff3d0d41eb26a7206b1b7f86286e6bb9025ba4d4bf051e5e609e2ead89a01fb552de6f9bb1728e11c8eef15a31b9bd82477783feb9f9e7fe068e6e18ffa2fac6fc19e70e7779f7ba3ec678bdad2ca6766097d01100ba50c1375158cee3df71cc144e5a22bc76b73f7d4f606fac4b93766248007d26c30262e23d972d8d9c2e3aea17bad0299e794be92f03ead5b94d2bf1e1304dc5b31f3b2cfdf93cb32993635e6e418e6f785371a2659af9d116447f00c540622e6f9a416c09c15712d8cdd72567db5657f750684fb7d820952742ed291c00a119ccb75f093b3ba6a94c9b586666a58dfadcc510beff59539fde68ece7a7fc68005a58626d3c8e557fe51be5988ea4dc153caec61ed5ef6586887707a7100fb5630dec2e7ee209c7ccac268ea09192ec8d05add06ca255b971cc821c68bf4d6136ffaea2b92c2891dbad6b426e77e4c3029088a08834f1b7772a98e98af006023f5f5e0b5a6ec2bb335c9090d891415af01cbd2121a76bce74e94959918044c248da4d89592df033e50d63ccf520fbd8aa637773db74ea316f4f2f3bbe659a9dc6f8a842af641f878fd308a7c234a5a8be7c3adfc93f8948932e6ebe58e054101723aa84b3bcd630d8218b807550670d7ae792f16f3835928bfcce35ae26579006eeb3a92521f21dda48b4d81f281cbe1a014acf39f332d529b2c3767502613da538c5a50d0b7ef55ff084705aed78fdf921d3b37acb47eabcf518c999fb42c7911c6d7b6b57cb2d440345b14f000756dca60a453abdb2e17d8b22a690acbbc8ff651fb71d19cadd476da9bf8868237d6bfc8744fbb63fe7634d1bdf13ea2de6526f88ddbacdcff3e5e0ff7e06158e17401514f7d1ec9b620d5c541851323473b7a5e42a5bfecb06f3ec22b0c7d77e75dd79a7d6a5c9e357db90b0c0260cac53d43cbba55444f2b2225fff4fd97133e94f9840b3d76962bf8ce6df8da8183b7d1023778cd45ed7b64495d89de86bdc9e6a07b910fe465b17d534dbbcd1e355648e6ce6cf053ebf7846cd86427844c0658c8165a5cfa827a077ee5b8d7493bb0788b010446e8c6faeae053b6b0684954a1fe8d8c82e13c3487236d21973d33a26a3f3251f65619b5f6d41cc68052a7e40abbc70db83d0c1fdf9f139546f45e6fb2b8152ae1e9d9a621bd6aefeb480070854a45974cdae7217f9e757398ff438c0d5ea41e3b75d70413339aa42c3e0ad0d7e09b9439b5652857b8165c8b3e5ca6da1586b5ea35f8078148017e937229abe9b00f7f4c21f65161f052e87720f04a8c78259882cbb1f1bf887f6a2904abe94792b4c26ff4dbe7c050b5d4f7abe7ec56de275e428156fa0e9d7dfcc1b01ab2c96682be288209e47f28a1a1ce061cc500f456aedabdb754d65cf090c86cee7b379602d69bd9ace5d784f75786f17acfe3f95c4dc88edd3ac6f025af28ad33b5f3f524b8655b28cb3343ce313c55fb9fb7d254193972ddd1b6ac7f8db2334b6e83a79ab3727c91b390f632f7c3093fad2fa3ba381a81ec8a442137d935cfaa4559d739e0b09706e7f8030c82ee8ffb63b02bc3a8fef3052d89a302e745713e70335437bfe87e2bbc19a873e6ab8899e77a5fe9e5ffc0dd5de75fd95357afc4e5718ab142637c6142adb56ffc780e831561a01363b81b9a23de8ab49d2fa9796aa2076ea48ad9f06470ca4f63ef3ae2032ce22ca3636899c9ca781f381ee4782e2fcd669d5883d1846b1409c99da9dd2b03cc6b05d6d22ab69ccf6291890e95a7667cfdef7322be31217475f99d64e496319a81d84d0acd9ab8b34c6895db5a938ccc6d05a1224b611e0a8de60f41754c4fb299f41229b8e7a6c2c8ffcfa8d03c2b3c159402a9ca056e85fdf700229be36b956767277deba4595427ccd6e20f58da082ac5d9d682fe71d5a587166a44993a41e56f122ec5f4f4ad41f534a6d00cda9b9d742d766d1008f97dd0f93f00d694ec36b646a7be7d395e80fb2dfedcb144d3a6c47093cf8b8a6ef9cb3eb37ecf7850e9eb3e2aab1ff66bed192e4e90aeda692815eecb53b1cb0aa82e380286495dcb5bdeafd8ca4ef8a821c0b426b9afd1bf39070def09cd376906592ddf7cc53edd75881da79d3b90f2df735ff5706b09081074086fac52870fb5e191d006c884c576f9646dc26ee5c0fcebd04481621ecab73bd2753b0b5869e9034fa6bdee9cc571ecbf7743495570dda255c551618525938ef274b5287f82e8976dfc9c2b876b7e9a63a8841f167d70f9249df4e708eb909a4fa094eb4d51e7faa0803f1265ac20ef01caaadd80cc331db2c118c7375600f3bfff20b3a9de066af57ca6761083c2deb130a7849ae4125adbf5209552ee4b46fa12b359c19335dffef6571c8de17eb519b8fe9f3589d865b9ff761b7d5c88ed24044ba8e2cbfe203b5a87a93d9c4c3440cf22acd928bb2076870fab46e5ab62eb954f843c97d3fcec6a2b9f9d70c9d01bc16117bae7afdf8b4561dcad5c4ebd46b736dceac90ad1c34f914e3e5979b7a5ff4a5af2602608573ec9b1316fcb7f80af323a8e4130864adf55be8f5ad23737df9fb082ac5c2b53269c4847537fa8be6367113e43b13d0818c55385aa9d1c6d9e472ffa80c27b1e74c9751ba45226fb6830a7124be292e4fb3f9504a447e1c6380c5154bf4971fe3a5dd4e530e4d9b2380a30e9bb138c2f3224d60671b327205153eb4be972ca3e5991c145a73e3bbdf60cbccabc3c90837f1903859be0c77020707d5d3e9d52e7337fc94499e7699481889aef16ec709830eb62f991117ace3cd46b81638366aa2a442e967be9e4001214fd069cd376445a7e551466263242a9f37a9e3856aae0fb27b1b61449843c37cb95465f94457242db4adf1ee6c8fee76914df7dcfce68731ac434828a909d33f27aa7c2757f8dd5533d44de2868a360e294ae97e311241d76f7dde321d37b3e10d48983f1dcdc00119d02dab7cb5101ba00431e5dd022285bf9436787fc53ae5fc62e2579e4dc6089844d87184b618770ed47ae886a6b474345b6dad796f02d24a497972bb05fec51747a63a7be991d73c2e41b4ad4620a6f94c2eef46c22f9cbb177dcc94ff8300130b68703a248d40b4e8c7d42693a0179c8db870d1bfd284d36850475919846377db6e1340987cd714b2f9ee0ca1d01d1c3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    
    <category term="面试经验" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="网课" scheme="http://yoursite.com/tags/%E7%BD%91%E8%AF%BE/"/>
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>alist网盘聚合</title>
    <link href="http://yoursite.com/2023/02/04/alist%E7%BD%91%E7%9B%98%E8%81%9A%E5%90%88/"/>
    <id>http://yoursite.com/2023/02/04/alist%E7%BD%91%E7%9B%98%E8%81%9A%E5%90%88/</id>
    <published>2023-02-04T10:59:27.000Z</published>
    <updated>2023-02-05T08:55:19.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="alist简介"><a href="#alist简介" class="headerlink" title="alist简介"></a>alist简介</h1><p><strong>AList</strong> 是一个支持在本地加载 18 款常见网盘文件列表的工具，它可以让用户直接在浏览器中预览文件、上传文件、下载文件、播放视频、浏览照片，也可以直接在播放器中打开视频文件，还可以配合 aria2 实现文件下载功能。跨平台简单易用。@<a href="https://www.appinn.com/alist-file-list-program/">Appinn</a></p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Appinn-2022-09-16T150310.322.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频"></p><p>感谢 @<strong>imsoff</strong> 推荐。</p><h2 id="AList-–-文件列表程序"><a href="#AList-–-文件列表程序" class="headerlink" title="AList – 文件列表程序"></a>AList – 文件列表程序</h2><p>AList 自己的定位是一个支持多存储的文件列表程序，使用 Gin 和 Solidjs。它可以将以下网盘聚合在一起：</p><ul><li>本地存储</li><li>阿里云盘</li><li>OneDrive &#x2F; Sharepoint（国际版, 世纪互联,de,us）</li><li>天翼云盘 (个人云, 家庭云)</li><li>GoogleDrive</li><li>123云盘</li><li>FTP &#x2F; SFTP</li><li>PikPak</li><li>S3</li><li>又拍云对象存储</li><li>WebDav(支持无API的OneDrive&#x2F;SharePoint)</li><li>Teambition（中国，国际）</li><li>分秒帧</li><li>和彩云 (个人云,家庭云)</li><li>Yandex.Disk</li><li>百度网盘</li><li>夸克网盘</li><li>迅雷网盘</li></ul><p>然后只需要在浏览器中打开，即可预览文件、上传文件、下载文件、直接播放视频、音频。</p><h2 id="在线播放视频效果"><a href="#在线播放视频效果" class="headerlink" title="在线播放视频效果"></a>在线播放视频效果</h2><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-15.59.14.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 1"></p><p>并且提供了几个播放器按钮，直接点击就能跳转。</p><p>不过青小蛙在测试的时候没搞定云字幕，似乎需要下载字幕之后才能加载。</p><h2 id="安装-amp-配置"><a href="#安装-amp-配置" class="headerlink" title="安装 &amp; 配置"></a>安装 &amp; 配置</h2><p>AList 的安装比较简单，对于 Windows 用户，直接下载 .exe 文件之后，使用命令提示符运行，就行了。对于其他平台用户，也差不多，另外也支持 docker 部署，即开机用非常简单。</p><p>也算是0配置，只需要输入命令 alist.exe admin 获取管理员密码，打开浏览器 127.0.0.1:5244 就行了。</p><h2 id="添加存储"><a href="#添加存储" class="headerlink" title="添加存储"></a>添加存储</h2><p>在管理界面，可以添加很多的网盘：</p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-16.30.03.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 2"></p><p>这里就需要<a href="https://alist.nn.ci/zh/guide/drivers/common.html">阅读文档</a>了，但也很简单，最重要的是获取 Token，也提供了自动化获取按钮。不放心的同学可以根据文档说明手动获取。</p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-16.31.09.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 3"></p><h2 id="公网访问"><a href="#公网访问" class="headerlink" title="公网访问"></a>公网访问</h2><p>虽然青小蛙主要用来自己在家用，但的确看到了不少人拿来在公网使用。AList 可以设置公告、用户权限、</p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-16.39.19.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 4"></p><p>嗯，比如<a href="https://kutt.appinn.net/ftlxSu">这种</a>。</p><h2 id="WebDAV"><a href="#WebDAV" class="headerlink" title="WebDAV"></a>WebDAV</h2><p>除了直接将 WebDAV 资源添加进 AList，还支持反向使用，即使用 WebDAV 客户端连接 Alist，然后浏览绑定的内容，这样就极大的扩展了客户端，包括 iPhone、Android 都可以轻松访问你的网盘资源了：</p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-16.47.23.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 5"></p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-16.47.28.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 6"></p><p>怎么说呢，反正省了台 <a href="https://www.appinn.com/tag/nas/">NAS</a> 的感觉。</p><h1 id="2-为什么搭建"><a href="#2-为什么搭建" class="headerlink" title="2.为什么搭建"></a>2.为什么搭建</h1><p>笔者手里有多个网盘，百度云（网课视频），阿里云（电视视频），pikpak（下torrent），还有谷歌云（自用，备份手机的）。</p><p>主要是笔者中午使用pikpak在线客户端很卡，播放视频非常卡顿，不流畅，所以笔者花了一点时间来进行搭建。搭建完成之后的效果就是可以只要输入一个网站，就可以访问多个网盘，而且播放效果，比官网好多 了。</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16755087318811675508731713.png"></p><p>搭建效果如图</p><h1 id="3-搭建教程"><a href="#3-搭建教程" class="headerlink" title="3.搭建教程"></a>3.搭建教程</h1><p>主要参考下面官网文档，本来想使用docker的，但是垃圾服务器，内存根本跑不了docker，所以直接使用的一件脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL &quot;https://alist.nn.ci/v3.sh&quot; | bash -s install</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://alist.nn.ci/zh/guide/install/script.html">https://alist.nn.ci/zh/guide/install/script.html</a> 官网教程</p><p>搭建完成之后，会出现账号密码，这个自己记住。</p><p>之后就是使用如何进行安装网盘。最简单的是pikpak，这个只要输入账号密码就行。具体安装步骤在官网上面。</p><p>百度网盘安装教程：</p><ol><li><a href="https://openapi.baidu.com/oauth/2.0/authorize?response_type=code&amp;client_id=iYCeC9g08h5vuP9UqvPHKKSVrKFXGa1v&amp;redirect_uri=https://tool.nn.ci/baidu/callback&amp;scope=basic,netdisk&amp;qrcode=1">https://openapi.baidu.com/oauth/2.0/authorize?response_type=code&amp;client_id=iYCeC9g08h5vuP9UqvPHKKSVrKFXGa1v&amp;redirect_uri=https://tool.nn.ci/baidu/callback&amp;scope=basic,netdisk&amp;qrcode=1</a></li><li>使用上面网站获取令牌还有secret还有id</li><li>下面看图，不然没有办法正常播放视频</li><li>下载选择非官方就行</li></ol><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16755090388811675509038218.png"></p><p>谷歌网盘：</p><p>这是最复杂的，需要自己申请api接口，然后再把这个接口开放给自己一个人使用，得到接口之后才能进行生成id还有token，具体参考下面这个YouTube博主视频</p><p><a href="https://youtu.be/Hktdyg7L0Bg">https://youtu.be/Hktdyg7L0Bg</a></p><ol><li>创建项目</li><li>然后启用api还有服务，主要使用云盘服务，找到云盘</li><li>之后就是创建姘居，创建OA客户端id，填写外部，然后只要输入自己的电子邮件</li><li>之后就是添加用户，吧自己添加进去</li><li>之后再次回到品聚，创建oa的id，选择应用是桌面客户端之后秘钥还有id就出来了</li><li>之后输入到那个网站，点击code，弹出网页，一直继续</li><li>就会有token出现</li><li>之后就按照放入到alist的后台</li></ol><h1 id="4-反向代理"><a href="#4-反向代理" class="headerlink" title="4.反向代理"></a>4.反向代理</h1><p>下午使用github学生包，白嫖了一个域名，然后，为了懒得记住ip，直接用域名来使用。</p><p>问题是alist使用的5244端口，但是直接输入域名+端口非常不好看，所以使用反向代理，这里使用的是nginx，</p><p>直接下载nginx安装，笔者之前忘了开80端口，一直打不开，以为是自己配置问题。换了apache也是一样的。于是再换回nginx，才发现80没有打开，大坑。打开之后，一直是配置502，一直以为是自己的配置有问题（实际上没有，只是linux内核问题），谷歌发现要设置一个内核关闭，代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsebool -P httpd_can_network_connect 1   </span><br></pre></td></tr></table></figure><p>之后就可以正常访问了，主要的是配置，参考官网，直接在http模块里面添加一个新的server模块，就可以，配置文档etc、nginx、nginxconf里面，修改如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">  proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">  proxy_set_header Host $http_host;</span><br><span class="line">  proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">  proxy_set_header Range $http_range;</span><br><span class="line">proxy_set_header If-Range $http_if_range;</span><br><span class="line">  proxy_redirect off;</span><br><span class="line">  proxy_pass http:<span class="comment">//127.0.0.1:5244;</span></span><br><span class="line">  <span class="meta"># the max size of file to upload</span></span><br><span class="line">  client_max_body_size <span class="number">20000</span>m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;alist简介&quot;&gt;&lt;a href=&quot;#alist简介&quot; class=&quot;headerlink&quot; title=&quot;alist简介&quot;&gt;&lt;/a&gt;alist简介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;AList&lt;/strong&gt; 是一个支持在本地加载 18 款常见网盘文件列表的工具，</summary>
      
    
    
    
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
    <category term="网盘" scheme="http://yoursite.com/tags/%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>一文详解欧易wise和depay</title>
    <link href="http://yoursite.com/2023/02/04/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E6%AC%A7%E6%98%93wise%E5%92%8Cdepay/"/>
    <id>http://yoursite.com/2023/02/04/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E6%AC%A7%E6%98%93wise%E5%92%8Cdepay/</id>
    <published>2023-02-04T09:56:13.000Z</published>
    <updated>2023-02-04T10:52:36.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简要介绍"><a href="#1-简要介绍" class="headerlink" title="1.简要介绍"></a>1.简要介绍</h1><p>之所以写这个的原因是，笔者正在白嫖土耳其的低价优惠。因为埃尔多安经济学，导致人民币兑土耳其不断升高，而且定价在土区也是低价区。所以如何充分利用土区白嫖优惠，就是个问题。</p><p>门前主流的国外网站netflix，Spotify，apple，google，Disney等价格都远远低于国区。但是购买方式只能使用国外的信用卡组织visa或者MasterCard。笔者作为学生党，当然是办不了的。但是oldubil这个软件，提供一个虚拟土耳其mastercard，可以对上述网站进行购买。所以我们的问题就变成如何给oldubil入金了。</p><p>目前有两种方式，笔者尝试的第一种损耗很大，而且还需要进行kyc身份验证，需要使用你的护照信息。第二种是直接通过欧易交易所，交易usdt给土耳其人（因为中国大陆区无法直接交易土耳其，所以还需要注册一个台湾区来进行交易）。</p><p>下面先介绍第一种思路：</p><ol><li>支付宝购买usdt在欧易里面（微信，银行卡也可以）</li><li>在depay里面进行充币操作</li><li>利用depay的虚拟卡给wise汇款</li><li>利用wise进行转换，把美元兑换成土耳其</li><li>最后利用wise发送到oldubil支持的iban银行</li></ol><p>以上每一步都有损耗，交易费，手续费，还有转账费用，笔者一共付出23.8在欧易，到wise里面就只有20了。损耗率有16个点。而且还需要kyc身份认证在wise，总体比较繁琐</p><p>第二种就是直接欧易买卖币，兑换成土耳其</p><ol><li>大陆欧易账号买币</li><li>发送到台湾欧易账号（站内转账）</li><li>最后用台湾的账号卖出为土耳其，填入iban相关的</li></ol><p>下面先介绍一下第一种方法</p><h2 id="1-1-欧易操作"><a href="#1-1-欧易操作" class="headerlink" title="1.1 欧易操作"></a>1.1 欧易操作</h2><blockquote><p><strong>欧易</strong>（英语：OKX；原名<strong>OKEx</strong>）是一间<a href="https://zh.wikipedia.org/wiki/%E7%B8%BD%E9%83%A8">总部</a>位于<a href="https://zh.wikipedia.org/wiki/%E5%A1%9E%E8%88%8C%E5%B0%94">塞舌尔</a>的<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E4%BA%A4%E6%98%93%E6%89%80">加密货币交易所</a>[<a href="https://zh.wikipedia.org/zh-cn/%E6%AC%A7%E6%98%93#cite_note-2">2]</a>，由徐明星于2017年创办[<a href="https://zh.wikipedia.org/zh-cn/%E6%AC%A7%E6%98%93#cite_note-Birnbaum_2022-3">3]</a>。该机构的主营业务是为<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7">用户</a>提供多种加密资产交易服务。2021年2月2日，该交易所正式启用中文名“欧易”[<a href="https://zh.wikipedia.org/zh-cn/%E6%AC%A7%E6%98%93#cite_note-4">4]</a>。2022年1月，OKEx更名为OKX[<a href="https://zh.wikipedia.org/zh-cn/%E6%AC%A7%E6%98%93#cite_note-5">5]</a>。</p></blockquote><p>简单来说就是一个交易所，进行买卖比特币的地方，我们如果要进行买币就要首先认证身份，l1认证就行，使用身份证可以通过。</p><p><strong>第二步就是进行c2c买币</strong>，顾名思义，就是顾客对顾客买币，量大他的折扣才打。目前汇率是1:6.78，但是个人卖家，你卖的少可能会出现1:7的价格。这也是一部分损耗。选择接受的方式进行筛选，微信，支付宝</p><h2 id="1-2depay操作"><a href="#1-2depay操作" class="headerlink" title="1.2depay操作"></a>1.2depay操作</h2><p><a href="https://zhuanlan.zhihu.com/p/596899194">https://zhuanlan.zhihu.com/p/596899194</a></p><blockquote><blockquote><p><em>一、Depay的使用场景有那些？</em></p></blockquote><p>1、Depay Master Visa卡支持绑定支付宝、微信支付、美团外卖、拼多多、Paypal、天猫国际版等等。</p><p>2、支持Stripe商户、google play商店、youtube premium、paypal商户、美区苹果商店、和支持非3DS卡的电商网站</p><p>3、支持国内苹果官网直接绑卡购买iphone和mac，可能会打电话问询，直接说即可。</p><p>4、暂不支持苹果支付APPLE PAY和谷歌PAY</p><p>5、所有等级的卡（Lite、标准、高级、白金、黑金）都满足以上场景</p></blockquote><p>简而言之就是提供了一个虚拟mastercard，但是入金的方式只能通过比特币来入金，所以我们需要第一步的欧易来操作。（注意，手续费比较多）</p><ol><li>首先把欧易里面的usdt发送给depay</li><li>我们需要在depay里面找到usdt，还有他的合约链，复制合约链还有id来到欧易</li><li><strong>在欧易里面选择提币，然后选择连上转账，输入地址还有链，这个时候因为是外链会有0.8的手续费</strong></li><li>之后等过5分钟到达depay</li><li>我们在等待时间，先开一张虚拟卡，使用身份证可以验证，然后就是最便宜的没有开卡费用，但是月费是1刀，还有交易费</li><li>开卡完成，我们回到usdt，还需要进行转换为usd才能放入depay一般是97折进行转换</li><li>转换放入需要扣除0.3的手续，到此23.8就只有21.76左右了</li></ol><h2 id="1-3wise操作"><a href="#1-3wise操作" class="headerlink" title="1.3wise操作"></a>1.3wise操作</h2><blockquote><h2 id="什麼是-Wise？"><a href="#什麼是-Wise？" class="headerlink" title="什麼是 Wise？"></a><strong>什麼是 Wise？</strong></h2><p>Wise（舊稱Transferwise），是一家提供國際匯款轉賬服務的 P2P 國際匯款平台。Wise 也是世界上成長速度最快的線上匯款、電子貨幣服務之一。</p><p>Wise 因匯率和定價透明，加上直接將資金匯到海外，省去高昂的銀行手續費，吸引超過1,000萬的用戶。目前 Wise 可支持40多個國家的貨幣轉賬，非常適合在海外工作，或是擁有海外收入的用戶。</p></blockquote><p>简单来说wise就是跨境汇款工具，因为普通银行汇款会有巨额的手续费没所以才有了wise，就是减少手续费 的。</p><p>但是wise这个软件是需要进行进行身份验证，前面两个使用身份证就行，这个必须使用护照（还好现在办护照容易，笔者是上个月办的，听到可以恢复办理护照，就赶快办了一个）。说回正题，现在你还需要入金20刀还有护照才能激活wise，才可以开通跨境转账成为土耳其货币，具体步骤如下。</p><ol><li>使用depay进行付款20美金，注意，<strong>又有手续费，0.8必须扣得</strong></li><li>之后就是身份验证，需要护照还有自拍</li><li>最后一步就是转账，具体流程如下图</li><li>转账之前还需要把美元兑换成土耳其，也有损耗</li><li>发送固定是24土耳其，合计1美金左右的手续费</li></ol><p>简单来说就是去oldubil里面 选择iban转账，然后去oldubil找到银行，复制iban和名称回到wise，最后一步就是附言要写上自己的虚拟卡（这个是oldubil提供的土耳其虚拟卡），如下图所示</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16755067588821675506758131.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16755067768841675506776221.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16755067878851675506787752.png"></p><h2 id="1-4oldubil操作"><a href="#1-4oldubil操作" class="headerlink" title="1.4oldubil操作"></a>1.4oldubil操作</h2><p>这个是土耳其的虚拟卡软件，但是注册的话，国内手机号没有办法使用。我是用的是土乌克兰lifecell的esim，使用国内的万事达借记卡，可以购买手机号。优点不需要实名认证，价格是5块钱一个月。使用的是美版se2，进行使用esim的</p><p>esim连接：<a href="https://www.lifecell.ua/en/sim-and-number/eSIM/">https://www.lifecell.ua/en/sim-and-number/eSIM/</a></p><blockquote><p>万事达借记卡：使用的是中国银行的莫奈，有3ds，可以在某些网站进行验证，有网申连接，主要参考这个网站</p><p><a href="https://poplite.xyz/post/2018/03/05/boc-debit-card-guide-for-online-payment.html">https://poplite.xyz/post/2018/03/05/boc-debit-card-guide-for-online-payment.html</a>   还有dotofcards这个群组。唯一缺点就是需要自己手动结汇购汇，这个是会占用自己的5w外汇额度的。美国运通的借记卡就不需要，但是没有3ds，有些网站买不了东西。</p></blockquote><p>最后就是转账到oldubil里面，然后使用这个提供的银行卡去买spotify，netflix</p><h1 id="2-方法总结"><a href="#2-方法总结" class="headerlink" title="2.方法总结"></a>2.方法总结</h1><p>上述方法，一共损耗0.8（欧易费用）+0.3（depay汇入费用）+（0.86wise汇入费用）+（1.2wise会出费用），这还没有计算，usdt打折，还有还有usdt转入usd的损耗，还有美元转土耳其的损耗。目前就损耗了3美元，流程繁琐，而且损耗严重。</p><p>第二种方法就是直接买usdt，通过欧易发送到台湾账户，这个站内转账没有损害，而且我们只需要在卖比特币给土耳其人就行，时间很快。主要有下面的教程</p><p><a href="https://yummy.best/how-to-top-up-oldubil/">https://yummy.best/how-to-top-up-oldubil/</a>  参考下面的教程</p><blockquote><h2 id="入金步骤（来自-沐攸-投稿）"><a href="#入金步骤（来自-沐攸-投稿）" class="headerlink" title="入金步骤（来自 沐攸 投稿）"></a>入金步骤（来自 <a href="https://t.me/Mylovetbole">沐攸</a> 投稿）</h2><p><strong>第一步</strong>：注册两个欧易账户，一个欧易账号身份认证选择  <code>**大陆+大陆身份证验证**</code> ，另一欧易账户身份认证选择 <code>**台湾+大陆身份证认证**</code> 。</p><blockquote><p>说明：选择台湾账户的账户只需要简单认证  <code>**L1**</code> 即可，不要验证到  <code>**L2**</code> 否则默认成为大陆欧易无法绕过 CNY 进行交易；另一个账户随便。</p></blockquote><p><strong>第二步</strong>：用 <code>**大陆**</code> 的欧易账户购买 USDT 入金欧易（支持微信+支付宝），然后将购买到的 USDT 发送到 <code>**台湾**</code> 欧易账户（<strong>选择站内转账，否则需要支付 0.8 usdt 手续费</strong>）</p><p><strong>第三步</strong>：使用 <code>**台湾**</code> 欧易账户 C2C 交易 → 选择货币为 TRY → 交易方式为银行转账 → 选择 oldubil 支持的银行并填入信息，然后按照如下格式填入发送到聊天框‌‌</p><p><strong>IBAN:‌‌</strong></p><p><strong>Name:</strong></p><p><strong>‌‌Card Number:</strong></p></blockquote><p>第三种就是直接淘宝进行购买，主要使用的是礼品卡，淘宝也有卖的，而且。还有一些专门卖礼品卡的网站。</p><p><a href="https://hezu.wiki/zh/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%BA/%E5%9C%9F%E8%80%B3%E5%85%B6%E7%A4%BC%E5%93%81%E5%8D%A1%E8%B4%AD%E4%B9%B0">https://hezu.wiki/zh/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%BA/%E5%9C%9F%E8%80%B3%E5%85%B6%E7%A4%BC%E5%93%81%E5%8D%A1%E8%B4%AD%E4%B9%B0</a></p><p><a href="https://www.oyunfor.com/tv/netflix-hediye-kodu-karti">https://www.oyunfor.com/tv/netflix-hediye-kodu-karti</a>  主要使用这个，这个基本都有买的。</p><p>总而言之，使用第一种方法是费力不讨好的，但是折腾了很久，也学到了btc一些知识。充值还是推荐后面两种。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简要介绍&quot;&gt;&lt;a href=&quot;#1-简要介绍&quot; class=&quot;headerlink&quot; title=&quot;1.简要介绍&quot;&gt;&lt;/a&gt;1.简要介绍&lt;/h1&gt;&lt;p&gt;之所以写这个的原因是，笔者正在白嫖土耳其的低价优惠。因为埃尔多安经济学，导致人民币兑土耳其不断升高，而且定价</summary>
      
    
    
    
    
    <category term="usdt" scheme="http://yoursite.com/tags/usdt/"/>
    
    <category term="btc" scheme="http://yoursite.com/tags/btc/"/>
    
    <category term="外汇" scheme="http://yoursite.com/tags/%E5%A4%96%E6%B1%87/"/>
    
    <category term="入金" scheme="http://yoursite.com/tags/%E5%85%A5%E9%87%91/"/>
    
    <category term="土耳其" scheme="http://yoursite.com/tags/%E5%9C%9F%E8%80%B3%E5%85%B6/"/>
    
    <category term="mastercard" scheme="http://yoursite.com/tags/mastercard/"/>
    
  </entry>
  
</feed>
