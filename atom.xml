<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-02-08T12:34:19.194Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>weijia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试课程</title>
    <link href="http://yoursite.com/2023/02/08/%E9%9D%A2%E8%AF%95%E8%AF%BE%E7%A8%8B/"/>
    <id>http://yoursite.com/2023/02/08/%E9%9D%A2%E8%AF%95%E8%AF%BE%E7%A8%8B/</id>
    <published>2023-02-08T07:24:32.000Z</published>
    <updated>2023-02-08T12:34:19.194Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b17e63c2e000fe59a34e5f90413d115128839a613d1b13e61c3208c75b082b44">0e35b6246a8c35a575b2c91dc60e01c14936a1b25ba8b7fdecb9775ac57febeb7ab6fa87a67189256a663b22fd6a5cb9008c5704e28f35a942d681419b692cf6017da28a2c55f7473bd26acfc0e9b21205ddd1b6a10df005059b1ada6efc6b85a9942a0a858e13c21dcde45164fa84115e152015d916b2c6b43206016fb434ecfda9bc766a7e017d70730fbdc570f2656d358898ddb2e4a42eb02a7803419e6b5dc83a58eaef0f6f7b6a461ed20a7195f14458b40f2111bc8ef118b52bdfc2f71ad4605dbcb08ceccac013abebcee863a1feb5e45774ace4520f70fe06792d0373ec1edffc776057b001406336f00e3b2269ab61735be1bd2dbda90be22eec8358c6eafdcdddfc3f7d8360035e3a717ee36d47884784f43c229651b37c45dd51a4cbab18397d625eaa7df623f6c9b832c434b43bf4ba20146bfadd7f69ab281082db8e9dd8f1ad426ace8beaf67ca504d7ead710b509e3cb826d27b5747234ab0055d223ac762f644a06ea44921a36ab77af87c814158cbeb6d591d317b1e80c2c85b64b9ee3c91d7d3e5e89d82ebd322eb3a545d59750169a95bbdbcddddf0a60da03b4dc59f439250d7025e8638b7b930f4a0da5d532976fc98a44c63193f216746b48ffcbbc162cc99886a884f61fc1dde19982d835b729d20854fd7bc17db72bb0ca3421414d0b5a1aef9cc96b5764ab04900f02583a4eb5cfdaa2e06998d50db7e71335d1ab39f1eb1284c4cace9574bfcadc3fa068e1b8ce9bbf419331784675368eb5fe5d41b438f5b0139b0c8763444fc1fac7227f5b067d8a46d26f975e2ece4ee74fdc3f54256ba0d2e20ffdf8792b3a2127c55016231bc2d0f7bbfe5d1ee0525b4e5aa83ad06c587d32a0b39bb90eedf321bdf82b8d467ec3848463b8ba831a4ee5a5a6bd540c6ca06a62f0f11e8ac29ec4a30f7aa0fba053500f4e83099a97ab6c2010029c8fb8ccfb81f226eea15f9d6576fa6f875819bb94cd442c31def19f94076498271b6472d10eb1a0848476ef4b4b59b995ca3dd1a2bff01b1572ac245d3ef843af344c39d129108fa0e7357d0d25fcf5ebb2585affc48b2dabef10a0875fe9e82da7ed7270eb8ae51744fd467a4624183aa645477a9240efe972c9fc210184965ee22ea14c888f610c09a85459488265676186d06dea966545e0dc8b53b99bab0a146a7fb69e6327c6d85fffeba4e77b306839616ffd5e7e04e31f9871a191b7ed8c5133fdaf9865c3d63ca8f6e57f7b6e290ebbabbe5a48b2cf42b0373d4d9cee72e92c2f697b932f5b323b7bdfe073f242b0601c28da7f39636502c7adb0d092269f3f9f7ab9e89b9fe82cd596cfffba0d4308f152a17e3e0235ad220efbb648f7f94a438d203112b11163487ef3a4da97b2a46e5a6a5b96a7f246d1ccbe0b55f2a784f56664dad55fcacc7f3d64a7226e17b45e10d008d07fbf3a4e3e03c7208aa3560e2b62c33c7e861429ec7485a46086e277f4c37afd92ce435c79e837f7385b248263fab95b5f92f5012623b60e6a8a20b35741113a874ef63d0e334a53765ff3d0d41eb26a7206b1b7f86286e6bb9025ba4d4bf051e5e609e2ead89a01fb552de6f9bb1728e11c8eef15a31b9bd82477783feb9f9e7fe068e6e18ffa2fac6fc19e70e7779f7ba3ec678bdad2ca6766097d01100ba50c1375158cee3df71cc144e5a22bc76b73f7d4f606fac4b93766248007d26c30262e23d972d8d9c2e3aea17bad0299e794be92f03ead5b94d2bf1e1304dc5b31f3b2cfdf93cb32993635e6e418e6f785371a2659af9d116447f00c540622e6f9a416c09c15712d8cdd72567db5657f750684fb7d820952742ed291c00a119ccb75f093b3ba6a94c9b586666a58dfadcc510beff59539fde68ece7a7fc68005a58626d3c8e557fe51be5988ea4dc153caec61ed5ef6586887707a7100fb5630dec2e7ee209c7ccac268ea09192ec8d05add06ca255b971cc821c68bf4d6136ffaea2b92c2891dbad6b426e77e4c3029088a08834f1b7772a98e98af006023f5f5e0b5a6ec2bb335c9090d891415af01cbd2121a76bce74e94959918044c248da4d89592df033e50d63ccf520fbd8aa637773db74ea316f4f2f3bbe659a9dc6f8a842af641f878fd308a7c234a5a8be7c3adfc93f8948932e6ebe58e054101723aa84b3bcd630d8218b807550670d7ae792f16f3835928bfcce35ae26579006eeb3a92521f21dda48b4d81f281cbe1a014acf39f332d529b2c3767502613da538c5a50d0b7ef55ff084705aed78fdf921d3b37acb47eabcf518c999fb42c7911c6d7b6b57cb2d440345b14f000756dca60a453abdb2e17d8b22a690acbbc8ff651fb71d19cadd476da9bf8868237d6bfc8744fbb63fe7634d1bdf13ea2de6526f88ddbacdcff3e5e0ff7e06158e17401514f7d1ec9b620d5c541851323473b7a5e42a5bfecb06f3ec22b0c7d77e75dd79a7d6a5c9e357db90b0c0260cac53d43cbba55444f2b2225fff4fd97133e94f9840b3d76962bf8ce6df8da8183b7d1023778cd45ed7b64495d89de86bdc9e6a07b910fe465b17d534dbbcd1e355648e6ce6cf053ebf7846cd86427844c0658c8165a5cfa827a077ee5b8d7493bb0788b010446e8c6faeae053b6b0684954a1fe8d8c82e13c3487236d21973d33a26a3f3251f65619b5f6d41cc68052a7e40abbc70db83d0c1fdf9f139546f45e6fb2b8152ae1e9d9a621bd6aefeb480070854a45974cdae7217f9e757398ff438c0d5ea41e3b75d70413339aa42c3e0ad0d7e09b9439b5652857b8165c8b3e5ca6da1586b5ea35f8078148017e937229abe9b00f7f4c21f65161f052e87720f04a8c78259882cbb1f1bf887f6a2904abe94792b4c26ff4dbe7c050b5d4f7abe7ec56de275e428156fa0e9d7dfcc1b01ab2c96682be288209e47f28a1a1ce061cc500f456aedabdb754d65cf090c86cee7b379602d69bd9ace5d784f75786f17acfb7c89591656e04005095899f8ca8259b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    
    <category term="面试经验" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="网课" scheme="http://yoursite.com/tags/%E7%BD%91%E8%AF%BE/"/>
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>alist网盘聚合</title>
    <link href="http://yoursite.com/2023/02/04/alist%E7%BD%91%E7%9B%98%E8%81%9A%E5%90%88/"/>
    <id>http://yoursite.com/2023/02/04/alist%E7%BD%91%E7%9B%98%E8%81%9A%E5%90%88/</id>
    <published>2023-02-04T10:59:27.000Z</published>
    <updated>2023-02-05T08:55:19.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="alist简介"><a href="#alist简介" class="headerlink" title="alist简介"></a>alist简介</h1><p><strong>AList</strong> 是一个支持在本地加载 18 款常见网盘文件列表的工具，它可以让用户直接在浏览器中预览文件、上传文件、下载文件、播放视频、浏览照片，也可以直接在播放器中打开视频文件，还可以配合 aria2 实现文件下载功能。跨平台简单易用。@<a href="https://www.appinn.com/alist-file-list-program/">Appinn</a></p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Appinn-2022-09-16T150310.322.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频"></p><p>感谢 @<strong>imsoff</strong> 推荐。</p><h2 id="AList-–-文件列表程序"><a href="#AList-–-文件列表程序" class="headerlink" title="AList – 文件列表程序"></a>AList – 文件列表程序</h2><p>AList 自己的定位是一个支持多存储的文件列表程序，使用 Gin 和 Solidjs。它可以将以下网盘聚合在一起：</p><ul><li>本地存储</li><li>阿里云盘</li><li>OneDrive &#x2F; Sharepoint（国际版, 世纪互联,de,us）</li><li>天翼云盘 (个人云, 家庭云)</li><li>GoogleDrive</li><li>123云盘</li><li>FTP &#x2F; SFTP</li><li>PikPak</li><li>S3</li><li>又拍云对象存储</li><li>WebDav(支持无API的OneDrive&#x2F;SharePoint)</li><li>Teambition（中国，国际）</li><li>分秒帧</li><li>和彩云 (个人云,家庭云)</li><li>Yandex.Disk</li><li>百度网盘</li><li>夸克网盘</li><li>迅雷网盘</li></ul><p>然后只需要在浏览器中打开，即可预览文件、上传文件、下载文件、直接播放视频、音频。</p><h2 id="在线播放视频效果"><a href="#在线播放视频效果" class="headerlink" title="在线播放视频效果"></a>在线播放视频效果</h2><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-15.59.14.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 1"></p><p>并且提供了几个播放器按钮，直接点击就能跳转。</p><p>不过青小蛙在测试的时候没搞定云字幕，似乎需要下载字幕之后才能加载。</p><h2 id="安装-amp-配置"><a href="#安装-amp-配置" class="headerlink" title="安装 &amp; 配置"></a>安装 &amp; 配置</h2><p>AList 的安装比较简单，对于 Windows 用户，直接下载 .exe 文件之后，使用命令提示符运行，就行了。对于其他平台用户，也差不多，另外也支持 docker 部署，即开机用非常简单。</p><p>也算是0配置，只需要输入命令 alist.exe admin 获取管理员密码，打开浏览器 127.0.0.1:5244 就行了。</p><h2 id="添加存储"><a href="#添加存储" class="headerlink" title="添加存储"></a>添加存储</h2><p>在管理界面，可以添加很多的网盘：</p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-16.30.03.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 2"></p><p>这里就需要<a href="https://alist.nn.ci/zh/guide/drivers/common.html">阅读文档</a>了，但也很简单，最重要的是获取 Token，也提供了自动化获取按钮。不放心的同学可以根据文档说明手动获取。</p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-16.31.09.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 3"></p><h2 id="公网访问"><a href="#公网访问" class="headerlink" title="公网访问"></a>公网访问</h2><p>虽然青小蛙主要用来自己在家用，但的确看到了不少人拿来在公网使用。AList 可以设置公告、用户权限、</p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-16.39.19.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 4"></p><p>嗯，比如<a href="https://kutt.appinn.net/ftlxSu">这种</a>。</p><h2 id="WebDAV"><a href="#WebDAV" class="headerlink" title="WebDAV"></a>WebDAV</h2><p>除了直接将 WebDAV 资源添加进 AList，还支持反向使用，即使用 WebDAV 客户端连接 Alist，然后浏览绑定的内容，这样就极大的扩展了客户端，包括 iPhone、Android 都可以轻松访问你的网盘资源了：</p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-16.47.23.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 5"></p><p><img src="https://www.appinn.com/wp-content/uploads/2022/09/Screen-Appinn2022-09-16-16.47.28.jpg" alt="AList - 聚合阿里云盘、百度网盘、PikPak、WebDav 等 18 款网盘：文件预览、上传/下载，直接播放视频 6"></p><p>怎么说呢，反正省了台 <a href="https://www.appinn.com/tag/nas/">NAS</a> 的感觉。</p><h1 id="2-为什么搭建"><a href="#2-为什么搭建" class="headerlink" title="2.为什么搭建"></a>2.为什么搭建</h1><p>笔者手里有多个网盘，百度云（网课视频），阿里云（电视视频），pikpak（下torrent），还有谷歌云（自用，备份手机的）。</p><p>主要是笔者中午使用pikpak在线客户端很卡，播放视频非常卡顿，不流畅，所以笔者花了一点时间来进行搭建。搭建完成之后的效果就是可以只要输入一个网站，就可以访问多个网盘，而且播放效果，比官网好多 了。</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16755087318811675508731713.png"></p><p>搭建效果如图</p><h1 id="3-搭建教程"><a href="#3-搭建教程" class="headerlink" title="3.搭建教程"></a>3.搭建教程</h1><p>主要参考下面官网文档，本来想使用docker的，但是垃圾服务器，内存根本跑不了docker，所以直接使用的一件脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL &quot;https://alist.nn.ci/v3.sh&quot; | bash -s install</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://alist.nn.ci/zh/guide/install/script.html">https://alist.nn.ci/zh/guide/install/script.html</a> 官网教程</p><p>搭建完成之后，会出现账号密码，这个自己记住。</p><p>之后就是使用如何进行安装网盘。最简单的是pikpak，这个只要输入账号密码就行。具体安装步骤在官网上面。</p><p>百度网盘安装教程：</p><ol><li><a href="https://openapi.baidu.com/oauth/2.0/authorize?response_type=code&amp;client_id=iYCeC9g08h5vuP9UqvPHKKSVrKFXGa1v&amp;redirect_uri=https://tool.nn.ci/baidu/callback&amp;scope=basic,netdisk&amp;qrcode=1">https://openapi.baidu.com/oauth/2.0/authorize?response_type=code&amp;client_id=iYCeC9g08h5vuP9UqvPHKKSVrKFXGa1v&amp;redirect_uri=https://tool.nn.ci/baidu/callback&amp;scope=basic,netdisk&amp;qrcode=1</a></li><li>使用上面网站获取令牌还有secret还有id</li><li>下面看图，不然没有办法正常播放视频</li><li>下载选择非官方就行</li></ol><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16755090388811675509038218.png"></p><p>谷歌网盘：</p><p>这是最复杂的，需要自己申请api接口，然后再把这个接口开放给自己一个人使用，得到接口之后才能进行生成id还有token，具体参考下面这个YouTube博主视频</p><p><a href="https://youtu.be/Hktdyg7L0Bg">https://youtu.be/Hktdyg7L0Bg</a></p><ol><li>创建项目</li><li>然后启用api还有服务，主要使用云盘服务，找到云盘</li><li>之后就是创建姘居，创建OA客户端id，填写外部，然后只要输入自己的电子邮件</li><li>之后就是添加用户，吧自己添加进去</li><li>之后再次回到品聚，创建oa的id，选择应用是桌面客户端之后秘钥还有id就出来了</li><li>之后输入到那个网站，点击code，弹出网页，一直继续</li><li>就会有token出现</li><li>之后就按照放入到alist的后台</li></ol><h1 id="4-反向代理"><a href="#4-反向代理" class="headerlink" title="4.反向代理"></a>4.反向代理</h1><p>下午使用github学生包，白嫖了一个域名，然后，为了懒得记住ip，直接用域名来使用。</p><p>问题是alist使用的5244端口，但是直接输入域名+端口非常不好看，所以使用反向代理，这里使用的是nginx，</p><p>直接下载nginx安装，笔者之前忘了开80端口，一直打不开，以为是自己配置问题。换了apache也是一样的。于是再换回nginx，才发现80没有打开，大坑。打开之后，一直是配置502，一直以为是自己的配置有问题（实际上没有，只是linux内核问题），谷歌发现要设置一个内核关闭，代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsebool -P httpd_can_network_connect 1   </span><br></pre></td></tr></table></figure><p>之后就可以正常访问了，主要的是配置，参考官网，直接在http模块里面添加一个新的server模块，就可以，配置文档etc、nginx、nginxconf里面，修改如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">  proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">  proxy_set_header Host $http_host;</span><br><span class="line">  proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">  proxy_set_header Range $http_range;</span><br><span class="line">proxy_set_header If-Range $http_if_range;</span><br><span class="line">  proxy_redirect off;</span><br><span class="line">  proxy_pass http:<span class="comment">//127.0.0.1:5244;</span></span><br><span class="line">  <span class="meta"># the max size of file to upload</span></span><br><span class="line">  client_max_body_size <span class="number">20000</span>m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;alist简介&quot;&gt;&lt;a href=&quot;#alist简介&quot; class=&quot;headerlink&quot; title=&quot;alist简介&quot;&gt;&lt;/a&gt;alist简介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;AList&lt;/strong&gt; 是一个支持在本地加载 18 款常见网盘文件列表的工具，</summary>
      
    
    
    
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
    <category term="网盘" scheme="http://yoursite.com/tags/%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>一文详解欧易wise和depay</title>
    <link href="http://yoursite.com/2023/02/04/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E6%AC%A7%E6%98%93wise%E5%92%8Cdepay/"/>
    <id>http://yoursite.com/2023/02/04/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E6%AC%A7%E6%98%93wise%E5%92%8Cdepay/</id>
    <published>2023-02-04T09:56:13.000Z</published>
    <updated>2023-02-04T10:52:36.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简要介绍"><a href="#1-简要介绍" class="headerlink" title="1.简要介绍"></a>1.简要介绍</h1><p>之所以写这个的原因是，笔者正在白嫖土耳其的低价优惠。因为埃尔多安经济学，导致人民币兑土耳其不断升高，而且定价在土区也是低价区。所以如何充分利用土区白嫖优惠，就是个问题。</p><p>门前主流的国外网站netflix，Spotify，apple，google，Disney等价格都远远低于国区。但是购买方式只能使用国外的信用卡组织visa或者MasterCard。笔者作为学生党，当然是办不了的。但是oldubil这个软件，提供一个虚拟土耳其mastercard，可以对上述网站进行购买。所以我们的问题就变成如何给oldubil入金了。</p><p>目前有两种方式，笔者尝试的第一种损耗很大，而且还需要进行kyc身份验证，需要使用你的护照信息。第二种是直接通过欧易交易所，交易usdt给土耳其人（因为中国大陆区无法直接交易土耳其，所以还需要注册一个台湾区来进行交易）。</p><p>下面先介绍第一种思路：</p><ol><li>支付宝购买usdt在欧易里面（微信，银行卡也可以）</li><li>在depay里面进行充币操作</li><li>利用depay的虚拟卡给wise汇款</li><li>利用wise进行转换，把美元兑换成土耳其</li><li>最后利用wise发送到oldubil支持的iban银行</li></ol><p>以上每一步都有损耗，交易费，手续费，还有转账费用，笔者一共付出23.8在欧易，到wise里面就只有20了。损耗率有16个点。而且还需要kyc身份认证在wise，总体比较繁琐</p><p>第二种就是直接欧易买卖币，兑换成土耳其</p><ol><li>大陆欧易账号买币</li><li>发送到台湾欧易账号（站内转账）</li><li>最后用台湾的账号卖出为土耳其，填入iban相关的</li></ol><p>下面先介绍一下第一种方法</p><h2 id="1-1-欧易操作"><a href="#1-1-欧易操作" class="headerlink" title="1.1 欧易操作"></a>1.1 欧易操作</h2><blockquote><p><strong>欧易</strong>（英语：OKX；原名<strong>OKEx</strong>）是一间<a href="https://zh.wikipedia.org/wiki/%E7%B8%BD%E9%83%A8">总部</a>位于<a href="https://zh.wikipedia.org/wiki/%E5%A1%9E%E8%88%8C%E5%B0%94">塞舌尔</a>的<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E4%BA%A4%E6%98%93%E6%89%80">加密货币交易所</a>[<a href="https://zh.wikipedia.org/zh-cn/%E6%AC%A7%E6%98%93#cite_note-2">2]</a>，由徐明星于2017年创办[<a href="https://zh.wikipedia.org/zh-cn/%E6%AC%A7%E6%98%93#cite_note-Birnbaum_2022-3">3]</a>。该机构的主营业务是为<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7">用户</a>提供多种加密资产交易服务。2021年2月2日，该交易所正式启用中文名“欧易”[<a href="https://zh.wikipedia.org/zh-cn/%E6%AC%A7%E6%98%93#cite_note-4">4]</a>。2022年1月，OKEx更名为OKX[<a href="https://zh.wikipedia.org/zh-cn/%E6%AC%A7%E6%98%93#cite_note-5">5]</a>。</p></blockquote><p>简单来说就是一个交易所，进行买卖比特币的地方，我们如果要进行买币就要首先认证身份，l1认证就行，使用身份证可以通过。</p><p><strong>第二步就是进行c2c买币</strong>，顾名思义，就是顾客对顾客买币，量大他的折扣才打。目前汇率是1:6.78，但是个人卖家，你卖的少可能会出现1:7的价格。这也是一部分损耗。选择接受的方式进行筛选，微信，支付宝</p><h2 id="1-2depay操作"><a href="#1-2depay操作" class="headerlink" title="1.2depay操作"></a>1.2depay操作</h2><p><a href="https://zhuanlan.zhihu.com/p/596899194">https://zhuanlan.zhihu.com/p/596899194</a></p><blockquote><blockquote><p><em>一、Depay的使用场景有那些？</em></p></blockquote><p>1、Depay Master Visa卡支持绑定支付宝、微信支付、美团外卖、拼多多、Paypal、天猫国际版等等。</p><p>2、支持Stripe商户、google play商店、youtube premium、paypal商户、美区苹果商店、和支持非3DS卡的电商网站</p><p>3、支持国内苹果官网直接绑卡购买iphone和mac，可能会打电话问询，直接说即可。</p><p>4、暂不支持苹果支付APPLE PAY和谷歌PAY</p><p>5、所有等级的卡（Lite、标准、高级、白金、黑金）都满足以上场景</p></blockquote><p>简而言之就是提供了一个虚拟mastercard，但是入金的方式只能通过比特币来入金，所以我们需要第一步的欧易来操作。（注意，手续费比较多）</p><ol><li>首先把欧易里面的usdt发送给depay</li><li>我们需要在depay里面找到usdt，还有他的合约链，复制合约链还有id来到欧易</li><li><strong>在欧易里面选择提币，然后选择连上转账，输入地址还有链，这个时候因为是外链会有0.8的手续费</strong></li><li>之后等过5分钟到达depay</li><li>我们在等待时间，先开一张虚拟卡，使用身份证可以验证，然后就是最便宜的没有开卡费用，但是月费是1刀，还有交易费</li><li>开卡完成，我们回到usdt，还需要进行转换为usd才能放入depay一般是97折进行转换</li><li>转换放入需要扣除0.3的手续，到此23.8就只有21.76左右了</li></ol><h2 id="1-3wise操作"><a href="#1-3wise操作" class="headerlink" title="1.3wise操作"></a>1.3wise操作</h2><blockquote><h2 id="什麼是-Wise？"><a href="#什麼是-Wise？" class="headerlink" title="什麼是 Wise？"></a><strong>什麼是 Wise？</strong></h2><p>Wise（舊稱Transferwise），是一家提供國際匯款轉賬服務的 P2P 國際匯款平台。Wise 也是世界上成長速度最快的線上匯款、電子貨幣服務之一。</p><p>Wise 因匯率和定價透明，加上直接將資金匯到海外，省去高昂的銀行手續費，吸引超過1,000萬的用戶。目前 Wise 可支持40多個國家的貨幣轉賬，非常適合在海外工作，或是擁有海外收入的用戶。</p></blockquote><p>简单来说wise就是跨境汇款工具，因为普通银行汇款会有巨额的手续费没所以才有了wise，就是减少手续费 的。</p><p>但是wise这个软件是需要进行进行身份验证，前面两个使用身份证就行，这个必须使用护照（还好现在办护照容易，笔者是上个月办的，听到可以恢复办理护照，就赶快办了一个）。说回正题，现在你还需要入金20刀还有护照才能激活wise，才可以开通跨境转账成为土耳其货币，具体步骤如下。</p><ol><li>使用depay进行付款20美金，注意，<strong>又有手续费，0.8必须扣得</strong></li><li>之后就是身份验证，需要护照还有自拍</li><li>最后一步就是转账，具体流程如下图</li><li>转账之前还需要把美元兑换成土耳其，也有损耗</li><li>发送固定是24土耳其，合计1美金左右的手续费</li></ol><p>简单来说就是去oldubil里面 选择iban转账，然后去oldubil找到银行，复制iban和名称回到wise，最后一步就是附言要写上自己的虚拟卡（这个是oldubil提供的土耳其虚拟卡），如下图所示</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16755067588821675506758131.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16755067768841675506776221.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16755067878851675506787752.png"></p><h2 id="1-4oldubil操作"><a href="#1-4oldubil操作" class="headerlink" title="1.4oldubil操作"></a>1.4oldubil操作</h2><p>这个是土耳其的虚拟卡软件，但是注册的话，国内手机号没有办法使用。我是用的是土乌克兰lifecell的esim，使用国内的万事达借记卡，可以购买手机号。优点不需要实名认证，价格是5块钱一个月。使用的是美版se2，进行使用esim的</p><p>esim连接：<a href="https://www.lifecell.ua/en/sim-and-number/eSIM/">https://www.lifecell.ua/en/sim-and-number/eSIM/</a></p><blockquote><p>万事达借记卡：使用的是中国银行的莫奈，有3ds，可以在某些网站进行验证，有网申连接，主要参考这个网站</p><p><a href="https://poplite.xyz/post/2018/03/05/boc-debit-card-guide-for-online-payment.html">https://poplite.xyz/post/2018/03/05/boc-debit-card-guide-for-online-payment.html</a>   还有dotofcards这个群组。唯一缺点就是需要自己手动结汇购汇，这个是会占用自己的5w外汇额度的。美国运通的借记卡就不需要，但是没有3ds，有些网站买不了东西。</p></blockquote><p>最后就是转账到oldubil里面，然后使用这个提供的银行卡去买spotify，netflix</p><h1 id="2-方法总结"><a href="#2-方法总结" class="headerlink" title="2.方法总结"></a>2.方法总结</h1><p>上述方法，一共损耗0.8（欧易费用）+0.3（depay汇入费用）+（0.86wise汇入费用）+（1.2wise会出费用），这还没有计算，usdt打折，还有还有usdt转入usd的损耗，还有美元转土耳其的损耗。目前就损耗了3美元，流程繁琐，而且损耗严重。</p><p>第二种方法就是直接买usdt，通过欧易发送到台湾账户，这个站内转账没有损害，而且我们只需要在卖比特币给土耳其人就行，时间很快。主要有下面的教程</p><p><a href="https://yummy.best/how-to-top-up-oldubil/">https://yummy.best/how-to-top-up-oldubil/</a>  参考下面的教程</p><blockquote><h2 id="入金步骤（来自-沐攸-投稿）"><a href="#入金步骤（来自-沐攸-投稿）" class="headerlink" title="入金步骤（来自 沐攸 投稿）"></a>入金步骤（来自 <a href="https://t.me/Mylovetbole">沐攸</a> 投稿）</h2><p><strong>第一步</strong>：注册两个欧易账户，一个欧易账号身份认证选择  <code>**大陆+大陆身份证验证**</code> ，另一欧易账户身份认证选择 <code>**台湾+大陆身份证认证**</code> 。</p><blockquote><p>说明：选择台湾账户的账户只需要简单认证  <code>**L1**</code> 即可，不要验证到  <code>**L2**</code> 否则默认成为大陆欧易无法绕过 CNY 进行交易；另一个账户随便。</p></blockquote><p><strong>第二步</strong>：用 <code>**大陆**</code> 的欧易账户购买 USDT 入金欧易（支持微信+支付宝），然后将购买到的 USDT 发送到 <code>**台湾**</code> 欧易账户（<strong>选择站内转账，否则需要支付 0.8 usdt 手续费</strong>）</p><p><strong>第三步</strong>：使用 <code>**台湾**</code> 欧易账户 C2C 交易 → 选择货币为 TRY → 交易方式为银行转账 → 选择 oldubil 支持的银行并填入信息，然后按照如下格式填入发送到聊天框‌‌</p><p><strong>IBAN:‌‌</strong></p><p><strong>Name:</strong></p><p><strong>‌‌Card Number:</strong></p></blockquote><p>第三种就是直接淘宝进行购买，主要使用的是礼品卡，淘宝也有卖的，而且。还有一些专门卖礼品卡的网站。</p><p><a href="https://hezu.wiki/zh/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%BA/%E5%9C%9F%E8%80%B3%E5%85%B6%E7%A4%BC%E5%93%81%E5%8D%A1%E8%B4%AD%E4%B9%B0">https://hezu.wiki/zh/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%BA/%E5%9C%9F%E8%80%B3%E5%85%B6%E7%A4%BC%E5%93%81%E5%8D%A1%E8%B4%AD%E4%B9%B0</a></p><p><a href="https://www.oyunfor.com/tv/netflix-hediye-kodu-karti">https://www.oyunfor.com/tv/netflix-hediye-kodu-karti</a>  主要使用这个，这个基本都有买的。</p><p>总而言之，使用第一种方法是费力不讨好的，但是折腾了很久，也学到了btc一些知识。充值还是推荐后面两种。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简要介绍&quot;&gt;&lt;a href=&quot;#1-简要介绍&quot; class=&quot;headerlink&quot; title=&quot;1.简要介绍&quot;&gt;&lt;/a&gt;1.简要介绍&lt;/h1&gt;&lt;p&gt;之所以写这个的原因是，笔者正在白嫖土耳其的低价优惠。因为埃尔多安经济学，导致人民币兑土耳其不断升高，而且定价</summary>
      
    
    
    
    
    <category term="usdt" scheme="http://yoursite.com/tags/usdt/"/>
    
    <category term="btc" scheme="http://yoursite.com/tags/btc/"/>
    
    <category term="外汇" scheme="http://yoursite.com/tags/%E5%A4%96%E6%B1%87/"/>
    
    <category term="入金" scheme="http://yoursite.com/tags/%E5%85%A5%E9%87%91/"/>
    
    <category term="土耳其" scheme="http://yoursite.com/tags/%E5%9C%9F%E8%80%B3%E5%85%B6/"/>
    
    <category term="mastercard" scheme="http://yoursite.com/tags/mastercard/"/>
    
  </entry>
  
  <entry>
    <title>搜索专题</title>
    <link href="http://yoursite.com/2023/02/03/%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98/"/>
    <id>http://yoursite.com/2023/02/03/%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98/</id>
    <published>2023-02-03T08:54:33.000Z</published>
    <updated>2023-02-03T11:14:51.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-BFS"><a href="#1-BFS" class="headerlink" title="1.BFS"></a>1.BFS</h1><p>bfs主要包括一下应用，flood fill（洪水灌溉）把所有的值进行填充man，最小步数模型，就是最先到达的形态，使用的最小方法。然后就是多源bfs，这个思路就是吧所有的起点全部放入到queue里面。之后就是双向bfs，这个是节约搜索时间（使用两个queue来进行）</p><h2 id="397-整数替换"><a href="#397-整数替换" class="headerlink" title="397. 整数替换"></a><a href="https://leetcode.cn/problems/integer-replacement/">397. 整数替换</a></h2><p>返回最小的次数，可以用递归，或者最小步数</p><p>思路也是没有发现了这个值，就放入st和queue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerReplacement</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        if (n==1)return 0;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        if(n%2)&#123;</span></span><br><span class="line"><span class="comment">//            return min(integerReplacement(n-1), integerReplacement(n+1))+1;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return 1+ integerReplacement(n/2);</span></span><br><span class="line">        queue&lt;<span class="type">long</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(n);</span><br><span class="line">        <span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">        set&lt;<span class="type">long</span>&gt; st;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> n=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> n1=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(n1==<span class="number">1</span>)<span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">if</span>(n1%<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">count</span>(n1<span class="number">-1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                        st.<span class="built_in">insert</span>(n1<span class="number">-1</span>);</span><br><span class="line">                        q.<span class="built_in">push</span>(n1<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (st.<span class="built_in">count</span>(n1+<span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(n1+<span class="number">1</span>);</span><br><span class="line">                        st.<span class="built_in">insert</span>(n1+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">count</span>(n1/<span class="number">2</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(n1/<span class="number">2</span>);</span><br><span class="line">                        st.<span class="built_in">insert</span>(n1/<span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="403-青蛙过河"><a href="#403-青蛙过河" class="headerlink" title="403. 青蛙过河"></a><a href="https://leetcode.cn/problems/frog-jump/">403. 青蛙过河</a></h2><p>f[i][j】表示表示到达i这个点，下一步是j步数。</p><p>计算方法就是当前i可能是由j，j-1，j+1构成的，f【rec[num[i]-j]][j]可以由他来构成，所以我们要查看当前值有没有。最后一个我们只要看f【n-1】【0.。。n-1】有没有一个成功的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//直接使用dp，f【i】【j】是bool，表示到达i，下一步是j，是不是可能的</span></span><br><span class="line"><span class="comment">//    地推方程f[?][j-1],f[?][j],f[?][j+1]来构成</span></span><br><span class="line"><span class="comment">//一共到达n，有f[n][1],f[n][2],f[n][n]中方法，一个是true，就返回</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n=stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            rec[stones[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> end=stones[stones.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">f</span>(n,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//开门表示，0开始一步跳是可以的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> x=stones[i];</span><br><span class="line">                <span class="keyword">if</span>(rec.<span class="built_in">count</span>(x-j))&#123;</span><br><span class="line">                    f[i][j]=f[i][j]||f[rec[x-j]][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(rec.<span class="built_in">count</span>(x-j<span class="number">-1</span>)&amp;&amp;j+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">                    f[i][j]=f[i][j]||f[rec[x-j<span class="number">-1</span>]][j+<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">if</span>(rec.<span class="built_in">count</span>(x-j+<span class="number">1</span>)&amp;&amp;j<span class="number">-1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    f[i][j]=f[i][j]||f[rec[x-j+<span class="number">1</span>]][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[n<span class="number">-1</span>][i])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">         <span class="type">int</span> len = stones.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp[i][j] 表示 第 i 个石头是否可以跳 j 步</span></span><br><span class="line">        <span class="comment">// boolean[][] dp = new boolean[len][len + 1];</span></span><br><span class="line">                vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(len,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(len+<span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始条件：第 0 个石头可以跳 1 步</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//因为 石头 i 最大只能跳 i + 1 步，因此 前面的石头 j 到达 石头 i 的距离必须 &lt;= i</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="type">int</span> diff = stones[i] - stones[j];</span><br><span class="line">                <span class="keyword">if</span>(diff &gt; i)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//对于 石头 j ，它需要跳 diff 步</span></span><br><span class="line">                <span class="keyword">if</span>(dp[j][diff])&#123;</span><br><span class="line">                    dp[i][diff - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    dp[i][diff] = <span class="literal">true</span>;</span><br><span class="line">                    dp[i][diff + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当到达了终点 而 flag ，表示无法从前面的任意石头跳到终点，返回 false</span></span><br><span class="line">            <span class="keyword">if</span>(i == len - <span class="number">1</span> &amp;&amp; !flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></h2><p>模板题目</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (!root)<span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> n=q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cur=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                path.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cur-&gt;children.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;children[j])&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(cur-&gt;children[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h2><p>dfs，直接加入depth，然后第一次出现的就进行设置，从做开始到右边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> max=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth&gt;max)&#123;</span><br><span class="line">            max=depth;</span><br><span class="line">            ans=root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者直接每一层的用vector存着，然后放出第一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; d = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        d.<span class="built_in">addLast</span>(root);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!d.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> sz = d.<span class="built_in">size</span>();</span><br><span class="line">            ans = d.<span class="built_in">peek</span>().val;</span><br><span class="line">            <span class="keyword">while</span> (sz-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode poll = d.<span class="built_in">pollFirst</span>();</span><br><span class="line">                <span class="keyword">if</span> (poll.left != null) d.<span class="built_in">addLast</span>(poll.left);</span><br><span class="line">                <span class="keyword">if</span> (poll.right != null) d.<span class="built_in">addLast</span>(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></h2><p>标准的层序，然后当前的进行比较，放进去，或者是使用dfs来对每一个进行大小比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line">    <span class="type">int</span> max1;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">0</span>);</span><br><span class="line">        rec[<span class="number">0</span>]=root-&gt;val;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=max1; ++i) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(rec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth&gt;max1)&#123;</span><br><span class="line">            max1=depth;</span><br><span class="line">            rec[depth]=root-&gt;val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            rec[depth]=<span class="built_in">max</span>(rec[depth],root-&gt;val);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h2><p>简单模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line">    <span class="type">int</span> maxdepth=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        rec[0]=1;</span></span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=maxdepth ; ++i) &#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(rec[i],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxdepth+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Node* root,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth&gt; maxdepth)&#123;</span><br><span class="line">            maxdepth=depth;</span><br><span class="line">            rec[maxdepth]=<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            rec[depth]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;children[i],depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="623-在二叉树中增加一行"><a href="#623-在二叉树中增加一行" class="headerlink" title="623. 在二叉树中增加一行"></a><a href="https://leetcode.cn/problems/add-one-row-to-tree/">623. 在二叉树中增加一行</a></h2><p>最开始就是在0层直接加，其它层就是找到深度-1的时候加入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">addOneRow</span><span class="params">(TreeNode* root, <span class="type">int</span> val, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth == <span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val,root, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(root,val,depth,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> val, <span class="type">int</span> depth,<span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height == depth - <span class="number">1</span>)&#123;</span><br><span class="line">            root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val,root-&gt;left, <span class="literal">nullptr</span>);</span><br><span class="line">            root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val,<span class="literal">nullptr</span>,root-&gt;right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,val,depth,height+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,val,depth,height+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h2><p>好题目，主要是想多了，如果当前值小，就返回右边的值（因为是bst，右边一定大），如果大，就返回左边的，如果符合返回root</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;low)&#123;</span><br><span class="line">            <span class="comment">//当前的国小,返回右边的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&gt;high)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left=<span class="built_in">trimBST</span>(root-&gt;left,low,high);</span><br><span class="line">        root-&gt;right=<span class="built_in">trimBST</span>(root-&gt;right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a><a href="https://leetcode.cn/problems/word-ladder/">127. 单词接龙</a></h2><p>这个是求最短的变换方式，就是最小步数模型。我们通过检索每一个位置，然后进行a-z的变形，而且在指点里面就进行加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;string&gt; S;</span><br><span class="line">      unordered_map&lt;string, int&gt; dist;</span><br><span class="line">      queue&lt;string&gt; q;</span><br><span class="line">      dist[beginWord] = 1;</span><br><span class="line">      q.push(beginWord);</span><br><span class="line">      for (auto word: wordList) S.insert(word);</span><br><span class="line"></span><br><span class="line">      while (q.size()) &#123;</span><br><span class="line">          auto t = q.front();</span><br><span class="line">          q.pop();</span><br><span class="line">          string r = t;</span><br><span class="line">          for (int i = 0; i &lt; t.size(); i ++ ) &#123;</span><br><span class="line">              t = r;</span><br><span class="line">              for (char j = &#x27;a&#x27;; j &lt;= &#x27;z&#x27;; j ++ )</span><br><span class="line">                  if (r[i] != j) &#123;</span><br><span class="line">                      t[i] = j;</span><br><span class="line">                      if (S.count(t) &amp;&amp; dist.count(t) == 0) &#123;</span><br><span class="line">                          dist[t] = dist[r] + 1;</span><br><span class="line">                          if (t == endWord) return dist[t];</span><br><span class="line">                          q.push(t);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return 0;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="417-太平洋大西洋水流问题"><a href="#417-太平洋大西洋水流问题" class="headerlink" title="417. 太平洋大西洋水流问题"></a><a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></h2><p>都可以流的，那我们只需要2次遍历，一次太平洋，一次大西洋，然后都可以的，两次遍历，取公共</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; heights;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; &amp; ocean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ocean[row][col]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        ocean[row][col] = <span class="literal">true</span>;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; qu;</span><br><span class="line">        qu.<span class="built_in">emplace</span>(row, col);</span><br><span class="line">        <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [row, col] = qu.<span class="built_in">front</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> newRow = row + dirs[i][<span class="number">0</span>], newCol = col + dirs[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; m &amp;&amp; newCol &gt;= <span class="number">0</span> &amp;&amp; newCol &lt; n &amp;&amp; heights[newRow][newCol] &gt;= heights[row][col] &amp;&amp; !ocean[newRow][newCol]) &#123;</span><br><span class="line">                    ocean[newRow][newCol] = <span class="literal">true</span>;</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(newRow, newCol);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;heights = heights;</span><br><span class="line">        <span class="type">int</span> m = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">pacific</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">atlantic</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(i, <span class="number">0</span>, pacific);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(<span class="number">0</span>, j, pacific);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(i, n - <span class="number">1</span>, atlantic);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">bfs</span>(m - <span class="number">1</span>, j, atlantic);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j]) &#123;</span><br><span class="line">                    vector&lt;<span class="type">int</span>&gt; cell;</span><br><span class="line">                    cell.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                    cell.<span class="built_in">emplace_back</span>(j);</span><br><span class="line">                    result.<span class="built_in">emplace_back</span>(cell);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="433-最小基因变化"><a href="#433-最小基因变化" class="headerlink" title="433. 最小基因变化"></a><a href="https://leetcode.cn/problems/minimum-genetic-mutation/">433. 最小基因变化</a></h2><p>简单的最小步数模型，和前两题一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMutation</span><span class="params">(string startGene, string endGene, vector&lt;string&gt;&amp; bank)</span> </span>&#123;</span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(startGene);</span><br><span class="line">        <span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">        set&lt;string&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bank.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bank[i]==endGene)&#123;</span><br><span class="line">                t=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">insert</span>(bank[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;string &gt; rec;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        rec.<span class="built_in">insert</span>(startGene);</span><br><span class="line">        <span class="type">char</span> dic[<span class="number">4</span>]=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> n=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span>  cur=q.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//                cout&lt;&lt;cur&lt;&lt;endl;</span></span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur==endGene)<span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cur.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                        string b=cur;</span><br><span class="line"></span><br><span class="line">                        b[j]=dic[k];</span><br><span class="line"><span class="comment">//                        cout&lt;&lt;cur&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(st.<span class="built_in">count</span>(b))&#123;</span><br><span class="line">                            <span class="keyword">if</span>(!rec.<span class="built_in">count</span>(b))&#123;</span><br><span class="line">                                q.<span class="built_in">push</span>(b);</span><br><span class="line">                                rec.<span class="built_in">insert</span>(b);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="752-打开转盘锁"><a href="#752-打开转盘锁" class="headerlink" title="752. 打开转盘锁"></a><a href="https://leetcode.cn/problems/open-the-lock/">752. 打开转盘锁</a></h2><p>最小步数模型，就是这样的模板，修改，如果为9，就变0或者8</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">openLock</span><span class="params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//状态转移,使用最小步数模型,使用bfs</span></span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        unordered_map&lt;string,<span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; deadends.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            rec[deadends[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec.<span class="built_in">find</span>(<span class="string">&quot;0000&quot;</span>)!=rec.<span class="built_in">end</span>())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        rec[<span class="string">&quot;0000&quot;</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> n=q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cur=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//                cout&lt;&lt;cur&lt;&lt;&quot; &quot;;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cur==target)<span class="keyword">return</span> ans;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> a= <span class="built_in">up</span>(cur,j);</span><br><span class="line">                    <span class="keyword">auto</span> b= <span class="built_in">down</span>(cur,j);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(rec.<span class="built_in">find</span>(a)==rec.<span class="built_in">end</span>())&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(a);</span><br><span class="line">                        rec[a]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(rec.<span class="built_in">find</span>(b)==rec.<span class="built_in">end</span>())&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(b);</span><br><span class="line">                        rec[b]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每一次++</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">up</span><span class="params">(string s,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            s[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s[i]=s[i]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">down</span><span class="params">(string s,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            s[i]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s[i]=s[i]<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-DFS"><a href="#2-DFS" class="headerlink" title="2.DFS"></a>2.DFS</h1><p>dfs一般就是爆搜，进行排列组合，组合数，一般就是直接sort，排列数，就是使用st数组，然后continue条件就是排列是0，组合是u</p><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h2><p>这个是组合数，u&#x3D;，直接push进去。正常的回溯教程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string strs[<span class="number">10</span>] = &#123;</span><br><span class="line">            <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">empty</span>())<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">dfs</span>(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string digits,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;digits.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> n=digits[u]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[n].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(strs[n][i]);</span><br><span class="line">            <span class="built_in">dfs</span>(digits,u+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><p>这个条件就是左括号大于右括号，左右括号的值相等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string path;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">2</span>*n)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;path&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="keyword">if</span>(rec.<span class="built_in">find</span>(<span class="string">&#x27;(&#x27;</span>)==rec.<span class="built_in">end</span>()||rec[<span class="string">&#x27;(&#x27;</span>]&lt;n)&#123;</span><br><span class="line">            path+=<span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            rec[<span class="string">&#x27;(&#x27;</span>]++;</span><br><span class="line">            <span class="built_in">dfs</span>(n,u+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            rec[<span class="string">&#x27;(&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec.<span class="built_in">find</span>(<span class="string">&#x27;)&#x27;</span>)==rec.<span class="built_in">end</span>()||rec[<span class="string">&#x27;)&#x27;</span>]&lt;rec[<span class="string">&#x27;(&#x27;</span>])&#123;</span><br><span class="line">            path+=<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            rec[<span class="string">&#x27;)&#x27;</span>]++;</span><br><span class="line">            <span class="built_in">dfs</span>(n,u+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            rec[<span class="string">&#x27;)&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独</a></h2><p>数独解法就是回溯，然后还是使用多个数组来进行，初始化每一个有的点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> row[<span class="number">9</span>][<span class="number">9</span>],col[<span class="number">9</span>][<span class="number">9</span>],block[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(row,<span class="literal">false</span>,<span class="keyword">sizeof</span> row);</span><br><span class="line">        <span class="built_in">memset</span>(col,<span class="literal">false</span>,<span class="keyword">sizeof</span> col);</span><br><span class="line">        <span class="built_in">memset</span>(block,<span class="literal">false</span>,<span class="keyword">sizeof</span> block);</span><br><span class="line">        <span class="comment">//初始化所有的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> t=board[i][j]-<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    row[i][t]=<span class="literal">true</span>;</span><br><span class="line">                    col[j][t]=<span class="literal">true</span>;</span><br><span class="line">                    block[i/<span class="number">3</span>][j/<span class="number">3</span>][t]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(board,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y==<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="comment">//进入下一轮</span></span><br><span class="line">            x++;</span><br><span class="line">            y=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断当前点是不是.可以填入</span></span><br><span class="line">        <span class="keyword">if</span> (board[x][y]!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(board,x,y+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;<span class="number">9</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[x][i]||col[y][i]||block[x/<span class="number">3</span>][y/<span class="number">3</span>][i])<span class="keyword">continue</span>;</span><br><span class="line">                row[x][i]=col[y][i]=block[x/<span class="number">3</span>][y/<span class="number">3</span>][i]=<span class="literal">true</span>;</span><br><span class="line">                board[x][y]=<span class="string">&#x27;0&#x27;</span>+i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(board,x,y+<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                board[x][y]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                row[x][i]=col[y][i]=block[x/<span class="number">3</span>][y/<span class="number">3</span>][i]=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><p>因为是组合，所以所以使用sort，还有continue，从u开始</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> u,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index==nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(u&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums,u-nums[i],i);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h2><p>这个就是药continue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> target,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;=nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;target&lt;&lt;&quot;  &quot;;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;target)<span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;u&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums,target-nums[i],i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//            rec[nums[i]]=1;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2><p>他这个前导0，需要用进行替换，用u+1代替s。szie</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        start=<span class="number">0</span>,end=<span class="number">255</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(s,<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s,<span class="type">int</span> times,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不出现011</span></span><br><span class="line">        <span class="comment">//只有3个小数点可以进行加入</span></span><br><span class="line">        <span class="keyword">if</span> (!times&amp;&amp;u==s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (times&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;=s.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> n=u+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[u]!=<span class="string">&#x27;0&#x27;</span>)n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// if(s[u]==&#x27;0&#x27;)&#123;</span></span><br><span class="line">        <span class="comment">//     path+=&quot;0.&quot;;</span></span><br><span class="line">        <span class="comment">//     dfs(s,times-1,u+1);</span></span><br><span class="line">        <span class="comment">//     return ;</span></span><br><span class="line">        <span class="comment">// &#125;else&#123;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-u+<span class="number">1</span>&gt;<span class="number">3</span>)<span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">auto</span> x=s.<span class="built_in">substr</span>(u,i-u+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> t= <span class="built_in">stoi</span>(x);</span><br><span class="line">                <span class="keyword">if</span>(t&lt;=<span class="number">255</span>)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> back=path;</span><br><span class="line">                    path+=x+<span class="string">&quot;.&quot;</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(s,times<span class="number">-1</span>,i+<span class="number">1</span>);</span><br><span class="line">                    path=back;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h2><p>找出不同的bst，我们设置根节点为0到n-1，没次遍历，然后左右两边设置为左右树，同事也对每一个左右节点来作为root的左右</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 进行建树，从1-n开始，可以改成1-l-1，l，和l+1到n</span></span><br><span class="line">        vector&lt;TreeNode*&gt; ans=<span class="built_in">dfs</span>(<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)&#123;</span><br><span class="line">             res.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; left=<span class="built_in">dfs</span>(l,i<span class="number">-1</span>);</span><br><span class="line">        vector&lt;TreeNode*&gt; right=<span class="built_in">dfs</span>(i+<span class="number">1</span>,r);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接着就是左右节点的选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;L:left)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;R:right)&#123;</span><br><span class="line">                TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                    root-&gt;left = L;</span><br><span class="line">                    root-&gt;right = R;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="310-最小高度树"><a href="#310-最小高度树" class="headerlink" title="310. 最小高度树"></a><a href="https://leetcode.cn/problems/minimum-height-trees/">310. 最小高度树</a></h2><p>建图也tle，使用树形dp，下次在写</p><h2 id="386-字典序排数"><a href="#386-字典序排数" class="headerlink" title="386. 字典序排数"></a><a href="https://leetcode.cn/problems/lexicographical-numbers/">386. 字典序排数</a></h2><p>这个的思路还是首先dfs，如果大于了，就返回，然后直接push</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lexicalOrder</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string path;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="built_in">to_string</span>(n),<span class="number">0</span>,path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s ,<span class="type">int</span> u,string path)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(u&gt;s.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;<span class="number">0</span>&amp;&amp;<span class="built_in">stoi</span>(s)&lt; <span class="built_in">stoi</span>(path))&#123;</span><br><span class="line"><span class="comment">//            ans.push_back(stoi(path));</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(u)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">0</span>)start=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;=<span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> b=path;</span><br><span class="line">            path+= <span class="built_in">to_string</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(s,u+<span class="number">1</span>,path);</span><br><span class="line">            path=b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先对u来进行判断，u&#x3D;0，只能从1开始，其他都是</p><h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h2><p>双重dfs，这个题目，首先第一次是遍历，第二次就是进行对以他为root，来查找路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//两个dfs，第一个遍历点，第二几个计算</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        x=targetSum;</span><br><span class="line">        <span class="built_in">dfs1</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(root,x-root-&gt;val);</span><br><span class="line"><span class="comment">//        cout&lt;&lt;&quot;-----------&quot;&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">dfs1</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">dfs1</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(TreeNode* root, <span class="type">long</span> targetSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(targetSum==<span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//       cout&lt;&lt;targetSum&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)<span class="built_in">dfs2</span>(root-&gt;left,targetSum-root-&gt;left-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)<span class="built_in">dfs2</span>(root-&gt;right,targetSum-root-&gt;right-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="473-火柴拼正方形"><a href="#473-火柴拼正方形" class="headerlink" title="473. 火柴拼正方形"></a><a href="https://leetcode.cn/problems/matchsticks-to-square/">473. 火柴拼正方形</a></h2><p>这个就是和之前的分组都是一样的，可以看成k&#x3D;4，求解4个相等的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; st;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">makesquare</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; matchsticks)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum= <span class="built_in">accumulate</span>(matchsticks.<span class="built_in">begin</span>(),matchsticks.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">4</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> k=sum/<span class="number">4</span>;</span><br><span class="line">        <span class="built_in">sort</span>(matchsticks.<span class="built_in">begin</span>(),matchsticks.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(matchsticks.<span class="built_in">back</span>()&gt;k)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        st=<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(matchsticks.<span class="built_in">size</span>(),<span class="literal">false</span>);</span><br><span class="line">        x=k;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(matchsticks,x,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span>  <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> target,<span class="type">int</span> index,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">4</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;u;</span></span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">dfs</span>(nums,x,<span class="number">0</span>,u+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//        if(target&lt;0)return false;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[i]&amp;&amp;target-nums[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                st[i]=<span class="literal">true</span>;</span><br><span class="line"><span class="comment">//                path.push_back(nums[i]);</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(nums,target-nums[i],i+<span class="number">1</span>,u))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                st[i]=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//                path.pop_back();</span></span><br><span class="line">                <span class="comment">//排好序了的,如果当前都没办法减少到0,后面就不可能</span></span><br><span class="line">                <span class="keyword">if</span> (target==x)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后还是使用index开始，最后的一个剪纸条件就是，无论如何这个target都不在改变，那就是失败了。我们可以把target看成某一成的值，但是他在这一层不变，说明以后的层也不变</p><h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h2><p>dfs两次操作就是+，-</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums,<span class="number">0</span>,target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> u,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==nums.<span class="built_in">size</span>()&amp;&amp;target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;=nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums,u+<span class="number">1</span>,target-nums[u]);</span><br><span class="line">        <span class="built_in">dfs</span>(nums,u+<span class="number">1</span>,target+nums[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-BFS&quot;&gt;&lt;a href=&quot;#1-BFS&quot; class=&quot;headerlink&quot; title=&quot;1.BFS&quot;&gt;&lt;/a&gt;1.BFS&lt;/h1&gt;&lt;p&gt;bfs主要包括一下应用，flood fill（洪水灌溉）把所有的值进行填充man，最小步数模型，就是最先到达的形态，</summary>
      
    
    
    
    
    <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
    <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>贪心</title>
    <link href="http://yoursite.com/2023/02/03/%E8%B4%AA%E5%BF%83/"/>
    <id>http://yoursite.com/2023/02/03/%E8%B4%AA%E5%BF%83/</id>
    <published>2023-02-03T08:33:54.000Z</published>
    <updated>2023-02-03T08:56:16.026Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="http://yoursite.com/2023/01/27/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://yoursite.com/2023/01/27/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2023-01-27T03:54:55.000Z</published>
    <updated>2023-01-27T07:47:03.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1.滑动窗口"></a>1.滑动窗口</h1><p>固定的模板talus就是,设置l,r,首先r++,当满足超过窗口大小的时候,使用while循环,来进行l++,之道跳出这个while循环,最后,还是r&lt;size</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.<span class="built_in">add</span>(s[right]);</span><br><span class="line">    right++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.<span class="built_in">remove</span>(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="76最小覆盖字串"><a href="#76最小覆盖字串" class="headerlink" title="76最小覆盖字串"></a>76最小覆盖字串</h2><p>这个的窗口大小就是t字符串不同的数量,当相等的时候,就进行比较最大值,然后进行移除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:t)&#123;</span><br><span class="line">            rec[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> total=rec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//u是总数,当前的,窗口条件,dp</span></span><br><span class="line">        string ans=s;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>,len=INT_MAX;</span><br><span class="line">       <span class="keyword">while</span>(i&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">           <span class="keyword">if</span> (rec.<span class="built_in">find</span>(s[i])!=rec.<span class="built_in">end</span>())&#123;</span><br><span class="line">               cnt[s[i]]++;</span><br><span class="line">               <span class="keyword">if</span>(cnt[s[i]]==rec[s[i]])&#123;</span><br><span class="line">                   u++;</span><br><span class="line">                   <span class="comment">//统计有多少个了</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//下面是提纯操作,进行更新什么的</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span>(u==total)&#123;</span><br><span class="line">               flag=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(i-j+<span class="number">1</span>&lt;len)&#123;</span><br><span class="line">                    start=j;</span><br><span class="line">                    len=i-j+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="keyword">if</span>(rec.<span class="built_in">find</span>(s[j])!=rec.<span class="built_in">end</span>())&#123;</span><br><span class="line">                   cnt[s[j]]--;</span><br><span class="line">                   <span class="keyword">if</span>(cnt[s[j]]&lt;rec[s[j]])&#123;</span><br><span class="line">                       u--;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">           i++;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(!flag)<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></h2><p>这个和上一题差不多,也是</p><p>这个思路,然后就是如果长度一样,那么就是直接返回true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; rec,window;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s1)rec[c]++;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;s2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c=s2[l];</span><br><span class="line">            <span class="keyword">if</span>(rec.<span class="built_in">count</span>(c))&#123;</span><br><span class="line">                window[c]++;</span><br><span class="line">                <span class="keyword">if</span> (window[c]==rec[c])u++;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">while</span>(u==rec.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(l-r==s1.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">auto</span> t=s2[r];</span><br><span class="line">                <span class="keyword">if</span>(rec.<span class="built_in">count</span>(t))&#123;</span><br><span class="line">                    window[t]--;</span><br><span class="line">                    <span class="keyword">if</span>(window[t]&lt;rec[t])&#123;</span><br><span class="line">                        u--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>求出最大的最长字串,那么这个窗口就是每一个字母出现的次数就是1,超过1,就开始进行滑动窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> c=s[r];</span><br><span class="line">            rec[c]++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//abb</span></span><br><span class="line">            <span class="keyword">while</span>(rec[s[r]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> t=s[l];</span><br><span class="line">                rec[t]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,r-l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></h2><p>这个就是滑动窗口是0出现的次数，然后如果超过k，就进行更新</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//窗口值就是k，放的是0</span></span><br><span class="line"><span class="comment">//        unordered_map&lt;int,int&gt; rec;</span></span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> c=nums[r];</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">0</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">while</span>(cnt&gt;k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]==<span class="number">0</span>)&#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时就是cnt==k</span></span><br><span class="line">            ans=<span class="built_in">max</span>(ans,r-l);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></h2><p>这个的滑动窗口就是最大值减去最小值是小于k，所以一旦超过就进行更新，使用set可以来得到最大值还有最小值，然后进行计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int l=0,r=0;</span></span><br><span class="line"><span class="comment">//        int ans=0;</span></span><br><span class="line"><span class="comment">//        multiset&lt;int&gt; s;</span></span><br><span class="line"><span class="comment">//        while(r&lt;nums.size())&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            s.insert(nums[r]);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            while(*s.rbegin()-*s.rend()&gt;limit)&#123;</span></span><br><span class="line"><span class="comment">//                s.erase(s.find(nums[l]));</span></span><br><span class="line"><span class="comment">//                l++;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            r++;</span></span><br><span class="line"><span class="comment">//            ans= max(ans,r-l);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return ans;</span></span><br><span class="line">        multiset&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            st.<span class="built_in">insert</span>(nums[right]);</span><br><span class="line">            <span class="keyword">while</span> (*st.<span class="built_in">rbegin</span>() - *st.<span class="built_in">begin</span>() &gt; limit) &#123;</span><br><span class="line">                st.<span class="built_in">erase</span>(st.<span class="built_in">find</span>(nums[left]));</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">is_ok</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">            t=<span class="built_in">max</span>(<span class="built_in">abs</span>(nums[r]-nums[i]),t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(t, <span class="built_in">is_ok</span>(nums,l,r<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1658-将-x-减到-0-的最小操作数"><a href="#1658-将-x-减到-0-的最小操作数" class="headerlink" title="1658. 将 x 减到 0 的最小操作数"></a><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/">1658. 将 x 减到 0 的最小操作数</a></h2><p>这个的思路就是计算最左+最右&#x3D;5，那我们可以计算中间的&#x3D;整体的-5，然后我们可以使用前缀和，来进行计算，如果等于了，就来计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//这题思路就是统计中间数值是acc（nums）-x的最大距离</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum= <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> target=sum-x;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag= <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            u+=nums[r];</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">while</span>(u&gt;target)&#123;</span><br><span class="line"></span><br><span class="line">                u-=nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (u==target)&#123;</span><br><span class="line">                flag= <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(r-l&gt;res)&#123;</span><br><span class="line">                    res=r-l;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>()-res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    int dfs(vector&lt;int&gt; &amp;nums,int l,int r,int &amp;x)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        if(x&lt;0||l&gt;r)return -1;</span></span><br><span class="line"><span class="comment">//        if(x==0)&#123;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        int t=x;</span></span><br><span class="line"><span class="comment">//        x-=nums[r];</span></span><br><span class="line"><span class="comment">//        auto l1= dfs(nums,l,r-1,x)+1;</span></span><br><span class="line"><span class="comment">//        t-=nums[l];</span></span><br><span class="line"><span class="comment">//        x=t;</span></span><br><span class="line"><span class="comment">//        auto r1= dfs(nums,l+1,r,x)+1;</span></span><br><span class="line"><span class="comment">//        if (l1==-1&amp;&amp;r1==-1)&#123;</span></span><br><span class="line"><span class="comment">//            return -1;</span></span><br><span class="line"><span class="comment">//        &#125;else if (l1==-1)&#123;</span></span><br><span class="line"><span class="comment">//            return r1;</span></span><br><span class="line"><span class="comment">//        &#125; else if(r1==-1)&#123;</span></span><br><span class="line"><span class="comment">//            return l1;</span></span><br><span class="line"><span class="comment">//        &#125;else&#123;</span></span><br><span class="line"><span class="comment">//            return min(l1,r1);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h2><p>这个也还是普通的滑动窗口，大小也是这个k来作为窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> ans=INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (r&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            u+=nums[r++];</span><br><span class="line">            <span class="keyword">while</span>(u&gt;=target)&#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,r-l);</span><br><span class="line">                u-=nums[l++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a><a href="https://leetcode.cn/problems/contains-duplicate-ii/">219. 存在重复元素 II</a></h2><p>检查是不是有重复的，使用双指针，来进行计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">       unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line">       <span class="keyword">while</span>(r&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">           rec[nums[r]]++;</span><br><span class="line">           <span class="keyword">while</span>(rec[nums[r]]==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//               cout&lt;&lt;&quot;ok&quot;;</span></span><br><span class="line">               <span class="keyword">if</span>(nums[l]==nums[r]&amp;&amp;r-l&lt;=k)&#123;</span><br><span class="line">                   cout&lt;&lt;r&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">               rec[nums[l]]--;</span><br><span class="line">               l++;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           r++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="220-存在重复元素-III"><a href="#220-存在重复元素-III" class="headerlink" title="220. 存在重复元素 III"></a><a href="https://leetcode.cn/problems/contains-duplicate-iii/">220. 存在重复元素 III</a></h2><p>这是上面一个题目的扩张，有两个值来进行计算，使用set来进行计算。首先找到比当前值num【i】-t大的值，如果没有就跳过，有而且还满足就是true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int indexDiff, int valueDiff) &#123;</span><br><span class="line">        int l=0,r=0;</span><br><span class="line">        set&lt;long&gt;st;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            auto lb = st.lower_bound((long)nums[i] - valueDiff);</span><br><span class="line">            if (lb != st.end() &amp;&amp; *lb &lt;= (long)nums[i] + valueDiff) return 1;</span><br><span class="line">            st.insert(nums[i]);</span><br><span class="line">            if (i &gt;= indexDiff) st.erase(nums[i - indexDiff]);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="395-至少有-K-个重复字符的最长子串"><a href="#395-至少有-K-个重复字符的最长子串" class="headerlink" title="395. 至少有 K 个重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></h2><p>选出至少有k个，这个提普通的窗口没有办法处理，使用枚举的方法，我们手动设置窗口，1-26为出现不同的异构字母，然后满足的窗口来进行滑动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;char,int&gt; PII;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">// 思路枚举出现不同的次数，作为窗口，，1-26，就是串口的大小，然后进行计算</span><br><span class="line">//int longestSubstring(string s, int k) &#123;</span><br><span class="line"></span><br><span class="line">    int k;</span><br><span class="line">    unordered_map&lt;char,int&gt;cnt;//字符的个数</span><br><span class="line">    void add(char c ,int&amp; x ,int&amp; y)&#123;</span><br><span class="line">        if(!cnt[c])x++;//如果当前字符以前没有,不同字符种数++</span><br><span class="line">        cnt[c]++;</span><br><span class="line">        if(cnt[c] == k)y++;//如果加上c之后,刚好满足条件(即字符c的个数不少于k),则满足条件的字符种数++</span><br><span class="line">    &#125;</span><br><span class="line">    void del(char c, int&amp; x , int&amp; y)&#123;</span><br><span class="line">        if(cnt[c] == k)y--;//如果当前c字符刚好满足条件,则去掉一个后,不再满足条件,则满足条件的字符种数--</span><br><span class="line">        cnt[c]--;</span><br><span class="line">        if(!cnt[c])x--;//如果刚好字符c删没了,则不同字符种数--</span><br><span class="line">    &#125;</span><br><span class="line">    int longestSubstring(string s, int _k) &#123;</span><br><span class="line">        k=_k;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        if(n &lt; k)return 0;</span><br><span class="line">        //允许字符的种数</span><br><span class="line">        for(int c = 1 ; c &lt;= 26 ; c++)&#123;//只允许一个字符,只允许两个字符,...</span><br><span class="line">            cnt.clear();</span><br><span class="line">            //i是遍历在前面的指针,j是遍历在后面的指针,x是当前窗口内不同字符的种数,y是当前窗口内满足条件的字符的种数</span><br><span class="line">            for(int i = 0 ,j = 0 , x = 0 , y = 0; i &lt; n ; i ++)&#123;//遍历字符串s</span><br><span class="line">                add(s[i],x,y);//每次先选先把字符加进来,并更新x和y</span><br><span class="line">                while(x&gt;c)del(s[j++],x,y);//当窗口内遍历到的字符种数超过了当前允许的字符的种数,就删除窗口的末端</span><br><span class="line">                if(x == y)res = max(res ,i-j+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424.替换后的最长重复字符"></a>424.<a href="https://leetcode.cn/problems/longest-repeating-character-replacement/">替换后的最长重复字符</a></h2><p>这个的思路就是r-l-1-max（字符串)&lt;&#x3D;k,所以我们的思路就是进行查找最大值字母</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">characterReplacement</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">// 两个指针</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> Max = <span class="number">-1</span>; <span class="comment">// 当前区间出现最多的字符数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span> &gt; <span class="title">nums</span><span class="params">(<span class="number">26</span>)</span></span>;  <span class="comment">// 用来统计字符出现的个数</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(right &lt; n)&#123;</span><br><span class="line">            <span class="comment">// 每次去更新字符出现的最大数</span></span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            nums[c - <span class="string">&#x27;A&#x27;</span>] ++ ;</span><br><span class="line">            Max = <span class="built_in">max</span>(Max, nums[c - <span class="string">&#x27;A&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断区间是否满足条件 注意这里当left++的时候，要提前更新Max，在left++</span></span><br><span class="line">            <span class="keyword">while</span>(right - left + <span class="number">1</span> - Max &gt; k)&#123;</span><br><span class="line">                nums[s[left] - <span class="string">&#x27;A&#x27;</span>] --;</span><br><span class="line">                Max = <span class="built_in">max</span>(Max, nums[s[left] - <span class="string">&#x27;A&#x27;</span>]);</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时的 [left, right]的区间一定是满足条件的，更新答案即可。</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="713-乘积小于-K-的子数组"><a href="#713-乘积小于-K-的子数组" class="headerlink" title="713. 乘积小于 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a></h2><p>这个题目的思路还是比较简单，主要的是如何进行求和。当l到r满足小于的，l+1，l+2的一定也满足，那么ans+&#x3D;r-l+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> u=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            u*=nums[r];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(u&gt;=k)&#123;</span><br><span class="line">                u/=nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=r-l+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//因为l到r满足小于k，l+1到r也是，l+2到r也是</span></span><br><span class="line"><span class="comment">//            那么就是计算l到r的距离</span></span><br><span class="line">            r++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-滑动窗口&quot;&gt;&lt;a href=&quot;#1-滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;1.滑动窗口&quot;&gt;&lt;/a&gt;1.滑动窗口&lt;/h1&gt;&lt;p&gt;固定的模板talus就是,设置l,r,首先r++,当满足超过窗口大小的时候,使用while循环,来进行l++</summary>
      
    
    
    
    
    <category term="滑动窗口" scheme="http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>回溯总结</title>
    <link href="http://yoursite.com/2023/01/26/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2023/01/26/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93/</id>
    <published>2023-01-26T03:03:40.000Z</published>
    <updated>2023-01-27T04:01:08.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-回溯总结"><a href="#1-回溯总结" class="headerlink" title="1.回溯总结"></a>1.回溯总结</h1><p>主要参考下面的题目，<a href="https://www.programmercarl.com/">代码随想</a>，还有<a href="https://labuladong.github.io/algo/di-san-zha-24031/">labuladong</a>，这个类型的主要思路就是，找</p><p>到结束条件，然后就是进行选择，放入之后，就再次进行放出</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>包含下面几个题目</p><h2 id="46全排列"><a href="#46全排列" class="headerlink" title="46全排列"></a>46全排列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; st;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        st=<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; (nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[i])&#123;</span><br><span class="line">                st[i]=<span class="literal">true</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(nums,u+<span class="number">1</span>);</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                st[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先还是使用ans进行保存，使用st进行验证，u代表成功的个数，当为n，就是可以进行添加，从0开始进行访问所有的值</p><h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51.N皇后"></a>51.N皇后</h2><p>这个题目就是进行求解，他的check条件就是列上没有，，斜线上没有，斜线就是当前的点（x-1，y-1），（x-1，y+1），检查这些值有没有，没有就放，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        res=<span class="built_in">vector</span>&lt;string&gt;(n,<span class="built_in">string</span>(n,<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">        <span class="built_in">dfs</span>(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==u)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isok</span>(u,i))&#123;</span><br><span class="line">                res[u][i]=<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(n,u+<span class="number">1</span>);</span><br><span class="line">                res[u][i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isok</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">//统计每一个竖起来的</span></span><br><span class="line">        <span class="comment">//统计左上还有右下</span></span><br><span class="line">        <span class="type">int</span> n=res.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;=u; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(res[j][i]==<span class="string">&#x27;Q&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//45°检查</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = u<span class="number">-1</span>,k=i<span class="number">-1</span>; j&gt;=<span class="number">0</span>&amp;&amp;k&gt;=<span class="number">0</span> ; j--,k--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(res[j][k]==<span class="string">&#x27;Q&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = u<span class="number">-1</span>,k=i+<span class="number">1</span>; j&gt;=<span class="number">0</span>&amp;&amp;k&lt;n ; j--,k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(res[j][k]==<span class="string">&#x27;Q&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="112路径总和"><a href="#112路径总和" class="headerlink" title="112路径总和"></a>112路径总和</h2><p>从根节点开始寻找，两种dfs方式，一种就是在for循环里面进行回溯，还有一种在最开始进行回溯。</p><p>这个就是在里面进行回溯，因为是直接开始减的，所以，不需要把target还原</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root,targetSum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target==<span class="number">0</span>&amp;&amp;!root-&gt;left&amp;&amp;!root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        if (target&lt;0)return false;</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="type">bool</span> left= <span class="built_in">dfs</span>(root-&gt;left,target-root-&gt;left-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (left)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(root-&gt;right,target-root-&gt;right-&gt;val))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="140-单词拆分"><a href="#140-单词拆分" class="headerlink" title="140.单词拆分"></a>140.单词拆分</h2><p>这个题目还是回溯，本质就是对i从u开始，进行截取，然后，看是不是在指点里面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; rec;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word:wordDict)&#123;</span><br><span class="line">            rec[word]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="comment">//排除末尾</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            path+=<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt;s.<span class="built_in">size</span>() ; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t=s.<span class="built_in">substr</span>(u,i-u+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(rec.<span class="built_in">find</span>(t)!=rec.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">auto</span> x=path;</span><br><span class="line">                path+=t+<span class="string">&quot; &quot;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(s,i+<span class="number">1</span>);</span><br><span class="line">                path=x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="17-电话组合"><a href="#17-电话组合" class="headerlink" title="17.电话组合"></a>17.电话组合</h2><p>还不是组合一样，放入字符串里面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string strs[<span class="number">10</span>] = &#123;</span><br><span class="line">            <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">            <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">empty</span>())<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">dfs</span>(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string digits,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;digits.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> n=digits[u]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[n].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(strs[n][i]);</span><br><span class="line">            <span class="built_in">dfs</span>(digits,u+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string path;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; rec;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">2</span>*n)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;path&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="keyword">if</span>(rec.<span class="built_in">find</span>(<span class="string">&#x27;(&#x27;</span>)==rec.<span class="built_in">end</span>()||rec[<span class="string">&#x27;(&#x27;</span>]&lt;n)&#123;</span><br><span class="line">            path+=<span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            rec[<span class="string">&#x27;(&#x27;</span>]++;</span><br><span class="line">            <span class="built_in">dfs</span>(n,u+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            rec[<span class="string">&#x27;(&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec.<span class="built_in">find</span>(<span class="string">&#x27;)&#x27;</span>)==rec.<span class="built_in">end</span>()||rec[<span class="string">&#x27;)&#x27;</span>]&lt;rec[<span class="string">&#x27;(&#x27;</span>])&#123;</span><br><span class="line">            path+=<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            rec[<span class="string">&#x27;)&#x27;</span>]++;</span><br><span class="line">            <span class="built_in">dfs</span>(n,u+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            rec[<span class="string">&#x27;)&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>两个剪纸，一个是长度都是n，括号，还有一个就是右括号小于左的</p><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h2><p>这个就是组合数，使用i到u进行遍历，然后还有一个就是，直接从i开始，不是i+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> u,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index==nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(u&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums,u-nums[i],i);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这个就是从i即系开始，可以重复使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; c, int target) &#123;</span><br><span class="line">            dfs(c,0,target);</span><br><span class="line">            return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; c,int u,int target )&#123;</span><br><span class="line">        // u代表当前循环到哪一个了数字呢</span><br><span class="line">        // 考虑边界</span><br><span class="line">        if(target==0)&#123;</span><br><span class="line">            ans.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(u==c.size())&#123;</span><br><span class="line">            return;</span><br><span class="line">            // 直接返回</span><br><span class="line">        &#125;</span><br><span class="line">        // 接下来就是放入放出</span><br><span class="line">        for(int i=0;i*c[u]&lt;=target;i++)&#123;</span><br><span class="line"></span><br><span class="line">            dfs(c,u+1,target-i*c[u]);</span><br><span class="line">            path.push_back(c[u]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 这是选择加入一个后，再对后面的进行加入</span><br><span class="line">            // target-i*c[u]是加入当前的次数，u+1是下一个值</span><br><span class="line">             // 回复现场</span><br><span class="line">             </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i*c[u]&lt;=target;i++)&#123;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>这个代码很不错，因为是先dfs然后再push，为什么了，因为先dfs，代表选0个当前的，之后放入一个，就是选了一个dfs，而且是在dfs之后选择下一个值，而且，target因为是没有变，所以直接减去i*cu</strong></p><h2 id="698-划分k个相等的子集"><a href="#698-划分k个相等的子集" class="headerlink" title="698.划分k个相等的子集"></a>698.划分k个相等的子集</h2><p>首先的先决条件就是sum数组的和可以整除k，而且最后一个数，一定小于平均数。之后就是进行回溯，代码思路，使用dfs(nums,avg,k,u)</p><p>含义就是当avg为0的时候，可以进行k-1（表示又有一组满足了，然后u从开始进行寻找，avg再次恢复到初始值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt;path;</span><br><span class="line">    vector&lt;bool&gt; st;</span><br><span class="line">    int t;</span><br><span class="line">    int avg;</span><br><span class="line">    bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">         auto sum=accumulate(nums.begin(),nums.end(),0);</span><br><span class="line">        if(sum%k!=0)return false;</span><br><span class="line">        st=vector&lt;bool&gt;(nums.size(),false);</span><br><span class="line">        int target=sum/k;</span><br><span class="line">        if (nums.back()&gt;target)return false;</span><br><span class="line">//</span><br><span class="line">        t=k;</span><br><span class="line">        avg=target;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        return dfs(nums,target,0,0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    bool  dfs(vector&lt;int&gt; &amp;nums,int target,int index,int u)&#123;</span><br><span class="line">        if(u==t)return true;</span><br><span class="line">//        cout&lt;&lt;u;</span><br><span class="line">        if(target==0)return dfs(nums,avg,0,u+1);</span><br><span class="line">//        if(target&lt;0)return false;</span><br><span class="line">        for (int i = index; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            if(!st[i]&amp;&amp;target-nums[i]&gt;=0)&#123;</span><br><span class="line">                st[i]=true;</span><br><span class="line">//                path.push_back(nums[i]);</span><br><span class="line">                if(dfs(nums,target-nums[i],i+1,u))&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                st[i]=false;</span><br><span class="line">//                path.pop_back();</span><br><span class="line">                    //排好序了的,如果当前都没办法减少到0,后面就不可能</span><br><span class="line">                if (target==avg)return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>if (target&#x3D;&#x3D;avg)return false;重要剪纸，当表示值不变还是avg，就表示后面更不可能进行减少值，因为后面的都比当前值大，target会一直不变，所以不能选择，直接失败</strong></p><h2 id="77-组合数"><a href="#77-组合数" class="headerlink" title="77.组合数"></a>77.组合数</h2><p>组合数，就是进行选择，首先进行排序，i到u开始，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rec;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt;st;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        st=<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; (n+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!k)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(rec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; n+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">            rec.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(n,k<span class="number">-1</span>,i+<span class="number">1</span>);</span><br><span class="line">            rec.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="78-幂集"><a href="#78-幂集" class="headerlink" title="78,幂集"></a>78,幂集</h2><p>就是返回所有的选择,直接在上面的进行手动设置k</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rec;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(nums,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> k,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!k)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(rec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            rec.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums,k<span class="number">-1</span>,i+<span class="number">1</span>);</span><br><span class="line">            rec.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="40-组合综合"><a href="#40-组合综合" class="headerlink" title="40.组合综合"></a>40.组合综合</h2><p>进行筛选,而且不能含有重复的,首先进行选择就是i到u,去重就是要使用那个continue,与前面相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> target,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;=nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;target&lt;&lt;&quot;  &quot;;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;target)<span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;u&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums,target-nums[i],i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//            rec[nums[i]]=1;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>if (i&gt;u&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1])continue;去重代码,不需要使用st,来表示,因为后面都是没有访问的</p><h2 id="216-组合综合"><a href="#216-组合综合" class="headerlink" title="216.组合综合"></a>216.组合综合</h2><p>还是之前一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,k,n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> k,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!n)ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k)&#123;</span><br><span class="line">            <span class="comment">// 说明还有字数需要</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n&gt;=i)&#123;</span><br><span class="line">                    path.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    <span class="built_in">dfs</span>(i+<span class="number">1</span>,k<span class="number">-1</span>,n-i);</span><br><span class="line">                    path.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h2><p>还是之前一样,check条件就是是不是会问,如果是true,直接返回</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> x=s.<span class="built_in">substr</span>(u,i-u+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">is_ok</span>(x))&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(x);</span><br><span class="line">                <span class="built_in">dfs</span>(s,i+<span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_ok</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x=s;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> x==s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="93复原ip地址"><a href="#93复原ip地址" class="headerlink" title="93复原ip地址"></a>93复原ip地址</h2><p>这个首先是对于0,直接继续,而且,一共只有4个小数点,最后一个在加入的时候去除,之后就是普通的回溯</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        start=<span class="number">0</span>,end=<span class="number">255</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(s,<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s,<span class="type">int</span> times,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不出现011</span></span><br><span class="line">        <span class="comment">//只有3个小数点可以进行加入</span></span><br><span class="line">        <span class="keyword">if</span> (!times&amp;&amp;u==s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (times&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;=s.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[u]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            path+=<span class="string">&quot;0.&quot;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(s,times<span class="number">-1</span>,u+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-u+<span class="number">1</span>&gt;<span class="number">3</span>)<span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">auto</span> x=s.<span class="built_in">substr</span>(u,i-u+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> t= <span class="built_in">stoi</span>(x);</span><br><span class="line">                <span class="keyword">if</span>(t&lt;=<span class="number">255</span>)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> back=path;</span><br><span class="line">                    path+=x+<span class="string">&quot;.&quot;</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(s,times<span class="number">-1</span>,i+<span class="number">1</span>);</span><br><span class="line">                    path=back;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>对于签到0的优化方法就是把循环的下一位变成u+1,不是s.size</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n=u+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[u]!=<span class="string">&#x27;0&#x27;</span>)n=s.<span class="built_in">size</span>();</span><br><span class="line">       </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt; n; ++i) &#123;</span><br></pre></td></tr></table></figure><h2 id="90子集"><a href="#90子集" class="headerlink" title="90子集"></a>90子集</h2><p>这个就是进行去重,直接看是不是相等,然后continue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(nums,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> n,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;=nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i =u; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;u&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums,n<span class="number">-1</span>,i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为都是排序了的,后面一定没有访问,所以不用st</p><h2 id="47全排列"><a href="#47全排列" class="headerlink" title="47全排列"></a>47全排列</h2><p>进行去重,这个就是需要st数组,因为从是排列,而且需要进行去重,所以是从0开始的,需要st</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 这题的意思就是要融合，消去2个112</span></span><br><span class="line"><span class="comment">// 去重使用三个数之和的方法，是不是前面一个相同，相同就跳过了</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; st;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        path= <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">size</span>());</span><br><span class="line">        st= <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> u )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;&amp;nums[i<span class="number">-1</span>]==nums[i]&amp;&amp;!st[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 前面一个还没有使用，那就用前面那个1</span></span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                path[u] = nums[i];</span><br><span class="line">                <span class="built_in">dfs</span>(nums, u + <span class="number">1</span>);</span><br><span class="line">                st[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="491递增子序列"><a href="#491递增子序列" class="headerlink" title="491递增子序列"></a>491递增子序列</h2><p>因为没有排序,不能排序,所以只能使用set来进行作为</p><p>本人思路,就是对所有n的n从2到size进行遍历,然后加进去,使用set去除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    set&lt;vector&lt;<span class="type">int</span>&gt;&gt; s;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;=nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(nums,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> n,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(path)==s.<span class="built_in">end</span>())&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">                s.<span class="built_in">insert</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = u; i &lt;nums.<span class="built_in">size</span>() ; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(path.<span class="built_in">empty</span>()||nums[i]&gt;=path.<span class="built_in">back</span>())&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(nums,n<span class="number">-1</span>,i+<span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-小结"><a href="#2-小结" class="headerlink" title="2.小结"></a>2.小结</h1><p>上面的几个经典题目,一个去重,前面相等直接跳过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(i&gt;u&amp;&amp;num[i]==num[i-1])continue</span><br></pre></td></tr></table></figure><p>第二个就是前导0的问题,一般是只能用做单独的0,那么距离就是u+1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n=s.size();</span><br><span class="line">if(s[i]==&#x27;0&#x27;)n=u+1:</span><br><span class="line">for(int i=u;i&lt;n;i++)</span><br></pre></td></tr></table></figure><p>第三个就是排列组合,排列的话就是从0开始,设置st数组.</p><p>组合的就是从u开始,去重和上面是一样的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-回溯总结&quot;&gt;&lt;a href=&quot;#1-回溯总结&quot; class=&quot;headerlink&quot; title=&quot;1.回溯总结&quot;&gt;&lt;/a&gt;1.回溯总结&lt;/h1&gt;&lt;p&gt;主要参考下面的题目，&lt;a href=&quot;https://www.programmercarl.com/&quot;&gt;代码</summary>
      
    
    
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2023/01/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2023/01/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-01-17T08:45:25.000Z</published>
    <updated>2023-01-18T04:14:12.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="1-设计模式"><a href="#1-设计模式" class="headerlink" title="1.设计模式"></a>1.设计模式</h1><p>设计模式主要包括一下三种创建者模式,结构模式还有行为模式</p><h1 id="2创建者模式"><a href="#2创建者模式" class="headerlink" title="2创建者模式"></a>2创建者模式</h1><p>主要包括以下工厂模式,单例模式,原型模式还有抽象工厂模式,最后是建造者模式</p><h2 id="2-1工厂模式"><a href="#2-1工厂模式" class="headerlink" title="2.1工厂模式"></a>2.1工厂模式</h2><p>简单点说:两个接口,一个食物类接口,一个工厂类接口,工厂接口来进行创建食物,使用工厂进行创建对象</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/loger.jpg"></p><h2 id="2-2抽象工厂模式"><a href="#2-2抽象工厂模式" class="headerlink" title="2.2抽象工厂模式"></a>2.2抽象工厂模式</h2><p>例子就是一个店子可以做咖啡还有甜品,所以继承工厂类,做两个视频,一个咖啡,一个蛋糕</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg"></p><p>可以看出,每一个工厂类都有做产品a还有做产品b的方法</p><h2 id="2-3单例模式"><a href="#2-3单例模式" class="headerlink" title="2.3单例模式"></a>2.3单例模式</h2><p>顾名思义就是无论如何,指挥产生一个对象instance,最简单的方法就是私有构造函数,然后使用静态变量生成instance,这届得到</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Singleton.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Singleton * Singleton::instance = <span class="literal">NULL</span>;</span><br><span class="line">Singleton::<span class="built_in">Singleton</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton::~<span class="built_in">Singleton</span>()&#123;</span><br><span class="line"><span class="keyword">delete</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Singleton::singletonOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;singletonOperation&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4建造者模式"><a href="#2-4建造者模式" class="headerlink" title="2.4建造者模式"></a>2.4建造者模式</h2><p>这个例子就是工厂工人做每一步,然后最后进行组装</p><p>todo:还没写完</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Builder.jpg"></p><h1 id="3-行为模式"><a href="#3-行为模式" class="headerlink" title="3.行为模式"></a>3.行为模式</h1><h2 id="3-1适配器模式"><a href="#3-1适配器模式" class="headerlink" title="3.1适配器模式"></a>3.1适配器模式</h2><p>例子:就是电源适配器(欧洲电源需要转接口才能使用),适配器就是转换头</p><p>所以我们需要实现欧洲的接口,但是继承国内的充电头,一个impl一个extend</p><p>然后在impl里面调用extend函数</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Adapter_classModel.jpg"></p><h2 id="3-2桥接模式"><a href="#3-2桥接模式" class="headerlink" title="3.2桥接模式"></a>3.2桥接模式</h2><p>主要是减少使用继承类,例如四边形,子类是长方形还有正方形,但是子类还有红色和蓝色的长方形</p><p>我们使用颜色类聚类到四边形里面,这样就可以减少子类,所以我们,我们在color里面实现,蓝色还有绿色,</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Bridge.jpg"></p><h2 id="3-3桥接模式"><a href="#3-3桥接模式" class="headerlink" title="3.3桥接模式"></a>3.3桥接模式</h2><p>就是代购火车票,方法都一样的,售票处售票,代购店也要售票,代购店售票的方法就是使用售票处的方法</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Proxy.jpg"></p><p>都要实现接口,同时调用真实接口</p><h2 id="3-4享元模式"><a href="#3-4享元模式" class="headerlink" title="3.4享元模式"></a>3.4享元模式</h2><p>贡献模式,每次调用都是相同的的值,但是修改一些属性而已</p><p>主要使用map,来得到相同的元素,map[i]</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Flyweight.jpg"></p><h2 id="3-5外观模式"><a href="#3-5外观模式" class="headerlink" title="3.5外观模式"></a>3.5外观模式</h2><p>基金经理帮我们来买股票,这样我们就不需自己进行选择股票</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Facade.jpg"></p><h2 id="3-6装饰模式"><a href="#3-6装饰模式" class="headerlink" title="3.6装饰模式"></a>3.6装饰模式</h2><p>就是炒饭+鸡蛋+肉+其他的,因此,炒房还有配料都要继承食物类别</p><p>同时配料类还要聚合食物类,这样就可以进行添加配料</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Decorator.jpg"></p><p>decorate是配料类,聚合食物类,设置get set方法,最后的总价价格&#x3D;this.getprice+this.getfood.getcost</p><h1 id="4-行为型模式"><a href="#4-行为型模式" class="headerlink" title="4.行为型模式"></a>4.行为型模式</h1><h2 id="4-1策略模式"><a href="#4-1策略模式" class="headerlink" title="4.1策略模式"></a>4.1策略模式</h2><p>最简单的模式,直接使用接口实现多个策略就可以,聚合策略就可以</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Strategy.jpg"></p><h2 id="4-2命令模式"><a href="#4-2命令模式" class="headerlink" title="4.2命令模式"></a>4.2命令模式</h2><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Command.jpg"></p><p>简单来说就是命令来控制厨师,让厨师做事,让服务员收拾订单</p><h2 id="4-3中介模式"><a href="#4-3中介模式" class="headerlink" title="4.3中介模式"></a>4.3中介模式</h2><p>中介这个人看碟子下菜,看对面是什么类型,然后调用不同的交互方法</p><p>使用get set方法来把中介者里面.</p><p>同时colleagues也要把中介放进去</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Mediator.jpg"></p><h2 id="4-4观察者模式"><a href="#4-4观察者模式" class="headerlink" title="4.4观察者模式"></a>4.4观察者模式</h2><p>例子就是订阅公众号,公众号添加用户,公众号推送更新,调用用户更新.使用list添加</p><p>subject是公众号,observe是微信用户,公众号的时候添加用户,使用for</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Obeserver.jpg"></p><h2 id="4-5状态模式"><a href="#4-5状态模式" class="headerlink" title="4.5状态模式"></a>4.5状态模式</h2><p>state是多个状态有电梯运行,电梯停止,电梯开门等多个状态,减少判断switch逻辑</p><p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/State.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h1 id=&quot;1-设计模式&quot;&gt;&lt;a href=&quot;#1-设计模式&quot; class=&quot;headerlink&quot; title=&quot;1.设计模式&quot;&gt;&lt;/a&gt;1.设计模式&lt;/h1&gt;&lt;p&gt;设</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>摄影技巧</title>
    <link href="http://yoursite.com/2023/01/05/%E6%91%84%E5%BD%B1%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2023/01/05/%E6%91%84%E5%BD%B1%E6%8A%80%E5%B7%A7/</id>
    <published>2023-01-05T06:51:23.000Z</published>
    <updated>2023-01-09T04:25:19.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摄影技巧"><a href="#摄影技巧" class="headerlink" title="摄影技巧"></a>摄影技巧</h1><h2 id="1-拍摄"><a href="#1-拍摄" class="headerlink" title="1.拍摄"></a>1.拍摄</h2><h3 id="1-1基础知识"><a href="#1-1基础知识" class="headerlink" title="1.1基础知识"></a>1.1基础知识</h3><p>硬件部分：</p><ol><li>光圈（f1.4，f2.2）数值越小就越好</li><li>快门（曝光时间，如果要拍摄晚上车水马龙，需要延长快门时间</li><li>ISO（可以提高曝光率，但是变大会有噪点）</li></ol><p>手机没有办法像单反那样，可以得到不同的焦距，所以只能用多个摄像头来进行获得不同的焦段，5倍，10倍，60倍。剩下的2倍使用算法进裁剪得到，所以还是一般使用固定的焦距。</p><h3 id="1-2光的知识"><a href="#1-2光的知识" class="headerlink" title="1.2光的知识"></a>1.2光的知识</h3><p>光强：</p><ol><li>亮度（明亮成都）</li><li>距离（越远越低）</li><li>光面积（越大越强）</li><li>反光率</li></ol><p>色温：</p><p>光质：</p><ol><li>硬广</li><li>软光（通过放入纸巾，可以把赢的变软（漫反射）</li></ol><p>光比：明暗对比</p><p>光影：影子</p><h3 id="1-3色彩"><a href="#1-3色彩" class="headerlink" title="1.3色彩"></a>1.3色彩</h3><p>色相：（颜色名称，红黄蓝）</p><p>明度：颜色的亮度</p><p>饱和度：洗衣服，掉色，颜色越来越淡</p><p>色相环（一般都是互补色，家教为180）黄色还有蓝色</p><p>冷暖对比（上冷下暖）</p><p>黄图还有蓝天</p><h3 id="1-4构图"><a href="#1-4构图" class="headerlink" title="1.4构图"></a>1.4构图</h3><p>点构图：</p><ol><li>中心点</li><li>九宫格法（放到四个焦点）</li><li>引导线（忘一个点走）</li></ol><p>线构图：</p><ol><li>对称（镜面）</li><li>二分线（九宫格）</li><li>三分线</li><li>引导线</li><li>对角线</li></ol><p>面构图：</p><ol><li>框架（被框柱）</li><li>三角</li><li>重复出现</li><li>留白</li></ol><h3 id="1-5专业模式"><a href="#1-5专业模式" class="headerlink" title="1.5专业模式"></a>1.5专业模式</h3><p>主要就是让自己手动设置快门，光圈还有感光度</p><p>光圈：（光圈越大，进光越大，一般就是使用人像），越小越好f1.4</p><p>快门：（打开门的时间，时间越短，就是记录的越来越快），时间越长，进光越多</p><p>感光度：（iso越大越亮，但是会出现噪点</p><p>景深：就是手动进行对焦</p><p>晚间拍摄车水马龙：调大光圈，然后延长曝光时间，iso一般不用设置，因为出现过度</p><p>shuttle（快门） af，mf来进行对焦</p><p>白平衡：进行设置色温的冷暖（越低越暖）</p><p>打开raw可以进行设置</p><h3 id="1-6夜景"><a href="#1-6夜景" class="headerlink" title="1.6夜景"></a>1.6夜景</h3><p>iso低，延长曝光时间</p><p>苹果的就是，实况，长曝光</p><h3 id="1-7人像"><a href="#1-7人像" class="headerlink" title="1.7人像"></a>1.7人像</h3><p>人像一般需要进行虚化，虚化一般需要大光圈。虚化背景</p><p><strong>背景就远离人物，可以拍摄更久，更好的虚化</strong></p><p><strong>拍摄技巧（后退2-3步，然后2-3倍）</strong>（因为，这样可以虚化背景）</p><p>如何拍摄长腿：</p><ol><li>弯腰，然后仰角拍摄</li><li><strong>或者是脚在最下面，然后偷留下1&#x2F;3的空间</strong></li><li><strong>或者对角线拍摄</strong></li></ol><p>或者是自己进行附魔头发</p><h3 id="1-8街拍"><a href="#1-8街拍" class="headerlink" title="1.8街拍"></a>1.8街拍</h3><p>一般使用引导线，然后夜间一般就是长曝光</p><h3 id="1-9风光"><a href="#1-9风光" class="headerlink" title="1.9风光"></a>1.9风光</h3><h3 id="1-10"><a href="#1-10" class="headerlink" title="1.10"></a>1.10</h3><p>微距</p><p>长时间在3-4cm会自动进行触发</p><p>然后喷壶，使用连拍，可以拍摄出动物</p><h3 id="1-11食物"><a href="#1-11食物" class="headerlink" title="1.11食物"></a>1.11食物</h3><p>拍摄角度</p><ol><li>俯拍</li><li>平拍摄（背景</li><li>45°进行拍摄</li></ol><p>构图：</p><ol><li>三角构图（三个食物）</li><li>斜对角线</li><li>中心点</li><li>重复食物</li></ol><p>光纤：放入一张白纸，增加柔软度</p><p>放大片面</p><h3 id="1-12星空"><a href="#1-12星空" class="headerlink" title="1.12星空"></a>1.12星空</h3><p>设置长曝光，iso进行调整</p><p>最后一个就是对焦（设置为无限远，因为要对焦的是星星）</p><p>有限使用主摄，白平衡（设置偏暖）</p><h2 id="2-后期设置"><a href="#2-后期设置" class="headerlink" title="2.后期设置"></a>2.后期设置</h2><h3 id="2-1基础知识"><a href="#2-1基础知识" class="headerlink" title="2.1基础知识"></a>2.1基础知识</h3><p>曝光：调整明亮度</p><p>对比度：就是明与暗的对比</p><p>锐化：图片表面边缘</p><p>饱和度：颜色更鲜艳</p><p>白平衡：调节色温</p><p>褪色：添加颗粒（一般使用胶片的时候）</p><p>肤色：调整人的肤色</p><p>镜头模糊：虚化</p><p>清晰：凸显细节</p><p>使用的软件</p><ol><li>vsco</li><li>snap</li><li>lr泼辣修图</li></ol><h3 id="2-2影调"><a href="#2-2影调" class="headerlink" title="2.2影调"></a>2.2影调</h3><p>图像分为影调还有色影</p><p>影调就是明暗轮廓，主要是从0-255的灰度值，来计算每个地方的数量</p><p>分为以下几个：</p><ol><li>曝光（纯黑）</li><li>对比（有点黑的数量）</li><li>细节（剩下的就是细节）</li><li>阴影（有点白的）</li><li>白色（全是白色的）</li></ol><p>这个可以用曲线来看出</p><p>清晰度：边缘对比</p><h3 id="2-3色调"><a href="#2-3色调" class="headerlink" title="2.3色调"></a>2.3色调</h3><p>色温，调整这个一般都是的相邻色</p><p>主要还是使用曲线来进行设置，剩下的就是hsl来进行设置</p><p>直方图：反应图片（黑色，阴影，细节，高光，白色），这个就是数值</p><p>从左到右是0-255,255是白光</p><p>下面是色彩的直方图</p><p>只有三原色，红绿蓝</p><p>左边是红色的数量少，右边是红色多</p><p>对比度（明暗的对比）</p><p>如何做好，就是模仿别人的直方图</p><h3 id="2-4hsl"><a href="#2-4hsl" class="headerlink" title="2.4hsl"></a>2.4hsl</h3><p>色彩调整</p><p>单一的颜色调整（七原色）</p><p>色相：颜色</p><p>饱和度：鲜艳程度</p><p>明亮度：明暗</p><p>色相：只能是他的相邻色，30平分</p><p>拉动只会到他的相邻色</p><p>调色思路：一般去除杂色，饱和度为0，<strong>然后留下互补色</strong></p><p>一般思路：</p><ol><li><strong>家曝光</strong>，这个在局部调整（增加光进入）</li><li>加对比</li><li>降低高光</li></ol><h3 id="2-6曲线"><a href="#2-6曲线" class="headerlink" title="2.6曲线"></a>2.6曲线</h3><p>一般是两个曲线，明亮曲线（一般用于s行）</p><p>左上是亮度，游侠是暗度</p><p>一般使用锚点，固定每一个的格子</p><p>胶片的思路：一般就是加暗，调低亮度，然后加入颗粒感</p><p>小清新：提高亮度，一般只有2中颜色，调低对比度</p><p><strong>颜色曲线：</strong></p><ol><li>往下就是互补色（红色互补就是蓝+绿）</li><li>往上就是增加强度</li><li>一般使用（2个颜色叠加，来增加第三个颜色）</li></ol><h3 id="2-7颜色分级"><a href="#2-7颜色分级" class="headerlink" title="2.7颜色分级"></a>2.7颜色分级</h3><p>就是使用圆形轮廓，然后设置，可以进行局部设置</p><h3 id="2-10后期实战"><a href="#2-10后期实战" class="headerlink" title="2.10后期实战"></a>2.10后期实战</h3><p>基础问题分析：</p><ol><li>没有层次感（加强对比度，加强清晰感）</li><li>色彩不突出（重新上色，局部提亮，增加曝光）</li></ol><p><strong>青橙思路</strong>：</p><ol><li>适用于风光，建筑，晴天</li><li>主要是互补色</li><li>高光，阴影，细节</li><li>lsh’设置青橙</li></ol><p><strong>暗黑：</strong></p><ol><li>适用于阴雨天</li><li>降低高光，加对比度，增加黑色</li><li>lsh去除杂色，明确颜色</li></ol><p><strong>蓝调：</strong></p><ol><li>增加曝光，降低高光，提高阴影</li><li>色温设定颜色</li></ol><p><strong>小清新：</strong></p><ol><li>天气好</li><li>降低对比度</li><li>一般都是男女为主，加明亮度</li></ol><p>*<em>cyberpunk</em>***：</p><ol><li>一般适用于夜晚</li><li>降低高光，提高阴影，加对比度</li><li>hsl往品红，杨宏走</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;摄影技巧&quot;&gt;&lt;a href=&quot;#摄影技巧&quot; class=&quot;headerlink&quot; title=&quot;摄影技巧&quot;&gt;&lt;/a&gt;摄影技巧&lt;/h1&gt;&lt;h2 id=&quot;1-拍摄&quot;&gt;&lt;a href=&quot;#1-拍摄&quot; class=&quot;headerlink&quot; title=&quot;1.拍摄&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="摄影" scheme="http://yoursite.com/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>excel</title>
    <link href="http://yoursite.com/2022/11/27/excel/"/>
    <id>http://yoursite.com/2022/11/27/excel/</id>
    <published>2022-11-27T11:59:36.000Z</published>
    <updated>2022-11-27T13:00:15.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="excel小结"><a href="#excel小结" class="headerlink" title="excel小结"></a>excel小结</h1><p>通过4个模块来学习excel如何使用，学生成绩表，学习如何对表格进行设置列宽，输入的格式</p><h2 id="4-1学生课程表"><a href="#4-1学生课程表" class="headerlink" title="4.1学生课程表"></a>4.1学生课程表</h2><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16695505408951669550540036.png"></p><p>这个首先就是需要进行第一行的合并单元格，然后进行插入单元格来近似填充文字。之后就是文字输入（这个是要自动换行，使用alt+enter，还有就是，输入3-4，需要设置单元格格式为文本，这样才不会出现问题。</p><p>一下是重点</p><ol><li>在单元格输入多个文字，使用文本框</li><li>输入数字，不会变成日期，需要把格式设置为文本</li><li>分成多行，需要使用alt+enter</li></ol><p>总结：</p><p>第一个案例还是比较简单的，不需要多次学习</p><h2 id="2-学生成绩表"><a href="#2-学生成绩表" class="headerlink" title="2.学生成绩表"></a>2.学生成绩表</h2><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16695508618951669550861471.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16695508758951669550875367.png"></p><p>这个没有效果图</p><p>使用官方教程来精简一下：</p><ol><li>第一个计算年龄（这个就需要使用函数，year（today（））-mid（c4,7,4），偶去今年然后减去省份中第7位开始长度为4的值 2022-2001&#x3D;21</li><li>第二个就是使用分裂，来得到班级，我们通过学号发现，前5位就是班级号。所以我们复制学号，然后到班级版一列，使用分裂，固定宽度为5.就可以进行分列</li><li>有效性，就是检查成绩是不是在0-100，使用有效性，需要先进行设置数据范围，之后全出有效性数据，修改数据值</li><li>计算成绩，这个直接使用公式计算，然后下拉</li><li>计算最高，这个直接使用max，count</li><li>这个在数据的条件格式，突出显示前20%就可以</li><li>选择性粘贴，直接右击，保存至，下一个就是直接乘</li><li>自定义排序</li><li>使用ctrl拖动就可以复制</li><li>合规岗使用筛选，之后使用自定义排序就可</li></ol><p>总结：</p><p>这个也不是很难，还是比较简单的。主要包括函数的使用，对程序员还是比较友好的</p><h2 id="3-班费分析图"><a href="#3-班费分析图" class="headerlink" title="3.班费分析图"></a>3.班费分析图</h2><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16695513598951669551359372.png"></p><p>这个主要是用来进行作图的，精简步骤如下</p><ol><li>选择包含列名的所有数据，之后选择插入柱状图</li><li>这样每一个系列就是列名</li><li>x和y轴就是从0开始的轴</li><li>水平垂直网格，就是每一行所代表的的</li><li>以上所有的操作都可以右击得到</li></ol><p>总结：</p><p>这个总体也不是很难，主要包括的动作，只需要右击属性，更换不同元素就可以进行设置</p><h2 id="4-图书信息表"><a href="#4-图书信息表" class="headerlink" title="4.图书信息表"></a>4.图书信息表</h2><p>信息量最大的一个，学习了多级分类，还有分类筛选</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16695517318951669551731087.png"></p><p>主要包括以上多个功能，我精简的说下如何实现</p><p><strong>高级筛选</strong>，这个需要我们自己首先建立一个筛选表，填上所需要的列名，查找元素，不确定（姓王，可以使用王<em>来代替），这个</em>s正则表达式的任意匹配，上面都是匹配条件，使用高级筛选，选择值为数据区域，条件区域，还有最后的结果区域</p><blockquote><p>单击“高级筛选”工作表，在表内，按要求输入条件数据，单击“开始”选项卡中“筛选”命令的下拉菜单中的“高级筛选”，在弹出的对话框中设置，列表区域设置“图书信息表!$A$2:$J$66”，条件区域设置“高级筛选!$B$2:$F$5”，复制到设置“高级筛选!$B$13”，即可。</p></blockquote><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16695519988991669551998303.png"></p><p><strong>分类汇总</strong>：就是进行分类出，这是那个书库，然后还有这些书库里的树又是那几个出版社出版的。</p><ol><li>单击“分类汇总”工作表，在表内选定A2:J66单元格区域,点击“数<strong>据”选项卡中的“排序”命令，设置主要关键字为“所在书库编号”，次要关键字为“出版社”</strong>（数据里的排序，主要关键是书库，次要是出版社）</li><li>第一次汇总，书库，选择分类汇总，字段为书库，汇总为计数，汇总的值是所在书库编号</li><li>下一个就是分类依据是出版社，然后火种为求和，UI中值是价格（选择对价格进行求和）</li></ol><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16695525368941669552536684.png"></p><p>数据透视表：这个要求是求出每一个书库每一个出版社，每一种类别的值：</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16695527979031669552797175.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16695529268961669552926263.png"></p><p>可以看出，最上面一行是总计，3,6,6,2都是下面的和。</p><p>然后行可以看到是出版社，还有图书类别构成（为什么，因为有4*8行），列就是书库名</p><p>所以我们把书库编号放到列，图书类型，还有出版社方导航，计数值就是图书名称求和</p><p><strong>数据透视图</strong>L:xianshi每一个出版社的人数。</p><p>这个上一个4.3就做过，我们只需要把著作者放到值区域，然后图例就是出版社</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16695534069141669553406891.png"></p><p><strong>合并计算</strong>：计算每个出版社的书的价格</p><blockquote><p>单击“合并计算”工作表，选定A1单元格，点击“数据”选项卡的“合并计算”命令，在弹出对话框中“函数”选“求和”、引用位置选择“图书信息表!$E$2:$F$66”，点击“添加”按钮，勾选“首行”、“最左列”，点击“确定”按钮，即可</p></blockquote><p><strong>选择e2到f66是因为，e2是出版社，f2是价格，直接选择这两个，首行代表，首行也要进行计算，最左列，代表是对最左列进行合并汇总</strong></p><p><strong>模拟计算</strong>：学校新增3000的图书，如果还有一个出版社，要出多少钱，之前的大75折扣</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16695537958951669553795387.png"></p><p>这个是所有的（b2到b6进行打75这扣扣，目前计算是查，所以需要b6来进行补充，所以使用模拟计算来得到b6的值</p><blockquote><p>这个就相当于求b6，使用函数来得到（x+b6）*0.75&#x3D;3000x已知得的，所以模拟计算就是用来求b65</p></blockquote><p>总结：这个案例还是有很多可圈可点的，学的内容还是很多，我做第二次还是不太熟悉，得多次进行练习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;excel小结&quot;&gt;&lt;a href=&quot;#excel小结&quot; class=&quot;headerlink&quot; title=&quot;excel小结&quot;&gt;&lt;/a&gt;excel小结&lt;/h1&gt;&lt;p&gt;通过4个模块来学习excel如何使用，学生成绩表，学习如何对表格进行设置列宽，输入的格式&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="office" scheme="http://yoursite.com/tags/office/"/>
    
    <category term="excel" scheme="http://yoursite.com/tags/excel/"/>
    
  </entry>
  
  <entry>
    <title>数字逻辑</title>
    <link href="http://yoursite.com/2022/11/26/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    <id>http://yoursite.com/2022/11/26/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/</id>
    <published>2022-11-26T07:45:52.000Z</published>
    <updated>2023-01-05T08:11:53.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数电小结"><a href="#数电小结" class="headerlink" title="数电小结"></a>数电小结</h1><h2 id="1-逻辑代数"><a href="#1-逻辑代数" class="headerlink" title="1.逻辑代数"></a>1.逻辑代数</h2><p>第一章主要是讲逻辑代数，主要是离散数学的知识，这些知识在考验期间学过，就直接跳过。包括逻辑化简，最小项还有最大项。砌筑一个新的知识点就是卡洛图。下面简单介绍一下卡诺图。</p><p>卡诺图：用小方格来表示最小项，一个小方格代表一个最小项，然后将这些最小项按照相邻性排列起来<strong>（00 01 11 10）</strong>。</p><p>注意，是使用01还有11，不是01,10这样排列，这样是为了，能够2个都是1可以消除第一位，只留下一，还有10和00也是可以在一起进行消除的。</p><p>无关项：就是值未知的项，值为x，可0可1，一般是为了凑成最大的圈，就把x设置为1</p><p>卡诺图化简规则</p><ol><li>尽量化最大的圈（只能是2的倍数）</li><li>化尽量少的圈</li><li>然后进行看无关项，如果无关项可以进行辅助化简也加进来</li></ol><h2 id="2-组合逻辑"><a href="#2-组合逻辑" class="headerlink" title="2.组合逻辑"></a>2.组合逻辑</h2><p>基础知识：与或非异或，基本的门电路</p><p>电路分析，一般使用一下方法</p><ol><li>直接按照输入输出进行化简</li><li>或者是对表达式，进行逻辑组合进行化简</li><li>或者是真值表，进行最小项来直接得到结果</li></ol><h3 id="2-1组合逻辑电路"><a href="#2-1组合逻辑电路" class="headerlink" title="2.1组合逻辑电路"></a>2.1组合逻辑电路</h3><p>编码器：就是把独热编码进行转化为相应的二进制代码把（0010）转化为二进制就是10（因为是2位使用，二进制就是10）</p><p>优先编码器：允许同时输入两个以上信号，并按优先级输出。例如：10-4线(如74LS147)、 8-3线(如74LS148)。<strong>就是输入多个有效信号，并且按照有限输出</strong></p><p>译码器：3-8译码器，刚才把2进行编码输出为10，那么译码器就是把10，输出为0010</p><p><img src="https://repo.holgerbest.top/img/fyMXeGraTizmxlK.png"></p><p>其中下面456是使能端，当45为低电平，6为高电平的时候才有效（因此，地址的开头可以设置在使能端，通过使能端的逻辑组合，来达到搜寻特定地址例如a8h到afh，后三位接到123，前面5位接到456，使用逻辑电路进行组合</p><p><strong>74LS138应用1 实现逻辑函数</strong>：将逻辑函数转换成最小项表达式，再转换成与非—与非形式。用一片74138加与非门就可实现三变量逻辑函数。</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16729040080261672904007282.png"></p><p>例题：首先画出真值表，得到卡诺图，发现是y2y3y4y5，我们可以在最后面使用与非得到，前面就是选择2345的最小项</p><p>数据选择器：（4选一，需要2位来进行选择，因为2的2次方就是4，这两位数就是地址选择）</p><p><img src="https://repo.holgerbest.top/img/R18Y9mlbF5rQ7Oo.png"></p><p>香浓化简法：把最终的逻辑函数，分成w还有-w，然后最下面进行设置数据选择器。</p><p>例题：2个8选一，构成16选一。</p><p>2片就是16选2，同时还需要设置，使能端，需要进行设置取反</p><p><img src="https://repo.holgerbest.top/img/CP69jouBO1SFlzb.png"></p><h2 id="3-时序电路"><a href="#3-时序电路" class="headerlink" title="3.时序电路"></a>3.时序电路</h2><p>rd的意识就是设置为0</p><p><strong>rs触发器</strong>：特点就是r&#x3D;1，最后q的输出就是为0（r是resert的意思），当s&#x3D;1，最后q就是1（s是set的意思），特征方程如下，rs</p><p><img src="https://repo.holgerbest.top/img/SQ3ACdbkvPrsVBz.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16729055030251672905502326.png"></p><p>这个要换成或非门，只需要我们把r还有s设置真值表，，然后就可以得到逻辑函数，我们知道q非还有q是相反的，所以我们的约束条件是rs&#x3D;0，但是当我们输入00的时候，这个条件就不成立，所以就是约束条件。</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16729057560251672905755304.png"></p><p>接下来就是d触发器（这个就是寄存器的原型，因为输入什么，输出什么）</p><p><img src="https://repo.holgerbest.top/img/ynDgfWOMzUcA1B5.png"></p><p>下面就是t触发器</p><p><img src="https://repo.holgerbest.top/img/EJTLOymIpvPd3hC.png"></p><p>最后一个就是jk触发器，</p><p><img src="https://repo.holgerbest.top/img/nyEHmc3PxdBgk5T.png"></p><p>他有上述的几个触发器的多个特点，j为1，设置0，k为设置为1，全0就是保持不变，全1就是进行取反</p><p>进行多个变形jk变d</p><p><img src="https://repo.holgerbest.top/img/VRsyxivXWPcTz8A.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16729062970281672906296730.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数电小结&quot;&gt;&lt;a href=&quot;#数电小结&quot; class=&quot;headerlink&quot; title=&quot;数电小结&quot;&gt;&lt;/a&gt;数电小结&lt;/h1&gt;&lt;h2 id=&quot;1-逻辑代数&quot;&gt;&lt;a href=&quot;#1-逻辑代数&quot; class=&quot;headerlink&quot; title=&quot;1.逻辑代</summary>
      
    
    
    
    
    <category term="数字逻辑" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
    <category term="ic" scheme="http://yoursite.com/tags/ic/"/>
    
  </entry>
  
  <entry>
    <title>职场networking</title>
    <link href="http://yoursite.com/2022/11/26/%E8%81%8C%E5%9C%BAnetworking/"/>
    <id>http://yoursite.com/2022/11/26/%E8%81%8C%E5%9C%BAnetworking/</id>
    <published>2022-11-26T07:08:19.000Z</published>
    <updated>2022-11-26T07:41:54.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="职场networking"><a href="#职场networking" class="headerlink" title="职场networking"></a>职场networking</h1><p>以下内容来源于小林说职场,关注小林的youtube即可</p><h2 id="1-为什么需要"><a href="#1-为什么需要" class="headerlink" title="1.为什么需要"></a>1.为什么需要</h2><ol><li>帮你快速了解整个流程(大一,找到学长学姐,直接知道大学三年,怎么走)</li><li>然后根据这些经验与其他人相互交流,这样别的人也会觉得你是有点东西的</li></ol><h2 id="2-如何开始"><a href="#2-如何开始" class="headerlink" title="2.如何开始"></a>2.如何开始</h2><p>分为线上还有平级社交,想射由于是boss,有点难度.</p><p>但是平级社交容易开始:</p><blockquote><p>平级社交本质就是价值交换</p></blockquote><p>只有我的价值有用才可以开始社交,普通人之间相互开始的.</p><p>如何开始:</p><ol><li>可以帮助他们查资料(做实验的时候)</li><li>举办活动的时候做志愿者</li><li>逢年过节(写上祝福)</li></ol><p>最简单的方式.</p><p><strong>如何溶蚀他人—-把自己要说的话写好,然后再转发给那个帮你的人(可以节约他的时间)</strong></p><h2 id="3-认识人模板"><a href="#3-认识人模板" class="headerlink" title="3.认识人模板"></a>3.认识人模板</h2><p>还是经典的三段论</p><ol><li>自我介绍</li><li>说明来意</li><li>提出需求</li></ol><p>1.自我介绍:</p><blockquote><p>xxx你好,我叫xxx,来自xxx.我从我那个水知道你,知道你是我们学校的做个这有很高方向的人</p></blockquote><p>2.说明来意:</p><blockquote><p>我目前做的研究与你这个有关联,再研究调养期间,发现你的论文对我很有帮助,然后正在逐步学习你的代码</p></blockquote><p>3.提出需求:</p><blockquote><p>然后发现,您的代码,有些逻辑,不太理解.能1请耽误您15分钟的时间,能简介 一下吗.解决之后(说出好处)</p></blockquote><h2 id="4-附录-社交场合如何networking"><a href="#4-附录-社交场合如何networking" class="headerlink" title="4.附录(社交场合如何networking)"></a>4.附录(社交场合如何networking)</h2><h3 id="4-1开始"><a href="#4-1开始" class="headerlink" title="4.1开始"></a>4.1开始</h3><ol><li>自我介绍(hi,你好,我叫xxx,nicetomeetu)</li><li>跨别人(你这个衣服真不错,直接这么做的呀)</li><li>套近乎(看着比较眼熟,你是哪里的)</li><li>插入别人的对话</li><li>mind i joining</li><li>你们再讨论什么呢,这么有意思</li></ol><h3 id="4-2chat-topic"><a href="#4-2chat-topic" class="headerlink" title="4.2chat topic"></a>4.2chat topic</h3><ol><li>你从哪里来的呀(开车呀,好远,哪里吃的不错)</li><li>你从哪里听到这个活动的呀</li><li>你也是这个活动的会员呀</li><li>环境感觉如何</li><li>经典的吃(茶歇)</li><li>我吃的这个不错,你也可以事实上哦</li><li>单独落单了,你也是第一次参加这个吗</li></ol><h3 id="4-3结束"><a href="#4-3结束" class="headerlink" title="4.3结束"></a>4.3结束</h3><ol><li>我去个厕所</li><li>我吃的没有了,弄点吃的</li><li>太晚了,我该回去了</li><li>我同学来了,我和他打个招呼</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;职场networking&quot;&gt;&lt;a href=&quot;#职场networking&quot; class=&quot;headerlink&quot; title=&quot;职场networking&quot;&gt;&lt;/a&gt;职场networking&lt;/h1&gt;&lt;p&gt;以下内容来源于小林说职场,关注小林的youtube即可&lt;/p</summary>
      
    
    
    
    
    <category term="社交" scheme="http://yoursite.com/tags/%E7%A4%BE%E4%BA%A4/"/>
    
    <category term="人机" scheme="http://yoursite.com/tags/%E4%BA%BA%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>人际社会学</title>
    <link href="http://yoursite.com/2022/11/25/%E4%BA%BA%E9%99%85%E7%A4%BE%E4%BC%9A%E5%AD%A6/"/>
    <id>http://yoursite.com/2022/11/25/%E4%BA%BA%E9%99%85%E7%A4%BE%E4%BC%9A%E5%AD%A6/</id>
    <published>2022-11-25T07:17:18.000Z</published>
    <updated>2022-11-25T08:08:35.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人机解剖"><a href="#人机解剖" class="headerlink" title="人机解剖"></a>人机解剖</h1><h2 id="1-什么叫魅力"><a href="#1-什么叫魅力" class="headerlink" title="1.什么叫魅力"></a>1.什么叫魅力</h2><blockquote><p>刚开始不认识对方还是和和气气的,认识之后就对对方可以调戏.这是因为我们知道了对方的框架.</p></blockquote><p>框架:</p><ol><li>对方能接受的底线(一开始不知道对方的底线)</li><li>包括对方喜欢什么,还有不接受什么</li></ol><p>人与人认识,就是认识对方的框架</p><hr><p>能量:</p><blockquote><p>为什么会在开始,就知道这个人能不能决胜.(因为已经做好准备了,兵马未动,粮草先行)</p></blockquote><p>决定你能不能取胜都是事前的准备(例如1km,取决于之前的锻炼,而不i是今天自己的爆发)</p><p>做好准备就是决定能量的多少就是你的实力</p><hr><p>实力:</p><ol><li>社会是幕强的</li><li>绝对实力再任何技巧面前都是没用的(只要篮球够好,总有一堆人喜欢你的)</li><li>赢家通吃(长得帅一堆女生)</li></ol><hr><p>提升实力:</p><p>能量&#x3D;&#x3D;&gt;包括实力</p><p>实力&#x3D;价值+稀缺性</p><p>实力可以包括:</p><ol><li>兴趣(使用电脑)</li><li>优势(数学&amp;英语)</li></ol><p>价值:取决于你所在位置的用途(滑雪对boss没什么用,只能当运动员)</p><p>稀缺性:阳光,空气还有水都有价值(但没有稀缺性,信息是有稀缺性的)</p><hr><p>稀缺性构建:</p><ol><li>信息过剩(查询到有用信息,查询会计师信息)</li><li>知识(知道信息,学习知识,使用某本书)</li><li>能力(需要联系的,能够和别人谈笑风生,都需要联系自己的交往能力的)</li><li>认识,能出其他人的角度思考</li><li>资源(资源永远是稀缺的,没人带你无法入门)</li></ol><hr><blockquote><p>重点部分</p></blockquote><p><strong>构成实力:</strong></p><ol><li><strong>干就完事了(不要多想)</strong></li><li>保持真实</li><li>再自己的主场(自己的主场,别人大佬也会请教你的,或者是自己的学晓)</li></ol><h2 id="2-人机关系痛苦"><a href="#2-人机关系痛苦" class="headerlink" title="2.人机关系痛苦"></a>2.人机关系痛苦</h2><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><blockquote><p>自己的需求得不到</p></blockquote><p>没有曼珠自己的需求</p><p>需求,不可能一直满足,所以会有痛苦.相反</p><p>当当时得到满足了,那个需求,那么一瞬间就是快乐</p><blockquote><ol><li>辩证的知道,没有痛苦就没有快乐</li><li>痛苦是常态</li></ol></blockquote><h3 id="他人攻击谩骂"><a href="#他人攻击谩骂" class="headerlink" title="他人攻击谩骂"></a>他人攻击谩骂</h3><blockquote><p>别人不喜欢,无所谓了</p></blockquote><blockquote><p>体温，为什么会被别人不喜欢</p><p>因为，他攻击力，是因为你当前这个角色没做好</p></blockquote><p>人是一切关系社会的综合，</p><p><strong>人也是角色的综合</strong></p><ol><li>自己是学生</li><li>自己也是老师</li><li>自己也是儿子</li><li>自己也是男朋友</li><li>自己也是同学</li><li>自己也是公司员工</li></ol><p><strong>高情商就是处理号自己的角色</strong></p><p>家长对孩子也是要辩证的</p><ol><li>孩子顶撞自己</li><li>孩子考试好了(阳)</li></ol><p>他只是攻击这个角色,并不是攻击我</p><hr><blockquote><p><strong>关于忍不忍</strong></p></blockquote><p><strong>主要是看是不是自己的核心利益</strong></p><p>辞职:这个时候辞职了,有没有下一家</p><h3 id="为什么会霸凌"><a href="#为什么会霸凌" class="headerlink" title="为什么会霸凌"></a>为什么会霸凌</h3><blockquote><p>一步步试探底线,发现你都可以接受(所以刚开始就要说不)</p></blockquote><p>为什么会干欺凌(因为没有代价)</p><p>如何解决:</p><ol><li>使劲闹大</li><li>增加犯错成本</li></ol><h2 id="3-恋爱"><a href="#3-恋爱" class="headerlink" title="3.恋爱"></a>3.恋爱</h2><p>分为下面多个阶段</p><h3 id="陌生人到男女朋友-暧昧期"><a href="#陌生人到男女朋友-暧昧期" class="headerlink" title="陌生人到男女朋友(暧昧期)"></a>陌生人到男女朋友(暧昧期)</h3><p>为什么会有的人自来熟(一见如故),因为他默认把你当作他多年的朋友.</p><p><strong>距离:你觉得近 就近,你觉得渊就远</strong></p><p>什么时候调:把对方当作你的情人</p><p>男女朋友(状态):</p><ol><li>直接开始吃饭</li><li>直接开始约会</li><li>直接做男女朋友的事</li></ol><h3 id="吸引"><a href="#吸引" class="headerlink" title="吸引"></a>吸引</h3><p>被你吸引事因为:</p><ol><li>被你这个人的世界所吸引(朋友圈,显示high value)</li><li>再这个领域事top(篮球)</li><li>会才艺(做饭)</li><li>处于焦点(经常出现,刷脸熟,容易被人记住)</li></ol><blockquote><p>人在专注的时候,别人会被你的世界吸引过来</p></blockquote><h3 id="激情"><a href="#激情" class="headerlink" title="激情"></a>激情</h3><p>好奇心(想了解你这个人的一切)</p><p>如何保持激情,就是保持好奇心,就是增加神秘感(你有你的世界,如果被知道了,就再增加)</p><h3 id="平淡"><a href="#平淡" class="headerlink" title="平淡"></a>平淡</h3><p>淡下去了,就去增加自己的神秘感</p><p>美好的声音≠好妻子</p><blockquote><p>结婚,找舒服的,想出舒服(情绪稳定,不要找个祖宗)(闹啊,你不爱我呀,打电话啊)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;人机解剖&quot;&gt;&lt;a href=&quot;#人机解剖&quot; class=&quot;headerlink&quot; title=&quot;人机解剖&quot;&gt;&lt;/a&gt;人机解剖&lt;/h1&gt;&lt;h2 id=&quot;1-什么叫魅力&quot;&gt;&lt;a href=&quot;#1-什么叫魅力&quot; class=&quot;headerlink&quot; title=&quot;1.什</summary>
      
    
    
    
    
    <category term="社会学" scheme="http://yoursite.com/tags/%E7%A4%BE%E4%BC%9A%E5%AD%A6/"/>
    
    <category term="多萝西" scheme="http://yoursite.com/tags/%E5%A4%9A%E8%90%9D%E8%A5%BF/"/>
    
  </entry>
  
  <entry>
    <title>pa1.1小结</title>
    <link href="http://yoursite.com/2022/11/19/pa1-1%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2022/11/19/pa1-1%E5%B0%8F%E7%BB%93/</id>
    <published>2022-11-19T12:41:21.000Z</published>
    <updated>2022-11-19T13:25:04.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pa1-1"><a href="#pa1-1" class="headerlink" title="pa1.1"></a>pa1.1</h1><p>本章主要是要求大家进行使用构建完成简易表达式，主要包括单步执行，打印寄存器，还有扫描内存</p><blockquote><p>为什么使用static，因为使用static可以解决两个c文件有相同函数名的问题，不会造成编译问题</p></blockquote><h2 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h2><p>但不执行，我们可以看到远吗使用的cmdc这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_c</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line"><span class="comment">//    -1是65535最大的2的64-1</span></span><br><span class="line">  cpu_exec(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用cpu_exec代表就是直接执行，使用-1，因为这是uint，无符号，-1的无符号就是最大值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cpu_exec</span><span class="params">(<span class="type">uint64_t</span> n)</span> &#123;</span><br><span class="line">  g_print_step = (n &lt; MAX_INST_TO_PRINT);</span><br><span class="line">  <span class="keyword">switch</span> (nemu_state.state) &#123;</span><br><span class="line">    <span class="keyword">case</span> NEMU_END: <span class="keyword">case</span> NEMU_ABORT:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Program execution has ended. To restart the program, exit NEMU and run again.\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">default</span>: nemu_state.state = NEMU_RUNNING;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以我们只需要对当前的函数，进行查找出需要执行的步数，然后调用cpu——exec来进行执行代码</p><p>使用strtok来进行抽取参数就可以</p><p>然后转换函数可以直接使用atoi</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_si</span><span class="params">(<span class="type">char</span> *args)</span>&#123;</span><br><span class="line">    <span class="comment">/* extract the first argument */</span></span><br><span class="line">    <span class="comment">/*get steps,default is 1*/</span></span><br><span class="line">    <span class="type">char</span> *arg = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(arg==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">/* no argument given */</span></span><br><span class="line">        i=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt; <span class="built_in">strlen</span>(arg);j++)&#123;</span><br><span class="line">            i=i*<span class="number">10</span>+arg[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    printf(&quot;%s&quot;,arg);</span></span><br><span class="line">    cpu_exec(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印寄存器"><a href="#打印寄存器" class="headerlink" title="打印寄存器"></a>打印寄存器</h2><blockquote><p>打印寄存器就更简单了. 不过既然寄存器的结构是ISA相关的, 我们希望能为简易调试器屏蔽ISA的差异. 框架代码已经为大家准备了如下的API:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// nemu/src/isa/$ISA/reg.c</span><br><span class="line">void isa_reg_display(void);</span><br></pre></td></tr></table></figure><p>执行<code>info r</code>之后, 就调用<code>isa_reg_display()</code>, 在里面直接通过<code>printf()</code>输出所有寄存器的值即可. 如果你从来没有使用过<code>printf()</code>, 请RTFM或者STFW. 如果你不知道要输出什么, 你可以参考GDB中的输出.</p></blockquote><p>这个因为我们使用的riscv，所以需要去riscv里面进行修改isa——display这个函数。</p><p>直接调用isa，主要思路就是在reg里面进行遍历每一个寄存器，然后reg里面有gpr这个可以直接获取值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">isa_reg_display</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line"><span class="comment">//        printf(&quot;%s %s&quot;,regs[i],isa_reg_str2val(regs[i],false));</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-3s :0x%08lx |  \n&quot;</span>, regs[i], cpu.gpr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扫描内存"><a href="#扫描内存" class="headerlink" title="扫描内存"></a>扫描内存</h2><p>这个意思就是求出地址附近的10个值。如何求出值，观看rtfsc，可以发现调用vaddr，传入地址，还有字节数就行。默认riscv一个地址有4B，所以我们就传入就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_x</span><span class="params">(<span class="type">char</span> *args)</span>&#123;</span><br><span class="line">    <span class="comment">/* get N info,with the start of exp*/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * vaddr_read(addr,len),这个len是长度的意思，单位是byte，一条指令默认4B，所以取的4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span> *arg= strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> N=atoi(arg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">paddr_t</span> exprs=<span class="number">0x80000000</span>;</span><br><span class="line"><span class="comment">//    printf(&quot;0x%08x&quot;,exprs);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    printf(&quot;Address    Dword block ... Byte sequence\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%8x  0x%08lx\n&quot;</span>,exprs + i*<span class="number">4</span>,vaddr_read(exprs + i * <span class="number">4</span>,<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后地址的话，每次都是更新4，。直接+4就可以</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说还是比较简单的，但是由于是第一次接触到这种作业，还是查了不少资料。重点还是要看jyy的2020ics的习题课</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pa1-1&quot;&gt;&lt;a href=&quot;#pa1-1&quot; class=&quot;headerlink&quot; title=&quot;pa1.1&quot;&gt;&lt;/a&gt;pa1.1&lt;/h1&gt;&lt;p&gt;本章主要是要求大家进行使用构建完成简易表达式，主要包括单步执行，打印寄存器，还有扫描内存&lt;/p&gt;
&lt;blockquo</summary>
      
    
    
    
    
    <category term="pa" scheme="http://yoursite.com/tags/pa/"/>
    
  </entry>
  
  <entry>
    <title>leetcode150</title>
    <link href="http://yoursite.com/2022/11/19/leetcode150/"/>
    <id>http://yoursite.com/2022/11/19/leetcode150/</id>
    <published>2022-11-19T12:33:58.000Z</published>
    <updated>2022-11-19T12:40:39.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-150"><a href="#leetcode-150" class="headerlink" title="leetcode 150"></a>leetcode 150</h1><blockquote><p>Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a>.</p><p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. Each operand may be an integer or another expression.</p><p><strong>Note</strong> that division between two integers should truncate toward zero.</p><p>It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.</p></blockquote><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>本题是给你了逆波兰表达式，让你自己求，这个结果。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们可以发现，这个就是后缀表达式，使用后缀遍历，然后我们也可以发现，这个树的叶子节点就是数字。</p><p>整体思路就是遍历这个字符串，然后发现是数字就push到stack里面，然后发现是符号就pop出来两个数字，对他进行操作。</p><p>最后返回栈顶元素</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 简单的后缀表达式求和</span></span><br><span class="line">        set&lt;string&gt; rec;</span><br><span class="line">        rec.<span class="built_in">insert</span>(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">        rec.<span class="built_in">insert</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        rec.<span class="built_in">insert</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        rec.<span class="built_in">insert</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:tokens)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(rec.<span class="built_in">find</span>(i)!=rec.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="type">int</span> a=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> b=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line">                    s.<span class="built_in">push</span>(a+b);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line">                    s.<span class="built_in">push</span>(b-a);</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line">                    s.<span class="built_in">push</span>((<span class="type">long</span> <span class="type">long</span>)a*(<span class="type">long</span> <span class="type">long</span> )b);</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    s.<span class="built_in">push</span>(b/a);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">atoi</span>(i.<span class="built_in">c_str</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcode-150&quot;&gt;&lt;a href=&quot;#leetcode-150&quot; class=&quot;headerlink&quot; title=&quot;leetcode 150&quot;&gt;&lt;/a&gt;leetcode 150&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Evaluate the valu</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="后序遍历" scheme="http://yoursite.com/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode148</title>
    <link href="http://yoursite.com/2022/11/19/leetcode148/"/>
    <id>http://yoursite.com/2022/11/19/leetcode148/</id>
    <published>2022-11-19T12:13:00.000Z</published>
    <updated>2022-11-19T12:33:46.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-148"><a href="#leetcode-148" class="headerlink" title="leetcode 148"></a>leetcode 148</h1><blockquote><p>Given the <code>head</code> of a linked list, return <em>the list after sorting it in <strong>ascending order</strong></em>.</p></blockquote><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16688601431171668860143064.png"></p><blockquote><p><strong>Follow up:</strong> Can you sort the linked list in <code>O(n logn)</code> time and <code>O(1)</code> memory (i.e. constant space)?</p></blockquote><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>把链表进行排序输出，但是只能使用o1的空间，nlogn的时间。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用nlogn的方法来进行排序只有快排还有归并，但是都是用来递归，那空间就是on。所以只能使用迭代的方法来进行排序。</p><p>地带也是给予归并的，就是我们手动从下到上，手动进行排序。排序完成一层厚，再次进行下一层来排序。</p><p>现在我们进行引进dummy还有cur，dummy使用尾插法，来构建新的完整的链表（这是新一层的）</p><p>每一层开始的时候p&#x3D;q&#x3D;head，</p><p>然后q多走i补来达到下一组的开始</p><p>然后引进p还有q，pq是两组的开头，对pq进行循环遍历，次数小于1,2,4，（这是分组的方式）。同事还有一个 o，o是2i的位置（表示新的一组开始进行排序，连接），这个都是用cur来进行尾插法。之后再把head&#x3D;o，开始进行下一组</p><p>完成一层厚，我们让head&#x3D;dummy-》next。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><blockquote><p><code>[4,3,1,7,8,9,2,11,5,6]</code>.这个进行排序</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">step=<span class="number">1</span>: (<span class="number">3</span>-&gt;<span class="number">4</span>)-&gt;(<span class="number">1</span>-&gt;<span class="number">7</span>)-&gt;(<span class="number">8</span>-&gt;<span class="number">9</span>)-&gt;(<span class="number">2</span>-&gt;<span class="number">11</span>)-&gt;(<span class="number">5</span>-&gt;<span class="number">6</span>)</span><br><span class="line">step=<span class="number">2</span>: (<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">7</span>)-&gt;(<span class="number">2</span>-&gt;<span class="number">8</span>-&gt;<span class="number">9</span>-&gt;<span class="number">11</span>)-&gt;(<span class="number">5</span>-&gt;<span class="number">6</span>)</span><br><span class="line">step=<span class="number">4</span>: (<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">7</span>-&gt;<span class="number">8</span>-&gt;<span class="number">9</span>-&gt;<span class="number">11</span>)-&gt;(<span class="number">5</span>-&gt;<span class="number">6</span>)</span><br><span class="line">step=<span class="number">8</span>: (<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>-&gt;<span class="number">7</span>-&gt;<span class="number">8</span>-&gt;<span class="number">9</span>-&gt;<span class="number">11</span>)</span><br></pre></td></tr></table></figure><p>我们可以看第一轮i&#x3D;1，dummy-&gt;next表示step1这个完整的链表（3417.。），cur都是尾插法，然后p&#x3D;4，q&#x3D;3，o&#x3D;1，34</p><p>结束后就是head&#x3D;o，p&#x3D;head&#x3D;1，q&#x3D;7，然后接着进行更新</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="comment">/*1.首先求出长度n</span></span><br><span class="line"><span class="comment">   2.第一个for i是求出层数</span></span><br><span class="line"><span class="comment">   3.第二个for是求出分了几组，想领2gei是一组</span></span><br><span class="line"><span class="comment">   4.然后对q走到下一个开头，p是当前的开头</span></span><br><span class="line"><span class="comment">   5.对o走到2i的位置，使他们可以接着循环</span></span><br><span class="line"><span class="comment">   6.之后就是常规的归并方法使用while</span></span><br><span class="line"><span class="comment">   7.一层遍历结束完成后，让cur-&gt;next=null,同事更新head为dummy-》nexzt表示新的开头</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用地带进行排序</span></span><br><span class="line">        <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i*=<span class="number">2</span>)&#123;</span><br><span class="line">             <span class="keyword">auto</span> dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//  dummy指示的是一层的开始</span></span><br><span class="line">            cur=dummy;</span><br><span class="line">            <span class="comment">//第一层循环是层数，从第一个开始,1,2,4</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j+=<span class="number">2</span>*i)&#123;</span><br><span class="line">                <span class="comment">//第二个循环是组好，然后进行比较</span></span><br><span class="line">                <span class="comment">//  在组好开始进行排序 这是一次组里的比较</span></span><br><span class="line">               </span><br><span class="line">                <span class="comment">// auto cur=dummy;使用cur来进行插入</span></span><br><span class="line">                <span class="keyword">auto</span> p=head;<span class="comment">//第一组开始</span></span><br><span class="line">                 <span class="keyword">auto</span> q=p;<span class="comment">//第二组开始</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//找到下一个组开始的0号</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i&amp;&amp;q;k++)&#123;</span><br><span class="line">                    q=q-&gt;next;</span><br><span class="line">                    <span class="comment">//下一组的开始</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">auto</span> o=q;<span class="comment">//下一组的开始标签，使用2i开始</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i&amp;&amp;o;k++)&#123;</span><br><span class="line">                    o=o-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 两个开始,第一组开始都是1开始比较</span></span><br><span class="line">                <span class="keyword">while</span>(p&amp;&amp;q&amp;&amp;l&lt;i&amp;&amp;r&lt;i)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p-&gt;val&lt;q-&gt;val)&#123;</span><br><span class="line">                        l++;</span><br><span class="line">                     cur-&gt;next=p;</span><br><span class="line">                     cur=cur-&gt;next;</span><br><span class="line">                     p=p-&gt;next;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        r++;</span><br><span class="line">                        cur-&gt;next=q;</span><br><span class="line">                        cur=cur-&gt;next;</span><br><span class="line">                        q=q-&gt;next;</span><br><span class="line">                        <span class="comment">//尾插法</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(p&amp;&amp;l&lt;i)&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                     cur-&gt;next=p;</span><br><span class="line">                     cur=cur-&gt;next; </span><br><span class="line">                     p=p-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(q&amp;&amp;r&lt;i)&#123;</span><br><span class="line">                   r++;</span><br><span class="line">                        cur-&gt;next=q;</span><br><span class="line">                        cur=cur-&gt;next;</span><br><span class="line">                        q=q-&gt;next;</span><br><span class="line">                        <span class="comment">//尾插法 </span></span><br><span class="line">                &#125;</span><br><span class="line">                head=o;<span class="comment">//下一次开始</span></span><br><span class="line">                <span class="comment">// cout&lt;&lt;head-&gt;val&lt;&lt;&quot; &quot;;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 整个结束了，插入到开始</span></span><br><span class="line">            cur-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">//尾插法，是因为要保持开始的顺序不变</span></span><br><span class="line">            head=dummy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcode-148&quot;&gt;&lt;a href=&quot;#leetcode-148&quot; class=&quot;headerlink&quot; title=&quot;leetcode 148&quot;&gt;&lt;/a&gt;leetcode 148&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Given the &lt;code&gt;h</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="linked list" scheme="http://yoursite.com/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>pa配置vscode</title>
    <link href="http://yoursite.com/2022/11/18/pa%E9%85%8D%E7%BD%AEvscode/"/>
    <id>http://yoursite.com/2022/11/18/pa%E9%85%8D%E7%BD%AEvscode/</id>
    <published>2022-11-18T12:59:12.000Z</published>
    <updated>2022-11-19T07:18:38.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pa配置vscode"><a href="#pa配置vscode" class="headerlink" title="pa配置vscode"></a>pa配置vscode</h1><h2 id="1-为什么会写这一个"><a href="#1-为什么会写这一个" class="headerlink" title="1.为什么会写这一个"></a>1.为什么会写这一个</h2><p>目前正在写nju pa。pa是用makefile进行构建的，然后使用了多个自定义宏，导致，无法进行，直接的和之前一样，按一下run就可以运行。所以得进行手动配置。</p><p>还有就是，没有使用ide进行编码，导致一堆{}对齐的问题，然后找bug比较难受</p><h2 id="2-配置方法"><a href="#2-配置方法" class="headerlink" title="2.配置方法"></a>2.配置方法</h2><p>根据jyy<a href="https://www.bilibili.com/video/BV1qa4y1j7xk?p=4&vd_source=d043013c6aa637931d747eae4c52b842">的课程</a>在1小时16分钟左右的时候，只需要进行vscode配置一会儿就可以正常使用。把defines里面进行添加宏就可以，这个宏如何查找，在第三届讲makefile的时候介绍过。我们使用make -nB(可以进行强制编译所有的)然后我们使用vim</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16687772080711668777207848.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make -nB \</span><br><span class="line"> | grep -ve &#x27;^\(\#\|echo\|mkdir\)&#x27; \</span><br><span class="line"> | vim -</span><br></pre></td></tr></table></figure><p>然后进行搜索 -D ，这个参数就是在编译里面加入自定义宏，然后我们把这些宏进行拷贝过来，使用管道连接，去除echo 还有mkidr，传递给vim，vim用搜索按钮查找就可以</p><h2 id="3-vscode配置教程"><a href="#3-vscode配置教程" class="headerlink" title="3.vscode配置教程"></a>3.vscode配置教程</h2><p>参考教程：<a href="https://zhuanlan.zhihu.com/p/87864677">https://zhuanlan.zhihu.com/p/87864677</a></p><ol><li>安装c++插件</li><li>安装远程开发（我是用的虚拟机，进行ssh开发）</li><li>之后就是通过ssh连接虚拟机，然后插件安装后，进行设置</li><li>进行配置c_cpp_properties.json，在defines进行添加宏（无人其他改动）</li><li><strong>接下来就是配置gdb</strong></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;__GUESR_ISA__=riscv64&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;_GNU_SOURCE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;__STDC_CONSTANT_MACROS&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;__STDC_FORMAT_MACROS&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;__STDC_LIMIT_MACROS&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++14&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux-clang-x64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>gdb配置有坑：</p><p>参考下面 ： <a href="https://www.youtube.com/watch?v=9VpiGwp8Vos&amp;ab_channel=SavvyNik">https://www.youtube.com/watch?v=9VpiGwp8Vos&amp;ab_channel=SavvyNik</a></p><p>我们要进行配置gdb，就得要在编译过程加入- g ，这个可以在makefile发现是在build.mk里面的，我们加入-g选项。然后还得设置launch.json</p><p>参考如下：<a href="https://blog.csdn.net/zztiger123/article/details/105544640">https://blog.csdn.net/zztiger123/article/details/105544640</a></p><p>修改program为build下面那个输出的，然后cwd，修改为nemu的目录</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) Launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;/nemu/build/riscv64-nemu-interpreter&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;-b&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stopAtConnect&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;/nemu&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这个结束之后，有个坑，jyy在is_mode_batch这个函数设置为true，我用gdb就追踪不了，我输入p命令的结果，把那个函数值设置为false就可以走正常流程，进行追踪。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;make&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;make -j8&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: gcc 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="4-clion应该也一样"><a href="#4-clion应该也一样" class="headerlink" title="4.clion应该也一样"></a>4.clion应该也一样</h2><p>明天有空在进行配置clion，修改自定义make目标，然后进行添加，可以参考下面的连接</p><p><a href="https://www.jetbrains.com/help/clion/custom-build-targets.html#custom-rundebug">https://www.jetbrains.com/help/clion/custom-build-targets.html#custom-rundebug</a></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>pa确实难，对于我这个非科班跨考的。不过感觉也学到挺多知识的，好的大学，课程真的可以和没过高校的课程差不多，现在才做完1.2，还得接着写。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pa配置vscode&quot;&gt;&lt;a href=&quot;#pa配置vscode&quot; class=&quot;headerlink&quot; title=&quot;pa配置vscode&quot;&gt;&lt;/a&gt;pa配置vscode&lt;/h1&gt;&lt;h2 id=&quot;1-为什么会写这一个&quot;&gt;&lt;a href=&quot;#1-为什么会写这一个&quot;</summary>
      
    
    
    
    
    <category term="pa" scheme="http://yoursite.com/tags/pa/"/>
    
    <category term="nemu" scheme="http://yoursite.com/tags/nemu/"/>
    
    <category term="vscode" scheme="http://yoursite.com/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>学习技巧</title>
    <link href="http://yoursite.com/2022/11/18/%E5%AD%A6%E4%B9%A0%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2022/11/18/%E5%AD%A6%E4%B9%A0%E6%8A%80%E5%B7%A7/</id>
    <published>2022-11-18T09:48:27.000Z</published>
    <updated>2022-11-18T12:51:26.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-学习技巧"><a href="#1-学习技巧" class="headerlink" title="1.学习技巧"></a>1.学习技巧</h1><p>来源于youtube 的crashcourse 里面分为10节进行讲述，如何学习。一个半小时左右可以看完，还是很不错的。具体连接如下</p><p><a href="https://youtu.be/IhuwS5ZLwKY">https://youtu.be/IhuwS5ZLwKY</a></p><p>看完了这个视频，解决了我研一所与到的多个问题，是使用笔记本还是手写做笔记。做笔记的方法有哪些怎么进行读书</p><h2 id="1-1学会做笔记"><a href="#1-1学会做笔记" class="headerlink" title="1.1学会做笔记"></a>1.1学会做笔记</h2><p>分为下面几个重点</p><p>1.<strong>工具</strong></p><ol><li>电脑</li><li>传统的笔记本</li></ol><blockquote><p><strong>研究表明，使用电脑的打字速度会更快，但是，打字只会让自己变成一个记忆机器，没有自己的思考。人的大佬不能并行处理时间（打字还有进行思考），所以得需要使用纸币来进行记录，这样不会进行打断思路</strong></p></blockquote><p>2.<strong>记录内容</strong></p><ol><li>idea</li><li>专业术语</li><li>例子</li></ol><p>3.<strong>笔记记录方式</strong></p><ol><li>思维导图，xmind</li><li>cmu笔记，使用左边hint，右边笔记，下面是总结</li><li>总结（目录法），就是word</li></ol><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16687713222201668771322176.png" alt="word大纲"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16687713750721668771374689.png"></p><h2 id="1-2读书"><a href="#1-2读书" class="headerlink" title="1.2读书"></a>1.2读书</h2><p>只能处理4-7bit的信息</p><p>看论文的方法</p><p>如何学习可课本教科书</p><ol><li>简介</li><li>标题</li><li>课后习题</li></ol><p><strong>如何快速的阅读</strong></p><ol><li>设置时间ddl</li><li>使用highlight</li><li>使用跳读,(跳过 and,or)</li><li>消除默读现象</li></ol><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16687716960771668771695525.png"></p><p>广泛的阅读还有其他多看书</p><ol><li>观点花点</li><li>论证的用破折号</li></ol><h2 id="1-3回忆与记忆"><a href="#1-3回忆与记忆" class="headerlink" title="1.3回忆与记忆"></a>1.3回忆与记忆</h2><p>recall&amp;memory</p><p>工作记忆只能处理4-7位的信息</p><p>长期记忆需要进行连接</p><p>记忆喜欢记得是图像,有形的(使用注记法),就是被关键词,使用联想法</p><p>然后就是记忆衰退的方法,多次检索,就会容易回忆(就是多次开始记录)</p><p>盒子记录：就是anki，会的就进入下一个盒子，不会的就重新回到第一个盒子</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16687725300721668772529814.png"></p><p>，每天学习，没三天学习</p><h2 id="1-4如何做组织管理"><a href="#1-4如何做组织管理" class="headerlink" title="1.4如何做组织管理"></a>1.4如何做组织管理</h2><p>这一节，解决了我之前想的，到底如何进行处理数据。使用日历+todo+笔记系统（calendar+todo+typora）</p><p>学习必须要在学习环境，在图书馆，或者咖啡店</p><p><strong>及时捕获自己的想法</strong></p><ol><li>任务</li><li>事件</li><li>还有知识</li><li>想法（论文的idea）</li></ol><p><strong>输出自己的想法</strong></p><ol><li>写作</li><li>代码</li></ol><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16687728890711668772888770.png"></p><p><strong>记录自己的戒指信息还有任务详情</strong></p><p>谷歌日历来进行记录</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16687730720801668773071545.png"></p><p>云端笔记如何记录：</p><blockquote><p>使用电脑结构，跟目录，时间，课程</p></blockquote><p>quick catch：</p><ol><li>当时有的信息，就储存下来</li><li>使用todo，记录今天发生的事件</li></ol><p>每周计划还有每日计划</p><ol><li>每个星期天来做（分成几个小块）</li><li><strong>杂事（全部在一起处理）</strong></li><li>还要复盘，每周（什么做了。什么没做）</li></ol><p>为什么无法坚持，因为熵增定律</p><h2 id="1-5如何专注"><a href="#1-5如何专注" class="headerlink" title="1.5如何专注"></a>1.5如何专注</h2><blockquote><p>这个解决了，我为什么感觉什么都没有学到专注不了自己喜欢的东西</p></blockquote><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16687735320721668773531358.png"></p><p>基于任务的（做数学题），自顶向下的，但是会匹配</p><p>如何加强自己</p><ol><li>环境</li><li>兴趣爱好</li><li>还有大脑的状态</li></ol><p><strong>加强自己专注</strong></p><ol><li>去图书馆（健身房就会自己想去健身）</li><li>停止多线程，经常切换，会让自己的大脑没有思路</li><li>关闭手机（断网，有时候多就是少，关闭手机还有电脑）（请勿打扰）</li><li>把我任务进行结块（摘要，结论，研究方法，实验）</li><li>使用forset或者番茄土豆（不要切换任务）</li><li>还要学会放松</li></ol><h2 id="1-6拖延症"><a href="#1-6拖延症" class="headerlink" title="1.6拖延症"></a>1.6拖延症</h2><blockquote><p>又是一个好的course，给解决拖延症提供了思路</p></blockquote><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16687744690781668774468167.png"></p><p>预期可以考到那个学校（求其上这得中）</p><p>价值越高（就是工作给的钱，就不会不拖延）</p><p>冲动做其他的事，拖延的时间越长，就容易拖延（</p><p><strong>减少冲动</strong></p><ol><li>分解任务</li></ol><p><strong>寻求帮助</strong></p><ol><li><p>成立学习小组</p></li><li><p>提高奖励（看完论文和朋友看电影</p></li><li><p>提高体验（打游戏，很久时间）</p></li><li><p>去图书馆</p></li><li><p>使用block进行阻挡网络</p></li><li><p>使用番茄土豆</p></li></ol><p><strong>进行娱乐</strong></p><h2 id="1-10体育学习"><a href="#1-10体育学习" class="headerlink" title="1.10体育学习"></a>1.10体育学习</h2><p>健身版提供助学习，还是要运动。 </p><p>用进废退</p><p>定期训练</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-学习技巧&quot;&gt;&lt;a href=&quot;#1-学习技巧&quot; class=&quot;headerlink&quot; title=&quot;1.学习技巧&quot;&gt;&lt;/a&gt;1.学习技巧&lt;/h1&gt;&lt;p&gt;来源于youtube 的crashcourse 里面分为10节进行讲述，如何学习。一个半小时左右可以看完，还</summary>
      
    
    
    
    
    <category term="crash course" scheme="http://yoursite.com/tags/crash-course/"/>
    
    <category term="学习方法" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机网络</title>
    <link href="http://yoursite.com/2022/11/18/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2022/11/18/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2022-11-18T09:32:01.000Z</published>
    <updated>2022-11-18T09:46:59.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vmware桥接没有网络"><a href="#vmware桥接没有网络" class="headerlink" title="vmware桥接没有网络"></a>vmware桥接没有网络</h1><p>好久没有登录虚拟机，虚拟机的桥接出现问题。我以为是这个虚拟机iso的问题。于是我对manjaro这个linux进行折腾了半天。从下午折腾到晚上。</p><p>主要包括，自己手动进行网络配置，然后重新建立网卡，还使用其他网络工具。最后我对网络进行啥用nat可以联网，但是使用nat联网，我的jetbrains gateway的配置识别不了，换了nat的ip也进不去。于是我准备使用新的iso，同时在manjaro里面下载github，把我写的代码进行上传。manjaro仓库有github第三方，可以直接下载。然后我是用deepin进行安装，安装完成后，我也是使用桥接的方式来进行连接，结果发现网络还是连接不了。那我就意识到是vmware的问题，于是我去stfw，网上进行搜索，发现这个问题是因为vmwarre进行桥接的时候识别不了，本机现在联网的网卡，需要自己手动设置。我 手动设置之后，结果两个linux都连上网了，又是折腾了一下午。</p><p>主要还是对manjaro这个系统不熟悉，我看到他的问题，显示已经连上网络，但是不能上网，我就以为是可能香谷歌那种，只是上不了谷歌才显示的，于是就以为是linux的问题。但是deepin安装完成后，直接就是显示网络平已经断开，所以，我才觉得是虚拟机的问题。</p><hr><p>总结</p><ol><li>主要是对manjaro这个linux发行版不熟悉</li><li>然后就是vmaware这个软件的bug</li></ol><p>具体解决方法</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16687647390781668764738161.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vmware桥接没有网络&quot;&gt;&lt;a href=&quot;#vmware桥接没有网络&quot; class=&quot;headerlink&quot; title=&quot;vmware桥接没有网络&quot;&gt;&lt;/a&gt;vmware桥接没有网络&lt;/h1&gt;&lt;p&gt;好久没有登录虚拟机，虚拟机的桥接出现问题。我以为是这个虚拟机</summary>
      
    
    
    
    
    <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>多源bfs</title>
    <link href="http://yoursite.com/2022/11/12/%E5%A4%9A%E6%BA%90bfs/"/>
    <id>http://yoursite.com/2022/11/12/%E5%A4%9A%E6%BA%90bfs/</id>
    <published>2022-11-12T13:26:33.000Z</published>
    <updated>2022-11-12T14:04:01.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多源bfs-amp-最小树"><a href="#多源bfs-amp-最小树" class="headerlink" title="多源bfs&amp;最小树"></a>多源bfs&amp;最小树</h1><h2 id="0-证明"><a href="#0-证明" class="headerlink" title="0.证明"></a>0.证明</h2><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16682604660491668260465791.png"></p><p>归纳法,开始为0,不用证明</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16682605600491668260559129.png"></p><p>去除对头的第一个元素x,可以加入3个x+1的元素,最多有两端</p><p>两个特性,一般是队列,前面是x,后面是x+1</p><p>默认开始的元素是最小值,喝dij的使用优先队列的最小值一样.</p><p>入队就是最小值的</p><h2 id="1-bfs"><a href="#1-bfs" class="headerlink" title="1.bfs"></a>1.bfs</h2><h3 id="1-1矩阵距离"><a href="#1-1矩阵距离" class="headerlink" title="1.1矩阵距离"></a>1.1矩阵距离</h3><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16682596642021668259663290.png"></p><blockquote><p>大致意识就是求每个位置到1的最短距离</p></blockquote><p>这个就是求最短路,求每个点到一堆起点的距离,建立一个虚拟起点,让1 作为起点开始寻找,然后使用虚拟起点,连接所有的 1</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16682598242021668259823715.png"></p><p>思路:先把所有是1的位置加入到queue里面,距离是0</p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16682603282041668260328053.png"></p><p>重点是找到放入所有的值,还有一个就是进行更新,tt&#x3D;-1</p><hr><p>总体思路如下</p><ol><li>使用1作为开始的点,把所有的1进行插入到队列</li><li>之后就是常规bfs,进行pop</li><li>然后第二阶段就是搜索周围的元素,找到符合的元素,二姐没有被使用(没有被使用就是距离为-1),使用的直接continue</li><li>然后进行更新,更新之后在把他插入到队列里面,</li></ol><h2 id="2-魔棒"><a href="#2-魔棒" class="headerlink" title="2.魔棒"></a>2.魔棒</h2><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16682614080511668261407501.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16682616770571668261677035.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16682616960541668261695181.png"></p><p><img src="https://fastly.jsdelivr.net/gh/weijia99/blog_image@main/16682617290551668261728112.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多源bfs-amp-最小树&quot;&gt;&lt;a href=&quot;#多源bfs-amp-最小树&quot; class=&quot;headerlink&quot; title=&quot;多源bfs&amp;amp;最小树&quot;&gt;&lt;/a&gt;多源bfs&amp;amp;最小树&lt;/h1&gt;&lt;h2 id=&quot;0-证明&quot;&gt;&lt;a href=&quot;#0-证明&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
